<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 7. Optimization</title><link rel="stylesheet" href="mysql-html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.1 Reference Manual"><link rel="prev" href="backup-and-recovery.html" title="Chapter 6. Backup and Recovery"><link rel="next" href="language-structure.html" title="Chapter 8. Language Structure"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 7. Optimization</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="backup-and-recovery.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="language-structure.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="optimization"></a>Chapter 7. Optimization</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="optimization.html#optimize-overview">7.1. Optimization Overview</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#design-limitations">7.1.1. MySQL Design Limitations and Tradeoffs</a></span></dt><dt><span class="section"><a href="optimization.html#portability">7.1.2. Designing Applications for Portability</a></span></dt><dt><span class="section"><a href="optimization.html#internal-use">7.1.3. What We Have Used MySQL For</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">7.1.4. The MySQL Benchmark Suite</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">7.1.5. Using Your Own Benchmarks</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#query-speed">7.2. Optimizing <code class="literal">SELECT</code> and Other Statements</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#using-explain">7.2.1. Optimizing Queries with <code class="literal">EXPLAIN</code></a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">7.2.2. Estimating Query Performance</a></span></dt><dt><span class="section"><a href="optimization.html#select-speed">7.2.3. Speed of <code class="literal">SELECT</code> Queries</a></span></dt><dt><span class="section"><a href="optimization.html#where-optimizations">7.2.4. <code class="literal">WHERE</code> Clause Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">7.2.5. Range Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">7.2.6. Index Merge Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#condition-pushdown-optimization">7.2.7. Condition Pushdown Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">7.2.8. <code class="literal">IS NULL</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#left-join-optimization">7.2.9. <code class="literal">LEFT JOIN</code> and <code class="literal">RIGHT JOIN</code>
        Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#nested-joins">7.2.10. Nested Join Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">7.2.11. Outer Join Simplification</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">7.2.12. <code class="literal">ORDER BY</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">7.2.13. <code class="literal">GROUP BY</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">7.2.14. <code class="literal">DISTINCT</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#in-subquery-optimization">7.2.15. Optimizing <code class="literal">IN</code>/<code class="literal">=ANY</code> Subqueries</a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">7.2.16. <code class="literal">LIMIT</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#how-to-avoid-table-scan">7.2.17. How to Avoid Table Scans</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">7.2.18. <code class="literal">INFORMATION_SCHEMA</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#insert-speed">7.2.19. Speed of <code class="literal">INSERT</code> Statements</a></span></dt><dt><span class="section"><a href="optimization.html#update-speed">7.2.20. Speed of <code class="literal">UPDATE</code> Statements</a></span></dt><dt><span class="section"><a href="optimization.html#delete-speed">7.2.21. Speed of <code class="literal">DELETE</code> Statements</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">7.2.22. Other Optimization Tips</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#locking-issues">7.3. Locking Issues</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#internal-locking">7.3.1. Internal Locking Methods</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">7.3.2. Table Locking Issues</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">7.3.3. Concurrent Inserts</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">7.3.4. External Locking</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-database-structure">7.4. Optimizing Database Structure</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#design">7.4.1. Design Choices</a></span></dt><dt><span class="section"><a href="optimization.html#data-size">7.4.2. Make Your Data as Small as Possible</a></span></dt><dt><span class="section"><a href="optimization.html#indexes">7.4.3. Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">7.4.4. Multiple-Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-indexes">7.4.5. How MySQL Uses Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">7.4.6. The <code class="literal">MyISAM</code> Key Cache</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">7.4.7. <code class="literal">MyISAM</code> Index Statistics Collection</a></span></dt><dt><span class="section"><a href="optimization.html#table-cache">7.4.8. How MySQL Opens and Closes Tables</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">7.4.9. Drawbacks to Creating Many Tables in the Same Database</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#optimizing-the-server">7.5. Optimizing the MySQL Server</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#system-optimization">7.5.1. System Factors and Startup Parameter Tuning</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">7.5.2. Tuning Server Parameters</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">7.5.3. Controlling Query Optimizer Performance</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache">7.5.4. The MySQL Query Cache</a></span></dt><dt><span class="section"><a href="optimization.html#thread-information">7.5.5. Examining Thread Information</a></span></dt><dt><span class="section"><a href="optimization.html#compile-and-link-options">7.5.6. How Compiling and Linking Affects the Speed of MySQL</a></span></dt><dt><span class="section"><a href="optimization.html#connection-threads">7.5.7. How MySQL Uses Threads for Client Connections</a></span></dt><dt><span class="section"><a href="optimization.html#memory-use">7.5.8. How MySQL Uses Memory</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">7.5.9. How MySQL Uses Internal Temporary Tables</a></span></dt><dt><span class="section"><a href="optimization.html#dns">7.5.10. How MySQL Uses DNS</a></span></dt></dl></dd><dt><span class="section"><a href="optimization.html#disk-issues">7.6. Disk Issues</a></span></dt><dd><dl><dt><span class="section"><a href="optimization.html#symbolic-links">7.6.1. Using Symbolic Links</a></span></dt></dl></dd></dl></div><p>
    Optimization is a complex task because ultimately it requires
    understanding of the entire system to be optimized. Although it may
    be possible to perform some local optimizations with little
    knowledge of your system or application, the more optimal you want
    your system to become, the more you must know about it.
  </p><p>
    This chapter tries to explain and give some examples of different
    ways to optimize MySQL. Remember, however, that there are always
    additional ways to make the system even faster, although they may
    require increasing effort to achieve.
  </p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimize-overview"></a>7.1. Optimization Overview</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#design-limitations">7.1.1. MySQL Design Limitations and Tradeoffs</a></span></dt><dt><span class="section"><a href="optimization.html#portability">7.1.2. Designing Applications for Portability</a></span></dt><dt><span class="section"><a href="optimization.html#internal-use">7.1.3. What We Have Used MySQL For</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-benchmarks">7.1.4. The MySQL Benchmark Suite</a></span></dt><dt><span class="section"><a href="optimization.html#custom-benchmarks">7.1.5. Using Your Own Benchmarks</a></span></dt></dl></div><p>
      The most important factor in making a system fast is its basic
      design. You must also know what kinds of processing your system is
      doing, and what its bottlenecks are. In most cases, system
      bottlenecks arise from these sources:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          Disk seeks. It takes time for the disk to find a piece of
          data. With modern disks, the mean time for this is usually
          lower than 10ms, so we can in theory do about 100 seeks a
          second. This time improves slowly with new disks and is very
          hard to optimize for a single table. The way to optimize seek
          time is to distribute the data onto more than one disk.
        </p></li><li><p>
          Disk reading and writing. When the disk is at the correct
          position, we need to read the data. With modern disks, one
          disk delivers at least 10–20MB/s throughput. This is
          easier to optimize than seeks because you can read in parallel
          from multiple disks.
        </p></li><li><p>
          CPU cycles. When we have the data in main memory, we need to
          process it to get our result. Having small tables compared to
          the amount of memory is the most common limiting factor. But
          with small tables, speed is usually not the problem.
        </p></li><li><p>
          Memory bandwidth. When the CPU needs more data than can fit in
          the CPU cache, main memory bandwidth becomes a bottleneck.
          This is an uncommon bottleneck for most systems, but one to be
          aware of.
        </p></li></ul></div><p class="mnmas"><b>MySQL Enterprise</b>
        For instant notification of system bottlenecks subscribe to the
        MySQL Enterprise Monitor. For more information, see
        <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="design-limitations"></a>7.1.1. MySQL Design Limitations and Tradeoffs</h3></div></div></div><a class="indexterm" name="id2049133"></a><a class="indexterm" name="id2049145"></a><p>
        When using the <code class="literal">MyISAM</code> storage engine, MySQL
        uses extremely fast table locking that allows multiple readers
        or a single writer. The biggest problem with this storage engine
        occurs when you have a steady stream of mixed updates and slow
        selects on a single table. If this is a problem for certain
        tables, you can use another storage engine for them. See
        <a href="storage-engines.html" title="Chapter 13. Storage Engines">Chapter 13, <i>Storage Engines</i></a>.
      </p><p>
        MySQL can work with both transactional and non-transactional
        tables. To make it easier to work smoothly with
        non-transactional tables (which cannot roll back if something
        goes wrong), MySQL has the following rules. Note that these
        rules apply <span class="emphasis"><em>only</em></span> when not running in strict
        SQL mode or if you use the <code class="literal">IGNORE</code> specifier
        for <code class="literal">INSERT</code> or <code class="literal">UPDATE</code>.
      </p><a class="indexterm" name="id2049203"></a><div class="itemizedlist"><ul type="disc"><li><p>
            All columns have default values.
          </p></li><li><p>
            If you insert an inappropriate or out-of-range value into a
            column, MySQL sets the column to the “<span class="quote">best possible
            value</span>” instead of reporting an error. For numerical
            values, this is 0, the smallest possible value or the
            largest possible value. For strings, this is either the
            empty string or as much of the string as can be stored in
            the column.
          </p></li><li><p>
            All calculated expressions return a value that can be used
            instead of signaling an error condition. For example, 1/0
            returns <code class="literal">NULL</code>.
          </p></li></ul></div><p>
        To change the preceding behaviors, you can enable stricter data
        handling by setting the server SQL mode appropriately. For more
        information about data handling, see
        <a href="introduction.html#constraints" title="1.8.6. How MySQL Deals with Constraints">Section 1.8.6, “How MySQL Deals with Constraints”</a>,
        <a href="server-administration.html#server-sql-mode" title="5.1.7. SQL Modes">Section 5.1.7, “SQL Modes”</a>, and <a href="sql-syntax.html#insert" title="12.2.4. INSERT Syntax">Section 12.2.4, “<code class="literal">INSERT</code> Syntax”</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portability"></a>7.1.2. Designing Applications for Portability</h3></div></div></div><a class="indexterm" name="id2049277"></a><a class="indexterm" name="id2049286"></a><a class="indexterm" name="id2049295"></a><p>
        Because all SQL servers implement different parts of standard
        SQL, it takes work to write portable database applications. It
        is very easy to achieve portability for very simple selects and
        inserts, but becomes more difficult the more capabilities you
        require. If you want an application that is fast with many
        database systems, it becomes even more difficult.
      </p><p>
        All database systems have some weak points. That is, they have
        different design compromises that lead to different behavior.
      </p><p>
        To make a complex application portable, you need to determine
        which SQL servers it must work with, and then determine what
        features those servers support. You can use the MySQL
        <span><strong class="command">crash-me</strong></span> program to find functions, types,
        and limits that you can use with a selection of database
        servers. <span><strong class="command">crash-me</strong></span> does not check for every
        possible feature, but it is still reasonably comprehensive,
        performing about 450 tests. An example of the type of
        information <span><strong class="command">crash-me</strong></span> can provide is that you
        should not use column names that are longer than 18 characters
        if you want to be able to use Informix or DB2.
      </p><p>
        The <span><strong class="command">crash-me</strong></span> program and the MySQL benchmarks
        are all very database independent. By taking a look at how they
        are written, you can get a feeling for what you must do to make
        your own applications database independent. The programs can be
        found in the <code class="filename">sql-bench</code> directory of MySQL
        source distributions. They are written in Perl and use the DBI
        database interface. Use of DBI in itself solves part of the
        portability problem because it provides database-independent
        access methods. See <a href="optimization.html#mysql-benchmarks" title="7.1.4. The MySQL Benchmark Suite">Section 7.1.4, “The MySQL Benchmark Suite”</a>.
      </p><p>
        If you strive for database independence, you need to get a good
        feeling for each SQL server's bottlenecks. For example, MySQL is
        very fast in retrieving and updating rows for
        <code class="literal">MyISAM</code> tables, but has a problem in mixing
        slow readers and writers on the same table. Transactional
        database systems in general are not very good at generating
        summary tables from log tables, because in this case row locking
        is almost useless.
      </p><p class="mnmas"><b>MySQL Enterprise</b>
          For expert advice on choosing the database engine suitable to
          your circumstances subscribe to the MySQL Enterprise Monitor.
          For more information, see
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p><p>
        To make your application <span class="emphasis"><em>really</em></span> database
        independent, you should define an easily extendable interface
        through which you manipulate your data. For example, C++ is
        available on most systems, so it makes sense to use a C++
        class-based interface to the databases.
      </p><p>
        If you use some feature that is specific to a given database
        system (such as the <code class="literal">REPLACE</code> statement, which
        is specific to MySQL), you should implement the same feature for
        other SQL servers by coding an alternative method. Although the
        alternative might be slower, it enables the other servers to
        perform the same tasks.
      </p><p>
        With MySQL, you can use the <code class="literal">/*! */</code> syntax to
        add MySQL-specific keywords to a statement. The code inside
        <code class="literal">/* */</code> is treated as a comment (and ignored)
        by most other SQL servers. For information about writing
        comments, see <a href="language-structure.html#comments" title="8.5. Comment Syntax">Section 8.5, “Comment Syntax”</a>.
      </p><p>
        If high performance is more important than exactness, as for
        some Web applications, it is possible to create an application
        layer that caches all results to give you even higher
        performance. By letting old results expire after a while, you
        can keep the cache reasonably fresh. This provides a method to
        handle high load spikes, in which case you can dynamically
        increase the cache size and set the expiration timeout higher
        until things get back to normal.
      </p><p>
        In this case, the table creation information should contain
        information about the initial cache size and how often the table
        should normally be refreshed.
      </p><p>
        An attractive alternative to implementing an application cache
        is to use the MySQL query cache. By enabling the query cache,
        the server handles the details of determining whether a query
        result can be reused. This simplifies your application. See
        <a href="optimization.html#query-cache" title="7.5.4. The MySQL Query Cache">Section 7.5.4, “The MySQL Query Cache”</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="internal-use"></a>7.1.3. What We Have Used MySQL For</h3></div></div></div><a class="indexterm" name="id2049477"></a><a class="indexterm" name="id2049490"></a><p>
        This section describes an early application for MySQL.
      </p><p>
        During MySQL initial development, the features of MySQL were
        made to fit our largest customer, which handled data warehousing
        for a couple of the largest retailers in Sweden.
      </p><p>
        From all stores, we got weekly summaries of all bonus card
        transactions, and were expected to provide useful information
        for the store owners to help them find how their advertising
        campaigns were affecting their own customers.
      </p><p>
        The volume of data was quite huge (about seven million summary
        transactions per month), and we had data for 4–10 years
        that we needed to present to the users. We got weekly requests
        from our customers, who wanted instant access to new reports
        from this data.
      </p><p>
        We solved this problem by storing all information per month in
        compressed “<span class="quote">transaction tables.</span>” We had a set of
        simple macros that generated summary tables grouped by different
        criteria (product group, customer id, store, and so on) from the
        tables in which the transactions were stored. The reports were
        Web pages that were dynamically generated by a small Perl
        script. This script parsed a Web page, executed the SQL
        statements in it, and inserted the results. We would have used
        PHP or <span><strong class="command">mod_perl</strong></span> instead, but they were not
        available at the time.
      </p><p>
        For graphical data, we wrote a simple tool in C that could
        process SQL query results and produce GIF images based on those
        results. This tool also was dynamically executed from the Perl
        script that parses the Web pages.
      </p><p>
        In most cases, a new report could be created simply by copying
        an existing script and modifying the SQL query that it used. In
        some cases, we needed to add more columns to an existing summary
        table or generate a new one. This also was quite simple because
        we kept all transaction-storage tables on disk. (This amounted
        to about 50GB of transaction tables and 200GB of other customer
        data.)
      </p><p>
        We also let our customers access the summary tables directly
        with ODBC so that the advanced users could experiment with the
        data themselves.
      </p><p>
        This system worked well and we had no problems handling the data
        with quite modest Sun Ultra SPARCstation hardware
        (2×200MHz). Eventually the system was migrated to Linux.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-benchmarks"></a>7.1.4. The MySQL Benchmark Suite</h3></div></div></div><a class="indexterm" name="id2049576"></a><a class="indexterm" name="id2049585"></a><p>
        This benchmark suite is meant to tell any user what operations a
        given SQL implementation performs well or poorly. You can get a
        good idea for how the benchmarks work by looking at the code and
        results in the <code class="filename">sql-bench</code> directory in any
        MySQL source distribution.
      </p><p>
        Note that this benchmark is single-threaded, so it measures the
        minimum time for the operations performed. We plan to add
        multi-threaded tests to the benchmark suite in the future.
      </p><p>
        To use the benchmark suite, the following requirements must be
        satisfied:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            The benchmark suite is provided with MySQL source
            distributions. You can either download a released
            distribution from <a href="http://dev.mysql.com/downloads/" target="_top">http://dev.mysql.com/downloads/</a>, or
            use the current development source tree. (See
            <a href="installing.html#installing-source-tree" title="2.9.3. Installing from the Development Source Tree">Section 2.9.3, “Installing from the Development Source Tree”</a>.)
          </p></li><li><p>
            The benchmark scripts are written in Perl and use the Perl
            DBI module to access database servers, so DBI must be
            installed. You also need the server-specific DBD drivers for
            each of the servers you want to test. For example, to test
            MySQL, PostgreSQL, and DB2, you must have the
            <code class="literal">DBD::mysql</code>, <code class="literal">DBD::Pg</code>,
            and <code class="literal">DBD::DB2</code> modules installed. See
            <a href="installing.html#perl-support" title="2.15. Perl Installation Notes">Section 2.15, “Perl Installation Notes”</a>.
          </p></li></ul></div><p>
        After you obtain a MySQL source distribution, you can find the
        benchmark suite located in its <code class="filename">sql-bench</code>
        directory. To run the benchmark tests, build MySQL, and then
        change location into the <code class="filename">sql-bench</code>
        directory and execute the <code class="literal">run-all-tests</code>
        script:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cd sql-bench</code></strong>
shell&gt; <strong class="userinput"><code>perl run-all-tests --server=<em class="replaceable"><code>server_name</code></em></code></strong>
</pre><p>
        <em class="replaceable"><code>server_name</code></em> should be the name of one
        of the supported servers. To get a list of all options and
        supported servers, invoke this command:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>perl run-all-tests --help</code></strong>
</pre><a class="indexterm" name="id2049731"></a><p>
        The <span><strong class="command">crash-me</strong></span> script also is located in the
        <code class="filename">sql-bench</code> directory.
        <span><strong class="command">crash-me</strong></span> tries to determine what features a
        database system supports and what its capabilities and
        limitations are by actually running queries. For example, it
        determines:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            What data types are supported
          </p></li><li><p>
            How many indexes are supported
          </p></li><li><p>
            What functions are supported
          </p></li><li><p>
            How big a query can be
          </p></li><li><p>
            How big a <code class="literal">VARCHAR</code> column can be
          </p></li></ul></div><p>
        For more information about benchmark results, visit
        <a href="http://www.mysql.com/why-mysql/benchmarks/" target="_top">http://www.mysql.com/why-mysql/benchmarks/</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="custom-benchmarks"></a>7.1.5. Using Your Own Benchmarks</h3></div></div></div><a class="indexterm" name="id2049824"></a><a class="indexterm" name="id2049833"></a><p>
        You should definitely benchmark your application and database to
        find out where the bottlenecks are. After fixing one bottleneck
        (or by replacing it with a “<span class="quote">dummy</span>” module), you can
        proceed to identify the next bottleneck. Even if the overall
        performance for your application currently is acceptable, you
        should at least make a plan for each bottleneck and decide how
        to solve it if someday you really need the extra performance.
      </p><p>
        For examples of portable benchmark programs, look at those in
        the MySQL benchmark suite. See
        <a href="optimization.html#mysql-benchmarks" title="7.1.4. The MySQL Benchmark Suite">Section 7.1.4, “The MySQL Benchmark Suite”</a>. You can take any program
        from this suite and modify it for your own needs. By doing this,
        you can try different solutions to your problem and test which
        really is fastest for you.
      </p><p>
        Another free benchmark suite is the Open Source Database
        Benchmark, available at
        <a href="http://osdb.sourceforge.net/" target="_top">http://osdb.sourceforge.net/</a>.
      </p><p>
        It is very common for a problem to occur only when the system is
        very heavily loaded. We have had many customers who contact us
        when they have a (tested) system in production and have
        encountered load problems. In most cases, performance problems
        turn out to be due to issues of basic database design (for
        example, table scans are not good under high load) or problems
        with the operating system or libraries. Most of the time, these
        problems would be much easier to fix if the systems were not
        already in production.
      </p><p>
        To avoid problems like this, you should put some effort into
        benchmarking your whole application under the worst possible
        load:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            The <span><strong class="command">mysqlslap</strong></span> program can be helpful for
            simulating a high load produced by multiple clients issuing
            queries simultaneously. See <a href="programs.html#mysqlslap" title="4.5.7. mysqlslap — Load Emulation Client">Section 4.5.7, “<span><strong class="command">mysqlslap</strong></span> — Load Emulation Client”</a>.
          </p></li><li><p>
            You can also try Super Smack, available at
            <a href="http://jeremy.zawodny.com/mysql/super-smack/" target="_top">http://jeremy.zawodny.com/mysql/super-smack/</a>.
          </p></li></ul></div><p>
        As suggested by the names of these programs, they can bring a
        system to its knees, so make sure to use them only on your
        development systems.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="query-speed"></a>7.2. Optimizing <code class="literal">SELECT</code> and Other Statements</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#using-explain">7.2.1. Optimizing Queries with <code class="literal">EXPLAIN</code></a></span></dt><dt><span class="section"><a href="optimization.html#estimating-performance">7.2.2. Estimating Query Performance</a></span></dt><dt><span class="section"><a href="optimization.html#select-speed">7.2.3. Speed of <code class="literal">SELECT</code> Queries</a></span></dt><dt><span class="section"><a href="optimization.html#where-optimizations">7.2.4. <code class="literal">WHERE</code> Clause Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#range-optimization">7.2.5. Range Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-optimization">7.2.6. Index Merge Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#condition-pushdown-optimization">7.2.7. Condition Pushdown Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#is-null-optimization">7.2.8. <code class="literal">IS NULL</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#left-join-optimization">7.2.9. <code class="literal">LEFT JOIN</code> and <code class="literal">RIGHT JOIN</code>
        Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#nested-joins">7.2.10. Nested Join Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#outer-join-simplification">7.2.11. Outer Join Simplification</a></span></dt><dt><span class="section"><a href="optimization.html#order-by-optimization">7.2.12. <code class="literal">ORDER BY</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#group-by-optimization">7.2.13. <code class="literal">GROUP BY</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#distinct-optimization">7.2.14. <code class="literal">DISTINCT</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#in-subquery-optimization">7.2.15. Optimizing <code class="literal">IN</code>/<code class="literal">=ANY</code> Subqueries</a></span></dt><dt><span class="section"><a href="optimization.html#limit-optimization">7.2.16. <code class="literal">LIMIT</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#how-to-avoid-table-scan">7.2.17. How to Avoid Table Scans</a></span></dt><dt><span class="section"><a href="optimization.html#information-schema-optimization">7.2.18. <code class="literal">INFORMATION_SCHEMA</code> Optimization</a></span></dt><dt><span class="section"><a href="optimization.html#insert-speed">7.2.19. Speed of <code class="literal">INSERT</code> Statements</a></span></dt><dt><span class="section"><a href="optimization.html#update-speed">7.2.20. Speed of <code class="literal">UPDATE</code> Statements</a></span></dt><dt><span class="section"><a href="optimization.html#delete-speed">7.2.21. Speed of <code class="literal">DELETE</code> Statements</a></span></dt><dt><span class="section"><a href="optimization.html#miscellaneous-optimization-tips">7.2.22. Other Optimization Tips</a></span></dt></dl></div><a class="indexterm" name="id2049944"></a><a class="indexterm" name="id2049956"></a><a class="indexterm" name="id2049968"></a><p>
      First, one factor affects all statements: The more complex your
      permissions setup, the more overhead you have. Using simpler
      permissions when you issue <code class="literal">GRANT</code> statements
      enables MySQL to reduce permission-checking overhead when clients
      execute statements. For example, if you do not grant any
      table-level or column-level privileges, the server need not ever
      check the contents of the <code class="literal">tables_priv</code> and
      <code class="literal">columns_priv</code> tables. Similarly, if you place no
      resource limits on any accounts, the server does not have to
      perform resource counting. If you have a very high
      statement-processing load, it may be worth the time to use a
      simplified grant structure to reduce permission-checking overhead.
    </p><p>
      If your problem is with a specific MySQL expression or function,
      you can perform a timing test by invoking the
      <a href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a> function using the
      <span><strong class="command">mysql</strong></span> client program. Its syntax is
      <a href="functions.html#function_benchmark"><code class="literal">BENCHMARK(<em class="replaceable"><code>loop_count</code></em>,<em class="replaceable"><code>expression</code></em>)</code></a>.
      The return value is always zero, but <span><strong class="command">mysql</strong></span>
      prints a line displaying approximately how long the statement took
      to execute. For example:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT BENCHMARK(1000000,1+1);</code></strong>
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</pre><p>
      This result was obtained on a Pentium II 400MHz system. It shows
      that MySQL can execute 1,000,000 simple addition expressions in
      0.32 seconds on that system.
    </p><p>
      All MySQL functions should be highly optimized, but there may be
      some exceptions. <a href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a> is an
      excellent tool for finding out if some function is a problem for
      your queries.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="using-explain"></a>7.2.1. Optimizing Queries with <code class="literal">EXPLAIN</code></h3></div></div></div><a class="indexterm" name="id2050089"></a><a class="indexterm" name="id2050098"></a><p>
        The <code class="literal">EXPLAIN</code> statement can be used either as a
        synonym for <code class="literal">DESCRIBE</code> or as a way to obtain
        information about how MySQL executes a <code class="literal">SELECT</code>
        statement:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">EXPLAIN
            <em class="replaceable"><code>tbl_name</code></em></code> is synonymous
            with <code class="literal">DESCRIBE
            <em class="replaceable"><code>tbl_name</code></em></code> or
            <code class="literal">SHOW COLUMNS FROM
            <em class="replaceable"><code>tbl_name</code></em></code>:
          </p><pre class="programlisting">EXPLAIN <em class="replaceable"><code>tbl_name</code></em>
</pre></li><li><p>
            When you precede a <code class="literal">SELECT</code> statement with
            the keyword <code class="literal">EXPLAIN</code>, MySQL displays
            information from the optimizer about the query execution
            plan. That is, MySQL explains how it would process the
            <code class="literal">SELECT</code>, including information about how
            tables are joined and in which order:

</p><pre class="programlisting">EXPLAIN [EXTENDED | PARTITIONS] SELECT <em class="replaceable"><code>select_options</code></em>
</pre><p>
          </p></li><li><p>
            <code class="literal">EXPLAIN PARTITIONS</code> is available beginning
            with MySQL 5.1.5. It is useful only when examining queries
            involving partitioned tables. For details, see
            <a href="partitioning.html#partitioning-info" title="21.3.4. Obtaining Information About Partitions">Section 21.3.4, “Obtaining Information About Partitions”</a>.
          </p></li></ul></div><p>
        This section describes the second use of
        <code class="literal">EXPLAIN</code> for obtaining query execution plan
        information. See also <a href="sql-syntax.html#explain" title="12.3.2. EXPLAIN Syntax">Section 12.3.2, “<code class="literal">EXPLAIN</code> Syntax”</a>. For a
        description of the <code class="literal">DESCRIBE</code> and <code class="literal">SHOW
        COLUMNS</code> statements, see <a href="sql-syntax.html#describe" title="12.3.1. DESCRIBE Syntax">Section 12.3.1, “<code class="literal">DESCRIBE</code> Syntax”</a>,
        and <a href="sql-syntax.html#show-columns" title="12.5.5.6. SHOW COLUMNS Syntax">Section 12.5.5.6, “<code class="literal">SHOW COLUMNS</code> Syntax”</a>.
      </p><p>
        <a class="indexterm" name="id2050270"></a>

        With the help of <code class="literal">EXPLAIN</code>, you can see where
        you should add indexes to tables to get a faster
        <code class="literal">SELECT</code> that uses indexes to find rows. You
        can also use <code class="literal">EXPLAIN</code> to check whether the
        optimizer joins the tables in an optimal order. To give a hint
        to the optimizer to use a join order corresponding to the order
        in which the tables are named in the <code class="literal">SELECT</code>
        statement, begin the statement with <code class="literal">SELECT
        STRAIGHT_JOIN</code> rather than just
        <code class="literal">SELECT</code>. (See <a href="sql-syntax.html#select" title="12.2.7. SELECT Syntax">Section 12.2.7, “<code class="literal">SELECT</code> Syntax”</a>.)
      </p><p>
        If you have a problem with indexes not being used when you
        believe that they should be, you should run <code class="literal">ANALYZE
        TABLE</code> to update table statistics such as cardinality
        of keys, that can affect the choices the optimizer makes. See
        <a href="sql-syntax.html#analyze-table" title="12.5.2.1. ANALYZE TABLE Syntax">Section 12.5.2.1, “<code class="literal">ANALYZE TABLE</code> Syntax”</a>.
      </p><p>
        <code class="literal">EXPLAIN</code> returns a row of information for each
        table used in the <code class="literal">SELECT</code> statement. The
        tables are listed in the output in the order that MySQL would
        read them while processing the query. MySQL resolves all joins
        using a <em class="firstterm">single-sweep multi-join</em> method.
        This means that MySQL reads a row from the first table, and then
        finds a matching row in the second table, the third table, and
        so on. When all tables are processed, MySQL outputs the selected
        columns and backtracks through the table list until a table is
        found for which there are more matching rows. The next row is
        read from this table and the process continues with the next
        table.
      </p><p>
        When the <code class="literal">EXTENDED</code> keyword is used,
        <code class="literal">EXPLAIN</code> produces extra information that can
        be viewed by issuing a <code class="literal">SHOW WARNINGS</code>
        statement following the <code class="literal">EXPLAIN</code> statement.
        This information displays how the optimizer qualifies table and
        column names in the <code class="literal">SELECT</code> statement, what
        the <code class="literal">SELECT</code> looks like after the application
        of rewriting and optimization rules, and possibly other notes
        about the optimization process. <code class="literal">EXPLAIN
        EXTENDED</code> also displays the <code class="literal">filtered</code>
        column as of MySQL 5.1.12.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          You cannot use the <code class="literal">EXTENDED</code> and
          <code class="literal">PARTITIONS</code> keywords together in the same
          <code class="literal">EXPLAIN</code> statement.
        </p></div><p>
        Each output row from <code class="literal">EXPLAIN</code> provides
        information about one table, and each row contains the following
        columns:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">id</code>
          </p><p>
            The <code class="literal">SELECT</code> identifier. This is the
            sequential number of the <code class="literal">SELECT</code> within
            the query.
          </p></li><li><p>
            <code class="literal">select_type</code>
          </p><p>
            The type of <code class="literal">SELECT</code>, which can be any of
            those shown in the following table:
          </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><code class="literal">SIMPLE</code></td><td>Simple <code class="literal">SELECT</code> (not using <code class="literal">UNION</code> or
                    subqueries)</td></tr><tr><td><code class="literal">PRIMARY</code></td><td>Outermost <code class="literal">SELECT</code></td></tr><tr><td><code class="literal">UNION</code></td><td>Second or later <code class="literal">SELECT</code> statement in a
                    <code class="literal">UNION</code></td></tr><tr><td><code class="literal">DEPENDENT UNION</code></td><td>Second or later <code class="literal">SELECT</code> statement in a
                    <code class="literal">UNION</code>, dependent on outer query</td></tr><tr><td><code class="literal">UNION RESULT</code></td><td>Result of a <code class="literal">UNION</code>.</td></tr><tr><td><code class="literal">SUBQUERY</code></td><td>First <code class="literal">SELECT</code> in subquery</td></tr><tr><td><code class="literal">DEPENDENT SUBQUERY</code></td><td>First <code class="literal">SELECT</code> in subquery, dependent on outer query</td></tr><tr><td><code class="literal">DERIVED</code></td><td>Derived table <code class="literal">SELECT</code> (subquery in
                    <code class="literal">FROM</code> clause)</td></tr><tr><td><code class="literal">UNCACHEABLE SUBQUERY</code></td><td>A subquery for which the result cannot be cached and must be
                    re-evaluated for each row of the outer query</td></tr><tr><td><code class="literal">UNCACHEABLE UNION</code></td><td>The second or later select in a <code class="literal">UNION</code> that belongs to
                    an uncacheable subquery (see <code class="literal">UNCACHEABLE
                    SUBQUERY</code>)</td></tr></tbody></table></div><p>
            <code class="literal">DEPENDENT</code> typically signifies the use of
            a correlated subquery. See
            <a href="sql-syntax.html#correlated-subqueries" title="12.2.8.7. Correlated Subqueries">Section 12.2.8.7, “Correlated Subqueries”</a>.
          </p><p>
            “<span class="quote">DEPENDENT SUBQUERY</span>” evaluation differs from
            <code class="literal">UNCACHEABLE SUBQUERY</code> evaluation. For
            “<span class="quote">DEPENDENT SUBQUERY</span>”, the subquery is
            re-evaluated only once for each set of different values of
            the variables from its outer context. For
            <code class="literal">UNCACHEABLE SUBQUERY</code>, the subquery is
            re-evaluated for each row of the outer context. Cacheability
            of subqueries is subject to the restrictions detailed in
            <a href="optimization.html#query-cache-how" title="7.5.4.1. How the Query Cache Operates">Section 7.5.4.1, “How the Query Cache Operates”</a>. For example, referring to
            user variables makes a subquery uncacheable.
          </p></li><li><p>
            <code class="literal">table</code>
          </p><p>
            The table to which the row of output refers.
          </p></li><li><p>
            <code class="literal">type</code>
          </p><p>
            The join type. The different join types are listed here,
            ordered from the best type to the worst:
          </p><div class="itemizedlist"><ul type="circle"><li><p>
                <a class="indexterm" name="id2050828"></a>

                <a class="indexterm" name="id2050840"></a>

                <code class="literal">system</code>
              </p><p>
                The table has only one row (= system table). This is a
                special case of the <code class="literal">const</code> join type.
              </p></li><li><p>
                <a class="indexterm" name="id2050875"></a>

                <a class="indexterm" name="id2050888"></a>

                <code class="literal">const</code>
              </p><p>
                The table has at most one matching row, which is read at
                the start of the query. Because there is only one row,
                values from the column in this row can be regarded as
                constants by the rest of the optimizer.
                <code class="literal">const</code> tables are very fast because
                they are read only once.
              </p><p>
                <code class="literal">const</code> is used when you compare all
                parts of a <code class="literal">PRIMARY KEY</code> or
                <code class="literal">UNIQUE</code> index to constant values. In
                the following queries,
                <em class="replaceable"><code>tbl_name</code></em> can be used as a
                <code class="literal">const</code> table:
              </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>primary_key</code></em>=1;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>primary_key_part1</code></em>=1 AND <em class="replaceable"><code>primary_key_part2</code></em>=2;
</pre></li><li><p>
                <a class="indexterm" name="id2050981"></a>

                <code class="literal">eq_ref</code>
              </p><p>
                One row is read from this table for each combination of
                rows from the previous tables. Other than the
                <code class="literal">system</code> and <code class="literal">const</code>
                types, this is the best possible join type. It is used
                when all parts of an index are used by the join and the
                index is a <code class="literal">PRIMARY KEY</code> or
                <code class="literal">UNIQUE</code> index.
              </p><p>
                <code class="literal">eq_ref</code> can be used for indexed
                columns that are compared using the <code class="literal">=</code>
                operator. The comparison value can be a constant or an
                expression that uses columns from tables that are read
                before this table. In the following examples, MySQL can
                use an <code class="literal">eq_ref</code> join to process
                <em class="replaceable"><code>ref_table</code></em>:
              </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li><p>
                <a class="indexterm" name="id2051118"></a>

                <code class="literal">ref</code>
              </p><p>
                All rows with matching index values are read from this
                table for each combination of rows from the previous
                tables. <code class="literal">ref</code> is used if the join uses
                only a leftmost prefix of the key or if the key is not a
                <code class="literal">PRIMARY KEY</code> or
                <code class="literal">UNIQUE</code> index (in other words, if the
                join cannot select a single row based on the key value).
                If the key that is used matches only a few rows, this is
                a good join type.
              </p><p>
                <code class="literal">ref</code> can be used for indexed columns
                that are compared using the <code class="literal">=</code> or
                <code class="literal">&lt;=&gt;</code> operator. In the following
                examples, MySQL can use a <code class="literal">ref</code> join to
                process <em class="replaceable"><code>ref_table</code></em>:
              </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em> WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>;

SELECT * FROM <em class="replaceable"><code>ref_table</code></em>,<em class="replaceable"><code>other_table</code></em>
  WHERE <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part1</code></em>=<em class="replaceable"><code>other_table</code></em>.<em class="replaceable"><code>column</code></em>
  AND <em class="replaceable"><code>ref_table</code></em>.<em class="replaceable"><code>key_column_part2</code></em>=1;
</pre></li><li><p>
                <a class="indexterm" name="id2051272"></a>

                <code class="literal">fulltext</code>
              </p><p>
                The join is performed using a
                <code class="literal">FULLTEXT</code> index.
              </p></li><li><p>
                <a class="indexterm" name="id2051307"></a>

                <code class="literal">ref_or_null</code>
              </p><p>
                This join type is like <code class="literal">ref</code>, but with
                the addition that MySQL does an extra search for rows
                that contain <code class="literal">NULL</code> values. This join
                type optimization is used most often in resolving
                subqueries. In the following examples, MySQL can use a
                <code class="literal">ref_or_null</code> join to process
                <em class="replaceable"><code>ref_table</code></em>:
              </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>ref_table</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em>=<em class="replaceable"><code>expr</code></em> OR <em class="replaceable"><code>key_column</code></em> IS NULL;
</pre><p>
                See <a href="optimization.html#is-null-optimization" title="7.2.8. IS NULL Optimization">Section 7.2.8, “<code class="literal">IS NULL</code> Optimization”</a>.
              </p></li><li><p>
                <a class="indexterm" name="id2051387"></a>

                <code class="literal">index_merge</code>
              </p><p>
                This join type indicates that the Index Merge
                optimization is used. In this case, the
                <code class="literal">key</code> column in the output row contains
                a list of indexes used, and <code class="literal">key_len</code>
                contains a list of the longest key parts for the indexes
                used. For more information, see
                <a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">Section 7.2.6, “Index Merge Optimization”</a>.
              </p></li><li><p>
                <a class="indexterm" name="id2051434"></a>

                <code class="literal">unique_subquery</code>
              </p><p>
                This type replaces <code class="literal">ref</code> for some
                <code class="literal">IN</code> subqueries of the following form:
              </p><pre class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>primary_key</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre><p>
                <code class="literal">unique_subquery</code> is just an index
                lookup function that replaces the subquery completely
                for better efficiency.
              </p></li><li><p>
                <a class="indexterm" name="id2051504"></a>

                <code class="literal">index_subquery</code>
              </p><p>
                This join type is similar to
                <code class="literal">unique_subquery</code>. It replaces
                <code class="literal">IN</code> subqueries, but it works for
                non-unique indexes in subqueries of the following form:
              </p><pre class="programlisting"><em class="replaceable"><code>value</code></em> IN (SELECT <em class="replaceable"><code>key_column</code></em> FROM <em class="replaceable"><code>single_table</code></em> WHERE <em class="replaceable"><code>some_expr</code></em>)
</pre></li><li><p>
                <a class="indexterm" name="id2051564"></a>

                <code class="literal">range</code>
              </p><p>
                Only rows that are in a given range are retrieved, using
                an index to select the rows. The <code class="literal">key</code>
                column in the output row indicates which index is used.
                The <code class="literal">key_len</code> contains the longest key
                part that was used. The <code class="literal">ref</code> column is
                <code class="literal">NULL</code> for this type.
              </p><p>
                <code class="literal">range</code> can be used when a key column
                is compared to a constant using any of the
                <a href="functions.html#operator_equal"><code class="literal">=</code></a>,
                <a href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>,
                <a href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
                <a href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
                <a href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
                <a href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
                <a href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a>,
                <a href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
                <a href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>, or
                <a href="functions.html#function_in"><code class="literal">IN()</code></a> operators:
              </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> = 10;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> BETWEEN 10 and 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_column</code></em> IN (10,20,30);

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>= 10 AND <em class="replaceable"><code>key_part2</code></em> IN (10,20,30);
</pre></li><li><p>
                <a class="indexterm" name="id2051738"></a>

                <code class="literal">index</code>
              </p><p>
                This join type is the same as <code class="literal">ALL</code>,
                except that only the index tree is scanned. This usually
                is faster than <code class="literal">ALL</code> because the index
                file usually is smaller than the data file.
              </p><p>
                MySQL can use this join type when the query uses only
                columns that are part of a single index.
              </p></li><li><p>
                <a class="indexterm" name="id2051784"></a>

                <code class="literal">ALL</code>
              </p><p>
                A full table scan is done for each combination of rows
                from the previous tables. This is normally not good if
                the table is the first table not marked
                <code class="literal">const</code>, and usually
                <span class="emphasis"><em>very</em></span> bad in all other cases.
                Normally, you can avoid <code class="literal">ALL</code> by adding
                indexes that allow row retrieval from the table based on
                constant values or column values from earlier tables.
              </p></li></ul></div></li><li><p>
            <code class="literal">possible_keys</code>
          </p><p>
            The <code class="literal">possible_keys</code> column indicates which
            indexes MySQL can choose from use to find the rows in this
            table. Note that this column is totally independent of the
            order of the tables as displayed in the output from
            <code class="literal">EXPLAIN</code>. That means that some of the keys
            in <code class="literal">possible_keys</code> might not be usable in
            practice with the generated table order.
          </p><p>
            If this column is <code class="literal">NULL</code>, there are no
            relevant indexes. In this case, you may be able to improve
            the performance of your query by examining the
            <code class="literal">WHERE</code> clause to check whether it refers
            to some column or columns that would be suitable for
            indexing. If so, create an appropriate index and check the
            query with <code class="literal">EXPLAIN</code> again. See
            <a href="sql-syntax.html#alter-table" title="12.1.4. ALTER TABLE Syntax">Section 12.1.4, “<code class="literal">ALTER TABLE</code> Syntax”</a>.
          </p><p>
            To see what indexes a table has, use <code class="literal">SHOW INDEX
            FROM <em class="replaceable"><code>tbl_name</code></em></code>.
          </p></li><li><p>
            <code class="literal">key</code>
          </p><p>
            The <code class="literal">key</code> column indicates the key (index)
            that MySQL actually decided to use. If MySQL decides to use
            one of the <code class="literal">possible_keys</code> indexes to look
            up rows, that index is listed as the key value.
          </p><p>
            It is possible that <code class="literal">key</code> will name an
            index that is not present in the
            <code class="literal">possible_keys</code> value. This can happen if
            none of the <code class="literal">possible_keys</code> indexes are
            suitable for looking up rows, but all the columns selected
            by the query are columns of some other index. That is, the
            named index covers the selected columns, so although it is
            not used to determine which rows to retrieve, an index scan
            is more efficient than a data row scan.
          </p><p>
            For <code class="literal">InnoDB</code>, a secondary index might cover
            the selected columns even if the query also selects the
            primary key because <code class="literal">InnoDB</code> stores the
            primary key value with each secondary index. If
            <code class="literal">key</code> is <code class="literal">NULL</code>, MySQL
            found no index to use for executing the query more
            efficiently.
          </p><p>
            To force MySQL to use or ignore an index listed in the
            <code class="literal">possible_keys</code> column, use <code class="literal">FORCE
            INDEX</code>, <code class="literal">USE INDEX</code>, or
            <code class="literal">IGNORE INDEX</code> in your query. See
            <a href="sql-syntax.html#index-hints" title="12.2.7.2. Index Hint Syntax">Section 12.2.7.2, “Index Hint Syntax”</a>.
          </p><p>
            For <code class="literal">MyISAM</code> tables, running
            <code class="literal">ANALYZE TABLE</code> helps the optimizer choose
            better indexes. For <code class="literal">MyISAM</code> tables,
            <span><strong class="command">myisamchk --analyze</strong></span> does the same. See
            <a href="sql-syntax.html#analyze-table" title="12.5.2.1. ANALYZE TABLE Syntax">Section 12.5.2.1, “<code class="literal">ANALYZE TABLE</code> Syntax”</a>, and
            <a href="backup-and-recovery.html#table-maintenance" title="6.4. Table Maintenance and Crash Recovery">Section 6.4, “Table Maintenance and Crash Recovery”</a>.
          </p></li><li><p>
            <code class="literal">key_len</code>
          </p><p>
            The <code class="literal">key_len</code> column indicates the length
            of the key that MySQL decided to use. The length is
            <code class="literal">NULL</code> if the <code class="literal">key</code> column
            says <code class="literal">NULL</code>. Note that the value of
            <code class="literal">key_len</code> enables you to determine how many
            parts of a multiple-part key MySQL actually uses.
          </p></li><li><p>
            <code class="literal">ref</code>
          </p><p>
            The <code class="literal">ref</code> column shows which columns or
            constants are compared to the index named in the
            <code class="literal">key</code> column to select rows from the table.
          </p></li><li><p>
            <code class="literal">rows</code>
          </p><p>
            The <code class="literal">rows</code> column indicates the number of
            rows MySQL believes it must examine to execute the query.
          </p></li><li><p>
            <code class="literal">filtered</code>
          </p><p>
            The <code class="literal">filtered</code> column indicates an
            estimated percentage of table rows that will be filtered by
            the table condition. That is, <code class="literal">rows</code> shows
            the estimated number of rows examined and
            <code class="literal">rows</code> × <code class="literal">filtered</code>
            / <code class="literal">100</code> shows the number of rows that will
            be joined with previous tables. This column is displayed if
            you use <code class="literal">EXPLAIN EXTENDED</code>. (New in MySQL
            5.1.12)
          </p></li><li><p>
            <code class="literal">Extra</code>
          </p><p>
            This column contains additional information about how MySQL
            resolves the query. The following list explains the values
            that can appear in this column. If you want to make your
            queries as fast as possible, you should look out for
            <code class="literal">Extra</code> values of <code class="literal">Using
            filesort</code> and <code class="literal">Using temporary</code>.
          </p><div class="itemizedlist"><ul type="circle"><li><p>
                <code class="literal">Distinct</code>
              </p><p>
                MySQL is looking for distinct values, so it stops
                searching for more rows for the current row combination
                after it has found the first matching row.
              </p></li><li><p>
                <code class="literal">Full scan on NULL key</code>
              </p><p>
                This occurs for subquery optimization as a fallback
                strategy when the optimizer cannot use an index-lookup
                access method.
              </p></li><li><p>
                <code class="literal">Impossible WHERE noticed after reading const
                tables</code>
              </p><p>
                MySQL has read all <code class="literal">const</code> (and
                <code class="literal">system</code>) tables and notice that the
                <code class="literal">WHERE</code> clause is always false.
              </p></li><li><p>
                <code class="literal">No tables</code>
              </p><p>
                The query has no <code class="literal">FROM</code> clause, or has
                a <code class="literal">FROM DUAL</code> clause.
              </p></li><li><p>
                <code class="literal">Not exists</code>
              </p><p>
                MySQL was able to do a <code class="literal">LEFT JOIN</code>
                optimization on the query and does not examine more rows
                in this table for the previous row combination after it
                finds one row that matches the <code class="literal">LEFT
                JOIN</code> criteria. Here is an example of the type
                of query that can be optimized this way:
              </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
  WHERE t2.id IS NULL;
</pre><p>
                Assume that <code class="literal">t2.id</code> is defined as
                <code class="literal">NOT NULL</code>. In this case, MySQL scans
                <code class="literal">t1</code> and looks up the rows in
                <code class="literal">t2</code> using the values of
                <code class="literal">t1.id</code>. If MySQL finds a matching row
                in <code class="literal">t2</code>, it knows that
                <code class="literal">t2.id</code> can never be
                <code class="literal">NULL</code>, and does not scan through the
                rest of the rows in <code class="literal">t2</code> that have the
                same <code class="literal">id</code> value. In other words, for
                each row in <code class="literal">t1</code>, MySQL needs to do
                only a single lookup in <code class="literal">t2</code>,
                regardless of how many rows actually match in
                <code class="literal">t2</code>.
              </p></li><li><p>
                <code class="literal">Range checked for each record (index map:
                <em class="replaceable"><code>N</code></em>)</code>
              </p><p>
                MySQL found no good index to use, but found that some of
                indexes might be used after column values from preceding
                tables are known. For each row combination in the
                preceding tables, MySQL checks whether it is possible to
                use a <code class="literal">range</code> or
                <code class="literal">index_merge</code> access method to retrieve
                rows. This is not very fast, but is faster than
                performing a join with no index at all. The
                applicability criteria are as described in
                <a href="optimization.html#range-optimization" title="7.2.5. Range Optimization">Section 7.2.5, “Range Optimization”</a>, and
                <a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">Section 7.2.6, “Index Merge Optimization”</a>, with the
                exception that all column values for the preceding table
                are known and considered to be constants.
              </p><p>
                Indexes are numbered beginning with 1, in the same order
                as shown by <code class="literal">SHOW INDEX</code> for the table.
                The index map value <em class="replaceable"><code>N</code></em> is a
                bitmask value that indicates which indexes are
                candidates. For example, a value of
                <code class="literal">0x19</code> (binary 11001) means that
                indexes 1, 4, and 5 will be considered.
              </p></li><li><p>
                <code class="literal">Scanned <em class="replaceable"><code>N</code></em>
                databases</code>
              </p><p>
                This indicates how many directory scans the server
                performs when processing a query for
                <code class="literal">INFORMATION_SCHEMA</code> tables, as
                described in
                <a href="optimization.html#information-schema-optimization" title="7.2.18. INFORMATION_SCHEMA Optimization">Section 7.2.18, “<code class="literal">INFORMATION_SCHEMA</code> Optimization”</a>. The
                value of <em class="replaceable"><code>N</code></em> can be 0, 1, or
                <code class="literal">all</code>.
              </p></li><li><p>
                <code class="literal">Select tables optimized away</code>
              </p><p>
                The query contained only aggregate functions
                (<a href="functions.html#function_min"><code class="literal">MIN()</code></a>,
                <a href="functions.html#function_max"><code class="literal">MAX()</code></a>) that were all
                resolved using an index, or
                <a href="functions.html#function_count"><code class="literal">COUNT(*)</code></a> for
                <code class="literal">MyISAM</code>, and no <code class="literal">GROUP
                BY</code> clause. The optimizer determined that only
                one row should be returned.
              </p></li><li><p>
                <code class="literal">Skip_open_table</code>,
                <code class="literal">Open_frm_only</code>,
                <code class="literal">Open_trigger_only</code>,
                <code class="literal">Open_full_table</code>
              </p><p>
                These values indicate file-opening optimizations that
                apply to queries for
                <code class="literal">INFORMATION_SCHEMA</code> tables, as
                described in
                <a href="optimization.html#information-schema-optimization" title="7.2.18. INFORMATION_SCHEMA Optimization">Section 7.2.18, “<code class="literal">INFORMATION_SCHEMA</code> Optimization”</a>.
              </p><div class="itemizedlist"><ul type="square"><li><p>
                    <code class="literal">Skip_open_table</code>: Table files do
                    not need to be opened. The information has already
                    become available within the query by scanning the
                    database directory.
                  </p></li><li><p>
                    <code class="literal">Open_frm_only</code>: Only the table's
                    <code class="filename">.frm</code> file need be opened.
                  </p></li><li><p>
                    <code class="literal">Open_trigger_only</code>: Only the
                    table's <code class="filename">.TRG</code> file need be
                    opened.
                  </p></li><li><p>
                    <code class="literal">Open_full_table</code>: The unoptimized
                    information lookup. The <code class="filename">.frm</code>,
                    <code class="filename">.MYD</code>, and
                    <code class="filename">.MYI</code> files must be opened.
                  </p></li></ul></div></li><li><p>
                <code class="literal">Using filesort</code>
              </p><p>
                MySQL must do an extra pass to find out how to retrieve
                the rows in sorted order. The sort is done by going
                through all rows according to the join type and storing
                the sort key and pointer to the row for all rows that
                match the <code class="literal">WHERE</code> clause. The keys then
                are sorted and the rows are retrieved in sorted order.
                See <a href="optimization.html#order-by-optimization" title="7.2.12. ORDER BY Optimization">Section 7.2.12, “<code class="literal">ORDER BY</code> Optimization”</a>.
              </p></li><li><p>
                <code class="literal">Using index</code>
              </p><p>
                The column information is retrieved from the table using
                only information in the index tree without having to do
                an additional seek to read the actual row. This strategy
                can be used when the query uses only columns that are
                part of a single index.
              </p><p>
                For <code class="literal">InnoDB</code> tables that have a
                user-defined clustered index, that index can be used
                even when <code class="literal">Using index</code> is absent from
                the <code class="literal">Extra</code> column. This is the case if
                if <code class="literal">type</code> is <code class="literal">index</code>
                and <code class="literal">key</code> is
                <code class="literal">PRIMARY</code>.
              </p></li><li><p>
                <code class="literal">Using index for group-by</code>
              </p><p>
                Similar to the <code class="literal">Using index</code> table
                access method, <code class="literal">Using index for
                group-by</code> indicates that MySQL found an index
                that can be used to retrieve all columns of a
                <code class="literal">GROUP BY</code> or
                <code class="literal">DISTINCT</code> query without any extra disk
                access to the actual table. Additionally, the index is
                used in the most efficient way so that for each group,
                only a few index entries are read. For details, see
                <a href="optimization.html#group-by-optimization" title="7.2.13. GROUP BY Optimization">Section 7.2.13, “<code class="literal">GROUP BY</code> Optimization”</a>.
              </p></li><li><p>
                <code class="literal">Using join buffer</code>
              </p><p>
                Tables are read in portions into the join buffer, and
                then their rows are used from the buffer to perform the
                join.
              </p></li><li><p>
                <code class="literal">Using sort_union(...)</code>, <code class="literal">Using
                union(...)</code>, <code class="literal">Using
                intersect(...)</code>
              </p><p>
                These indicate how index scans are merged for the
                <code class="literal">index_merge</code> join type. See
                <a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">Section 7.2.6, “Index Merge Optimization”</a>.
              </p></li><li><p>
                <code class="literal">Using temporary</code>
              </p><p>
                To resolve the query, MySQL needs to create a temporary
                table to hold the result. This typically happens if the
                query contains <code class="literal">GROUP BY</code> and
                <code class="literal">ORDER BY</code> clauses that list columns
                differently.
              </p></li><li><p>
                <code class="literal">Using where</code>
              </p><p>
                A <code class="literal">WHERE</code> clause is used to restrict
                which rows to match against the next table or send to
                the client. Unless you specifically intend to fetch or
                examine all rows from the table, you may have something
                wrong in your query if the <code class="literal">Extra</code>
                value is not <code class="literal">Using where</code> and the
                table join type is <code class="literal">ALL</code> or
                <code class="literal">index</code>.
              </p></li><li><p>
                <code class="literal">Using where with pushed condition</code>
              </p><p>
                This item applies to <code class="literal">NDBCLUSTER</code>
                tables <span class="emphasis"><em>only</em></span>. It means that MySQL
                Cluster is using the Condition Pushdown optimization to
                improve the efficiency of a direct comparison between a
                non-indexed column and a constant. In such cases, the
                condition is “<span class="quote">pushed down</span>” to the cluster's
                data nodes and is evaluated on all data nodes
                simultaneously. This eliminates the need to send
                non-matching rows over the network, and can speed up
                such queries by a factor of 5 to 10 times over cases
                where Condition Pushdown could be but is not used. For
                more information, see
                <a href="optimization.html#condition-pushdown-optimization" title="7.2.7. Condition Pushdown Optimization">Section 7.2.7, “Condition Pushdown Optimization”</a>.
              </p></li></ul></div></li></ul></div><p>
        You can get a good indication of how good a join is by taking
        the product of the values in the <code class="literal">rows</code> column
        of the <code class="literal">EXPLAIN</code> output. This should tell you
        roughly how many rows MySQL must examine to execute the query.
        If you restrict queries with the
        <code class="literal">max_join_size</code> system variable, this row
        product also is used to determine which multiple-table
        <code class="literal">SELECT</code> statements to execute and which to
        abort. See <a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">Section 7.5.2, “Tuning Server Parameters”</a>.
      </p><p>
        The following example shows how a multiple-table join can be
        optimized progressively based on the information provided by
        <code class="literal">EXPLAIN</code>.
      </p><p>
        Suppose that you have the <code class="literal">SELECT</code> statement
        shown here and that you plan to examine it using
        <code class="literal">EXPLAIN</code>:
      </p><pre class="programlisting">EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
               tt.ProjectReference, tt.EstimatedShipDate,
               tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID,
               tt.CurrentProcess, tt.CurrentDPPerson,
               tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
               et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
          AND tt.ActualPC = et.EMPLOYID
          AND tt.AssignedPC = et_1.EMPLOYID
          AND tt.ClientID = do.CUSTNMBR;
</pre><p>
        For this example, make the following assumptions:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            The columns being compared have been declared as follows:
          </p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Table</strong></span></td><td><span class="bold"><strong>Column</strong></span></td><td><span class="bold"><strong>Data Type</strong></span></td></tr><tr><td><code class="literal">tt</code></td><td><code class="literal">ActualPC</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td><code class="literal">tt</code></td><td><code class="literal">AssignedPC</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td><code class="literal">tt</code></td><td><code class="literal">ClientID</code></td><td><code class="literal">CHAR(10)</code></td></tr><tr><td><code class="literal">et</code></td><td><code class="literal">EMPLOYID</code></td><td><code class="literal">CHAR(15)</code></td></tr><tr><td><code class="literal">do</code></td><td><code class="literal">CUSTNMBR</code></td><td><code class="literal">CHAR(15)</code></td></tr></tbody></table></div></li><li><p>
            The tables have the following indexes:
          </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Table</strong></span></td><td><span class="bold"><strong>Index</strong></span></td></tr><tr><td><code class="literal">tt</code></td><td><code class="literal">ActualPC</code></td></tr><tr><td><code class="literal">tt</code></td><td><code class="literal">AssignedPC</code></td></tr><tr><td><code class="literal">tt</code></td><td><code class="literal">ClientID</code></td></tr><tr><td><code class="literal">et</code></td><td><code class="literal">EMPLOYID</code> (primary key)</td></tr><tr><td><code class="literal">do</code></td><td><code class="literal">CUSTNMBR</code> (primary key)</td></tr></tbody></table></div></li><li><p>
            The <code class="literal">tt.ActualPC</code> values are not evenly
            distributed.
          </p></li></ul></div><p>
        Initially, before any optimizations have been performed, the
        <code class="literal">EXPLAIN</code> statement produces the following
        information:
      </p><pre class="programlisting">table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
      Range checked for each record (index map: 0x23)
</pre><p>
        Because <code class="literal">type</code> is <code class="literal">ALL</code> for
        each table, this output indicates that MySQL is generating a
        Cartesian product of all the tables; that is, every combination
        of rows. This takes quite a long time, because the product of
        the number of rows in each table must be examined. For the case
        at hand, this product is 74 × 2135 × 74 × 3872
        = 45,268,558,720 rows. If the tables were bigger, you can only
        imagine how long it would take.
      </p><p>
        One problem here is that MySQL can use indexes on columns more
        efficiently if they are declared as the same type and size. In
        this context, <code class="literal">VARCHAR</code> and
        <code class="literal">CHAR</code> are considered the same if they are
        declared as the same size. <code class="literal">tt.ActualPC</code> is
        declared as <code class="literal">CHAR(10)</code> and
        <code class="literal">et.EMPLOYID</code> is <code class="literal">CHAR(15)</code>,
        so there is a length mismatch.
      </p><p>
        To fix this disparity between column lengths, use <code class="literal">ALTER
        TABLE</code> to lengthen <code class="literal">ActualPC</code> from 10
        characters to 15 characters:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY ActualPC VARCHAR(15);</code></strong>
</pre><p>
        Now <code class="literal">tt.ActualPC</code> and
        <code class="literal">et.EMPLOYID</code> are both
        <code class="literal">VARCHAR(15)</code>. Executing the
        <code class="literal">EXPLAIN</code> statement again produces this result:
      </p><pre class="programlisting">table type   possible_keys key     key_len ref         rows    Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872    Using
             ClientID,                                         where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
      Range checked for each record (index map: 0x1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
      Range checked for each record (index map: 0x1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
</pre><p>
        This is not perfect, but is much better: The product of the
        <code class="literal">rows</code> values is less by a factor of 74. This
        version executes in a couple of seconds.
      </p><p>
        A second alteration can be made to eliminate the column length
        mismatches for the <code class="literal">tt.AssignedPC =
        et_1.EMPLOYID</code> and <code class="literal">tt.ClientID =
        do.CUSTNMBR</code> comparisons:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),</code></strong>
    -&gt;                <strong class="userinput"><code>MODIFY ClientID   VARCHAR(15);</code></strong>
</pre><p>
        After that modification, <code class="literal">EXPLAIN</code> produces the
        output shown here:
      </p><pre class="programlisting">table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
</pre><p>
        At this point, the query is optimized almost as well as
        possible. The remaining problem is that, by default, MySQL
        assumes that values in the <code class="literal">tt.ActualPC</code> column
        are evenly distributed, and that is not the case for the
        <code class="literal">tt</code> table. Fortunately, it is easy to tell
        MySQL to analyze the key distribution:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>ANALYZE TABLE tt;</code></strong>
</pre><p>
        With the additional index information, the join is perfect and
        <code class="literal">EXPLAIN</code> produces this result:
      </p><pre class="programlisting">table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using
             ClientID,                                        where
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
</pre><p>
        <a class="indexterm" name="id2053729"></a>

        Note that the <code class="literal">rows</code> column in the output from
        <code class="literal">EXPLAIN</code> is an educated guess from the MySQL
        join optimizer. You should check whether the numbers are even
        close to the truth by comparing the <code class="literal">rows</code>
        product with the actual number of rows that the query returns.
        If the numbers are quite different, you might get better
        performance by using <code class="literal">STRAIGHT_JOIN</code> in your
        <code class="literal">SELECT</code> statement and trying to list the
        tables in a different order in the <code class="literal">FROM</code>
        clause.
      </p><p>
        It is possible in some cases to execute statements that modify
        data when <code class="literal">EXPLAIN SELECT</code> is used with a
        subquery; for more information, see
        <a href="sql-syntax.html#unnamed-views" title="12.2.8.8. Subqueries in the FROM clause">Section 12.2.8.8, “Subqueries in the <code class="literal">FROM</code> clause”</a>.
      </p><p class="mnmas"><b>MySQL Enterprise</b>
          Subscribers to the MySQL Enterprise Monitor regularly receive
          expert advice on optimization. For more information, see
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="estimating-performance"></a>7.2.2. Estimating Query Performance</h3></div></div></div><a class="indexterm" name="id2053821"></a><a class="indexterm" name="id2053833"></a><a class="indexterm" name="id2053845"></a><p>
        In most cases, you can estimate query performance by counting
        disk seeks. For small tables, you can usually find a row in one
        disk seek (because the index is probably cached). For bigger
        tables, you can estimate that, using B-tree indexes, you need
        this many seeks to find a row:
        <code class="literal">log(<em class="replaceable"><code>row_count</code></em>) /
        log(<em class="replaceable"><code>index_block_length</code></em> / 3 × 2
        / (<em class="replaceable"><code>index_length</code></em> +
        <em class="replaceable"><code>data_pointer_length</code></em>)) + 1</code>.
      </p><p>
        In MySQL, an index block is usually 1,024 bytes and the data
        pointer is usually four bytes. For a 500,000-row table with an
        index length of three bytes (the size of
        <code class="literal">MEDIUMINT</code>), the formula indicates
        <code class="literal">log(500,000)/log(1024/3×2/(3+4)) + 1</code> =
        <code class="literal">4</code> seeks.
      </p><p>
        This index would require storage of about 500,000 × 7
        × 3/2 = 5.2MB (assuming a typical index buffer fill ratio
        of 2/3), so you probably have much of the index in memory and so
        need only one or two calls to read data to find the row.
      </p><p>
        For writes, however, you need four seek requests to find where
        to place a new index value and normally two seeks to update the
        index and write the row.
      </p><p>
        Note that the preceding discussion does not mean that your
        application performance slowly degenerates by log
        <em class="replaceable"><code>N</code></em>. As long as everything is cached by
        the OS or the MySQL server, things become only marginally slower
        as the table gets bigger. After the data gets too big to be
        cached, things start to go much slower until your applications
        are bound only by disk seeks (which increase by log
        <em class="replaceable"><code>N</code></em>). To avoid this, increase the key
        cache size as the data grows. For <code class="literal">MyISAM</code>
        tables, the key cache size is controlled by the
        <code class="literal">key_buffer_size</code> system variable. See
        <a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">Section 7.5.2, “Tuning Server Parameters”</a>.
      </p><p class="mnmas"><b>MySQL Enterprise</b>
          The MySQL Enterprise Monitor provides a number of advisors
          specifically designed to improve query performance. For more
          information see
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="select-speed"></a>7.2.3. Speed of <code class="literal">SELECT</code> Queries</h3></div></div></div><a class="indexterm" name="id2053986"></a><a class="indexterm" name="id2053995"></a><p>
        In general, when you want to make a slow <code class="literal">SELECT ...
        WHERE</code> query faster, the first thing to check is
        whether you can add an index. All references between different
        tables should usually be done with indexes. You can use the
        <code class="literal">EXPLAIN</code> statement to determine which indexes
        are used for a <code class="literal">SELECT</code>. See
        <a href="optimization.html#using-explain" title="7.2.1. Optimizing Queries with EXPLAIN">Section 7.2.1, “Optimizing Queries with <code class="literal">EXPLAIN</code>”</a>, and
        <a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">Section 7.4.5, “How MySQL Uses Indexes”</a>.
      </p><p>
        Some general tips for speeding up queries on
        <code class="literal">MyISAM</code> tables:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            To help MySQL better optimize queries, use <code class="literal">ANALYZE
            TABLE</code> or run <span><strong class="command">myisamchk
            --analyze</strong></span> on a table after it has been loaded with
            data. This updates a value for each index part that
            indicates the average number of rows that have the same
            value. (For unique indexes, this is always 1.) MySQL uses
            this to decide which index to choose when you join two
            tables based on a non-constant expression. You can check the
            result from the table analysis by using <code class="literal">SHOW INDEX
            FROM <em class="replaceable"><code>tbl_name</code></em></code> and
            examining the <code class="literal">Cardinality</code> value.
            <span><strong class="command">myisamchk --description --verbose</strong></span> shows
            index distribution information.
          </p></li><li><p>
            To sort an index and data according to an index, use
            <span><strong class="command">myisamchk --sort-index --sort-records=1</strong></span>
            (assuming that you want to sort on index 1). This is a good
            way to make queries faster if you have a unique index from
            which you want to read all rows in order according to the
            index. The first time you sort a large table this way, it
            may take a long time.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="where-optimizations"></a>7.2.4. <code class="literal">WHERE</code> Clause Optimization</h3></div></div></div><a class="indexterm" name="id2054127"></a><a class="indexterm" name="id2054136"></a><p>
        This section discusses optimizations that can be made for
        processing <code class="literal">WHERE</code> clauses. The examples use
        <code class="literal">SELECT</code> statements, but the same optimizations
        apply for <code class="literal">WHERE</code> clauses in
        <code class="literal">DELETE</code> and <code class="literal">UPDATE</code>
        statements.
      </p><p>
        Work on the MySQL optimizer is ongoing, so this section is
        incomplete. MySQL performs a great many optimizations, not all
        of which are documented here.
      </p><p>
        Some of the optimizations performed by MySQL follow:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Removal of unnecessary parentheses:
          </p><pre class="programlisting">   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&gt; (a AND b AND c) OR (a AND b AND c AND d)
</pre></li><li><p>
            Constant folding:
          </p><pre class="programlisting">   (a&lt;b AND b=c) AND a=5
-&gt; b&gt;5 AND b=c AND a=5
</pre></li><li><p>
            Constant condition removal (needed because of constant
            folding):
          </p><pre class="programlisting">   (B&gt;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&gt; B=5 OR B=6
</pre></li><li><p>
            Constant expressions used by indexes are evaluated only
            once.
          </p></li><li><p>
            <a href="functions.html#function_count"><code class="literal">COUNT(*)</code></a> on a single table
            without a <code class="literal">WHERE</code> is retrieved directly
            from the table information for <code class="literal">MyISAM</code> and
            <code class="literal">MEMORY</code> tables. This is also done for any
            <code class="literal">NOT NULL</code> expression when used with only
            one table.
          </p></li><li><p>
            Early detection of invalid constant expressions. MySQL
            quickly detects that some <code class="literal">SELECT</code>
            statements are impossible and returns no rows.
          </p></li><li><p>
            <code class="literal">HAVING</code> is merged with
            <code class="literal">WHERE</code> if you do not use <code class="literal">GROUP
            BY</code> or aggregate functions
            (<a href="functions.html#function_count"><code class="literal">COUNT()</code></a>,
            <a href="functions.html#function_min"><code class="literal">MIN()</code></a>, and so on).
          </p></li><li><p>
            For each table in a join, a simpler <code class="literal">WHERE</code>
            is constructed to get a fast <code class="literal">WHERE</code>
            evaluation for the table and also to skip rows as soon as
            possible.
          </p></li><li><p>
            <a class="indexterm" name="id2054354"></a>

            <a class="indexterm" name="id2054363"></a>

            All constant tables are read first before any other tables
            in the query. A constant table is any of the following:
          </p><div class="itemizedlist"><ul type="circle"><li><p>
                An empty table or a table with one row.
              </p></li><li><p>
                A table that is used with a <code class="literal">WHERE</code>
                clause on a <code class="literal">PRIMARY KEY</code> or a
                <code class="literal">UNIQUE</code> index, where all index parts
                are compared to constant expressions and are defined as
                <code class="literal">NOT NULL</code>.
              </p></li></ul></div><p>
            All of the following tables are used as constant tables:
          </p><pre class="programlisting">SELECT * FROM t WHERE <em class="replaceable"><code>primary_key</code></em>=1;
SELECT * FROM t1,t2
  WHERE t1.<em class="replaceable"><code>primary_key</code></em>=1 AND t2.<em class="replaceable"><code>primary_key</code></em>=t1.id;
</pre></li><li><p>
            The best join combination for joining the tables is found by
            trying all possibilities. If all columns in <code class="literal">ORDER
            BY</code> and <code class="literal">GROUP BY</code> clauses come
            from the same table, that table is preferred first when
            joining.
          </p></li><li><p>
            If there is an <code class="literal">ORDER BY</code> clause and a
            different <code class="literal">GROUP BY</code> clause, or if the
            <code class="literal">ORDER BY</code> or <code class="literal">GROUP BY</code>
            contains columns from tables other than the first table in
            the join queue, a temporary table is created.
          </p></li><li><p>
            If you use the <code class="literal">SQL_SMALL_RESULT</code> option,
            MySQL uses an in-memory temporary table.
          </p></li><li><p>
            Each table index is queried, and the best index is used
            unless the optimizer believes that it is more efficient to
            use a table scan. At one time, a scan was used based on
            whether the best index spanned more than 30% of the table,
            but a fixed percentage no longer determines the choice
            between using an index or a scan. The optimizer now is more
            complex and bases its estimate on additional factors such as
            table size, number of rows, and I/O block size.
          </p></li><li><p>
            In some cases, MySQL can read rows from the index without
            even consulting the data file. If all columns used from the
            index are numeric, only the index tree is used to resolve
            the query.
          </p></li><li><p>
            Before each row is output, those that do not match the
            <code class="literal">HAVING</code> clause are skipped.
          </p></li></ul></div><p>
        Some examples of queries that are very fast:
      </p><pre class="programlisting">SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MIN(<em class="replaceable"><code>key_part1</code></em>),MAX(<em class="replaceable"><code>key_part1</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>;

SELECT MAX(<em class="replaceable"><code>key_part2</code></em>) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>constant</code></em>;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... LIMIT 10;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... LIMIT 10;
</pre><p>
        MySQL resolves the following queries using only the index tree,
        assuming that the indexed columns are numeric:
      </p><pre class="programlisting">SELECT <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val</code></em>;

SELECT COUNT(*) FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>val1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>val2</code></em>;

SELECT <em class="replaceable"><code>key_part2</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> GROUP BY <em class="replaceable"><code>key_part1</code></em>;
</pre><p>
        The following queries use indexing to retrieve the rows in
        sorted order without a separate sorting pass:
      </p><pre class="programlisting">SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... ;

SELECT ... FROM <em class="replaceable"><code>tbl_name</code></em>
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC, ... ;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="range-optimization"></a>7.2.5. Range Optimization</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#range-access-single-part">7.2.5.1. The Range Access Method for Single-Part Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#range-access-multi-part">7.2.5.2. The Range Access Method for Multiple-Part Indexes</a></span></dt></dl></div><p>
        The <code class="literal">range</code> access method uses a single index
        to retrieve a subset of table rows that are contained within one
        or several index value intervals. It can be used for a
        single-part or multiple-part index. The following sections give
        a detailed description of how intervals are extracted from the
        <code class="literal">WHERE</code> clause.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="range-access-single-part"></a>7.2.5.1. The Range Access Method for Single-Part Indexes</h4></div></div></div><p>
          For a single-part index, index value intervals can be
          conveniently represented by corresponding conditions in the
          <code class="literal">WHERE</code> clause, so we speak of
          <em class="firstterm">range conditions</em> rather than
          “<span class="quote">intervals.</span>”
        </p><p>
          The definition of a range condition for a single-part index is
          as follows:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              For both <code class="literal">BTREE</code> and
              <code class="literal">HASH</code> indexes, comparison of a key part
              with a constant value is a range condition when using the
              <a href="functions.html#operator_equal"><code class="literal">=</code></a>,
              <a href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
              <a href="functions.html#function_in"><code class="literal">IN()</code></a>,
              <a href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a>, or
              <a href="functions.html#operator_is-not-null"><code class="literal">IS NOT NULL</code></a> operators.
            </p></li><li><p>
              For <code class="literal">BTREE</code> indexes, comparison of a key
              part with a constant value is a range condition when using
              the
              <a href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
              <a href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
              <a href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
              <a href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
              <a href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>,
              <a href="functions.html#operator_not-equal"><code class="literal">!=</code></a>,
              or
              <a href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>
              operators, or <a href="functions.html#operator_like"><code class="literal">LIKE</code></a>
              comparisons if the argument to
              <a href="functions.html#operator_like"><code class="literal">LIKE</code></a> is a constant
              string that does not start with a wildcard character.
            </p></li><li><p>
              For all types of indexes, multiple range conditions
              combined with <a href="functions.html#operator_or"><code class="literal">OR</code></a> or
              <a href="functions.html#operator_and"><code class="literal">AND</code></a> form a range
              condition.
            </p></li></ul></div><p>
          “<span class="quote">Constant value</span>” in the preceding descriptions
          means one of the following:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              A constant from the query string
            </p></li><li><p>
              A column of a <code class="literal">const</code> or
              <code class="literal">system</code> table from the same join
            </p></li><li><p>
              The result of an uncorrelated subquery
            </p></li><li><p>
              Any expression composed entirely from subexpressions of
              the preceding types
            </p></li></ul></div><p>
          Here are some examples of queries with range conditions in the
          <code class="literal">WHERE</code> clause:
        </p><pre class="programlisting">SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_col</code></em> &gt; 1 
  AND <em class="replaceable"><code>key_col</code></em> &lt; 10;

SELECT * FROM t1 
  WHERE <em class="replaceable"><code>key_col</code></em> = 1 
  OR <em class="replaceable"><code>key_col</code></em> IN (15,18,20);

SELECT * FROM t1 
  WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'ab%' 
  OR <em class="replaceable"><code>key_col</code></em> BETWEEN 'bar' AND 'foo';
</pre><p>
          Note that some non-constant values may be converted to
          constants during the constant propagation phase.
        </p><p>
          MySQL tries to extract range conditions from the
          <code class="literal">WHERE</code> clause for each of the possible
          indexes. During the extraction process, conditions that cannot
          be used for constructing the range condition are dropped,
          conditions that produce overlapping ranges are combined, and
          conditions that produce empty ranges are removed.
        </p><p>
          Consider the following statement, where
          <code class="literal">key1</code> is an indexed column and
          <code class="literal">nonkey</code> is not indexed:
        </p><pre class="programlisting">SELECT * FROM t1 WHERE
  (key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 &lt; 'bar' AND nonkey = 4) OR
  (key1 &lt; 'uux' AND key1 &gt; 'z');
</pre><p>
          The extraction process for key <code class="literal">key1</code> is as
          follows:
        </p><div class="orderedlist"><ol type="1"><li><p>
              Start with original <code class="literal">WHERE</code> clause:
            </p><pre class="programlisting">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 &lt; 'bar' AND nonkey = 4) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li><p>
              Remove <code class="literal">nonkey = 4</code> and <code class="literal">key1
              LIKE '%b'</code> because they cannot be used for a
              range scan. The correct way to remove them is to replace
              them with <code class="literal">TRUE</code>, so that we do not miss
              any matching rows when doing the range scan. Having
              replaced them with <code class="literal">TRUE</code>, we get:
            </p><pre class="programlisting">(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 &lt; 'bar' AND TRUE) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li><li><p>
              Collapse conditions that are always true or false:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
                  <code class="literal">(key1 LIKE 'abcde%' OR TRUE)</code> is
                  always true
                </p></li><li><p>
                  <code class="literal">(key1 &lt; 'uux' AND key1 &gt; 'z')</code>
                  is always false
                </p></li></ul></div><p>
              Replacing these conditions with constants, we get:
            </p><pre class="programlisting">(key1 &lt; 'abc' AND TRUE) OR (key1 &lt; 'bar' AND TRUE) OR (FALSE)
</pre><p>
              Removing unnecessary <code class="literal">TRUE</code> and
              <code class="literal">FALSE</code> constants, we obtain:
            </p><pre class="programlisting">(key1 &lt; 'abc') OR (key1 &lt; 'bar')
</pre></li><li><p>
              Combining overlapping intervals into one yields the final
              condition to be used for the range scan:
            </p><pre class="programlisting">(key1 &lt; 'bar')
</pre></li></ol></div><p>
          In general (and as demonstrated by the preceding example), the
          condition used for a range scan is less restrictive than the
          <code class="literal">WHERE</code> clause. MySQL performs an additional
          check to filter out rows that satisfy the range condition but
          not the full <code class="literal">WHERE</code> clause.
        </p><p>
          The range condition extraction algorithm can handle nested
          <a href="functions.html#operator_and"><code class="literal">AND</code></a>/<a href="functions.html#operator_or"><code class="literal">OR</code></a>
          constructs of arbitrary depth, and its output does not depend
          on the order in which conditions appear in
          <code class="literal">WHERE</code> clause.
        </p><p>
          Currently, MySQL does not support merging multiple ranges for
          the <code class="literal">range</code> access method for spatial
          indexes. To work around this limitation, you can use a
          <code class="literal">UNION</code> with identical
          <code class="literal">SELECT</code> statements, except that you put each
          spatial predicate in a different <code class="literal">SELECT</code>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="range-access-multi-part"></a>7.2.5.2. The Range Access Method for Multiple-Part Indexes</h4></div></div></div><p>
          Range conditions on a multiple-part index are an extension of
          range conditions for a single-part index. A range condition on
          a multiple-part index restricts index rows to lie within one
          or several key tuple intervals. Key tuple intervals are
          defined over a set of key tuples, using ordering from the
          index.
        </p><p>
          For example, consider a multiple-part index defined as
          <code class="literal">key1(<em class="replaceable"><code>key_part1</code></em>,
          <em class="replaceable"><code>key_part2</code></em>,
          <em class="replaceable"><code>key_part3</code></em>)</code>, and the
          following set of key tuples listed in key order:
        </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em>  <em class="replaceable"><code>key_part2</code></em>  <em class="replaceable"><code>key_part3</code></em>
  NULL       1          'abc'
  NULL       1          'xyz'
  NULL       2          'foo'
   1         1          'abc'
   1         1          'xyz'
   1         2          'abc'
   2         1          'aaa'
</pre><p>
          The condition <code class="literal"><em class="replaceable"><code>key_part1</code></em> =
          1</code> defines this interval:
        </p><pre class="programlisting">(1,-inf,-inf) &lt;= (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; (1,+inf,+inf)
</pre><p>
          The interval covers the 4th, 5th, and 6th tuples in the
          preceding data set and can be used by the range access method.
        </p><p>
          By contrast, the condition
          <code class="literal"><em class="replaceable"><code>key_part3</code></em> =
          'abc'</code> does not define a single interval and cannot
          be used by the range access method.
        </p><p>
          The following descriptions indicate how range conditions work
          for multiple-part indexes in greater detail.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              For <code class="literal">HASH</code> indexes, each interval
              containing identical values can be used. This means that
              the interval can be produced only for conditions in the
              following form:
            </p><pre class="programlisting">    <em class="replaceable"><code>key_part1</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const1</code></em>
AND <em class="replaceable"><code>key_part2</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>const2</code></em>
AND ...
AND <em class="replaceable"><code>key_partN</code></em> <em class="replaceable"><code>cmp</code></em> <em class="replaceable"><code>constN</code></em>;
</pre><p>
              Here, <em class="replaceable"><code>const1</code></em>,
              <em class="replaceable"><code>const2</code></em>, … are constants,
              <em class="replaceable"><code>cmp</code></em> is one of the
              <a href="functions.html#operator_equal"><code class="literal">=</code></a>,
              <a href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
              or <a href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a> comparison
              operators, and the conditions cover all index parts. (That
              is, there are <em class="replaceable"><code>N</code></em> conditions, one
              for each part of an <em class="replaceable"><code>N</code></em>-part
              index.) For example, the following is a range condition
              for a three-part <code class="literal">HASH</code> index:
            </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> IS NULL AND <em class="replaceable"><code>key_part3</code></em> = 'foo'
</pre><p>
              For the definition of what is considered to be a constant,
              see <a href="optimization.html#range-access-single-part" title="7.2.5.1. The Range Access Method for Single-Part Indexes">Section 7.2.5.1, “The Range Access Method for Single-Part Indexes”</a>.
            </p></li><li><p>
              For a <code class="literal">BTREE</code> index, an interval might be
              usable for conditions combined with
              <a href="functions.html#operator_and"><code class="literal">AND</code></a>, where each
              condition compares a key part with a constant value using
              <a href="functions.html#operator_equal"><code class="literal">=</code></a>,
              <a href="functions.html#operator_equal-to"><code class="literal">&lt;=&gt;</code></a>,
              <a href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a>,
              <a href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
              <a href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
              <a href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
              <a href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
              <a href="functions.html#operator_not-equal"><code class="literal">!=</code></a>,
              <a href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>,
              <a href="functions.html#operator_between"><code class="literal">BETWEEN</code></a>, or
              <a href="functions.html#operator_like"><code class="literal">LIKE
              '<em class="replaceable"><code>pattern</code></em>'</code></a> (where
              <code class="literal">'<em class="replaceable"><code>pattern</code></em>'</code>
              does not start with a wildcard). An interval can be used
              as long as it is possible to determine a single key tuple
              containing all rows that match the condition (or two
              intervals if
              <a href="functions.html#operator_not-equal"><code class="literal">&lt;&gt;</code></a>
              or
              <a href="functions.html#operator_not-equal"><code class="literal">!=</code></a>
              is used). For example, for this condition:
            </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> = 'foo' AND <em class="replaceable"><code>key_part2</code></em> &gt;= 10 AND <em class="replaceable"><code>key_part3</code></em> &gt; 10
</pre><p>
              The single interval is:
            </p><pre class="programlisting">('foo',10,10) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,<em class="replaceable"><code>key_part3</code></em>) &lt; ('foo',+inf,+inf)
</pre><p>
              It is possible that the created interval contains more
              rows than the initial condition. For example, the
              preceding interval includes the value <code class="literal">('foo', 11,
              0)</code>, which does not satisfy the original
              condition.
            </p></li><li><p>
              If conditions that cover sets of rows contained within
              intervals are combined with
              <a href="functions.html#operator_or"><code class="literal">OR</code></a>, they form a
              condition that covers a set of rows contained within the
              union of their intervals. If the conditions are combined
              with <a href="functions.html#operator_and"><code class="literal">AND</code></a>, they form a
              condition that covers a set of rows contained within the
              intersection of their intervals. For example, for this
              condition on a two-part index:
            </p><pre class="programlisting">(<em class="replaceable"><code>key_part1</code></em> = 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2) OR (<em class="replaceable"><code>key_part1</code></em> &gt; 5)
</pre><p>
              The intervals are:
            </p><pre class="programlisting">(1,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>) &lt; (1,2)
(5,-inf) &lt; (<em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>)
</pre><p>
              In this example, the interval on the first line uses one
              key part for the left bound and two key parts for the
              right bound. The interval on the second line uses only one
              key part. The <code class="literal">key_len</code> column in the
              <code class="literal">EXPLAIN</code> output indicates the maximum
              length of the key prefix used.
            </p><p>
              In some cases, <code class="literal">key_len</code> may indicate
              that a key part was used, but that might be not what you
              would expect. Suppose that
              <em class="replaceable"><code>key_part1</code></em> and
              <em class="replaceable"><code>key_part2</code></em> can be
              <code class="literal">NULL</code>. Then the
              <code class="literal">key_len</code> column displays two key part
              lengths for the following condition:
            </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> &lt; 2
</pre><p>
              But, in fact, the condition is converted to this:
            </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em> &gt;= 1 AND <em class="replaceable"><code>key_part2</code></em> IS NOT NULL
</pre></li></ul></div><p>
          <a href="optimization.html#range-access-single-part" title="7.2.5.1. The Range Access Method for Single-Part Indexes">Section 7.2.5.1, “The Range Access Method for Single-Part Indexes”</a>, describes how
          optimizations are performed to combine or eliminate intervals
          for range conditions on a single-part index. Analogous steps
          are performed for range conditions on multiple-part indexes.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="index-merge-optimization"></a>7.2.6. Index Merge Optimization</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#index-merge-intersection">7.2.6.1. The Index Merge Intersection Access Algorithm</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-union">7.2.6.2. The Index Merge Union Access Algorithm</a></span></dt><dt><span class="section"><a href="optimization.html#index-merge-sort-union">7.2.6.3. The Index Merge Sort-Union Access Algorithm</a></span></dt></dl></div><a class="indexterm" name="id2055853"></a><a class="indexterm" name="id2055862"></a><a class="indexterm" name="id2055871"></a><p>
        The <em class="firstterm">Index Merge</em> method is used to
        retrieve rows with several <code class="literal">range</code> scans and to
        merge their results into one. The merge can produce unions,
        intersections, or unions-of-intersections of its underlying
        scans. This access method merges index scans from a single
        table; it does not merge scans across multiple tables.
      </p><p>
        In <code class="literal">EXPLAIN</code> output, the Index Merge method
        appears as <code class="literal">index_merge</code> in the
        <code class="literal">type</code> column. In this case, the
        <code class="literal">key</code> column contains a list of indexes used,
        and <code class="literal">key_len</code> contains a list of the longest
        key parts for those indexes.
      </p><p>
        Examples:
      </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key1</code></em> = 10 OR <em class="replaceable"><code>key2</code></em> = 20) AND <em class="replaceable"><code>non_key</code></em>=30;

SELECT * FROM t1, t2
  WHERE (t1.<em class="replaceable"><code>key1</code></em> IN (1,2) OR t1.<em class="replaceable"><code>key2</code></em> LIKE '<em class="replaceable"><code>value</code></em>%')
  AND t2.<em class="replaceable"><code>key1</code></em>=t1.<em class="replaceable"><code>some_col</code></em>;

SELECT * FROM t1, t2
  WHERE t1.<em class="replaceable"><code>key1</code></em>=1
  AND (t2.<em class="replaceable"><code>key1</code></em>=t1.<em class="replaceable"><code>some_col</code></em> OR t2.<em class="replaceable"><code>key2</code></em>=t1.<em class="replaceable"><code>some_col2</code></em>);
</pre><p>
        The Index Merge method has several access algorithms (seen in
        the <code class="literal">Extra</code> field of <code class="literal">EXPLAIN</code>
        output):
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">Using intersect(...)</code>
          </p></li><li><p>
            <code class="literal">Using union(...)</code>
          </p></li><li><p>
            <code class="literal">Using sort_union(...)</code>
          </p></li></ul></div><p>
        The following sections describe these methods in greater detail.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          The Index Merge optimization algorithm has the following known
          deficiencies:
        </p></div><div class="itemizedlist"><ul type="disc"><li><p>
            If a range scan is possible on some key, the optimizer will
            not consider using Index Merge Union or Index Merge
            Sort-Union algorithms. For example, consider this query:
          </p><pre class="programlisting">SELECT * FROM t1 WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND badkey &lt; 30;
</pre><p>
            For this query, two plans are possible:
          </p><div class="itemizedlist"><ul type="circle"><li><p>
                An Index Merge scan using the <code class="literal">(goodkey1 &lt; 10
                OR goodkey2 &lt; 20)</code> condition.
              </p></li><li><p>
                A range scan using the <code class="literal">badkey &lt; 30</code>
                condition.
              </p></li></ul></div><p>
            However, the optimizer considers only the second plan.
          </p></li><li><p>
            If your query has a complex <code class="literal">WHERE</code> clause
            with deep
            <a href="functions.html#operator_and"><code class="literal">AND</code></a>/<a href="functions.html#operator_or"><code class="literal">OR</code></a>
            nesting and MySQL doesn't choose the optimal plan, try
            distributing terms using the following identity laws:
          </p><pre class="programlisting">(<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>y</code></em>) OR <em class="replaceable"><code>z</code></em> = (<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>z</code></em>) AND (<em class="replaceable"><code>y</code></em> OR <em class="replaceable"><code>z</code></em>)
(<em class="replaceable"><code>x</code></em> OR <em class="replaceable"><code>y</code></em>) AND <em class="replaceable"><code>z</code></em> = (<em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>z</code></em>) OR (<em class="replaceable"><code>y</code></em> AND <em class="replaceable"><code>z</code></em>)
</pre></li><li><p>
            Index Merge is not applicable to fulltext indexes. We plan
            to extend it to cover these in a future MySQL release.
          </p></li></ul></div><p>
        The choice between different possible variants of the Index
        Merge access method and other access methods is based on cost
        estimates of various available options.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="index-merge-intersection"></a>7.2.6.1. The Index Merge Intersection Access Algorithm</h4></div></div></div><p>
          This access algorithm can be employed when a
          <code class="literal">WHERE</code> clause was converted to several range
          conditions on different keys combined with
          <a href="functions.html#operator_and"><code class="literal">AND</code></a>, and each condition is
          one of the following:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              In this form, where the index has exactly
              <em class="replaceable"><code>N</code></em> parts (that is, all index
              parts are covered):
            </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em>=<em class="replaceable"><code>constN</code></em>
</pre></li><li><p>
              Any range condition over a primary key of an
              <code class="literal">InnoDB</code> table.
            </p></li></ul></div><p>
          Examples:
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>innodb_table</code></em> WHERE <em class="replaceable"><code>primary_key</code></em> &lt; 10 AND <em class="replaceable"><code>key_col1</code></em>=20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key1_part1</code></em>=1 AND <em class="replaceable"><code>key1_part2</code></em>=2) AND <em class="replaceable"><code>key2</code></em>=2;
</pre><p>
          The Index Merge intersection algorithm performs simultaneous
          scans on all used indexes and produces the intersection of row
          sequences that it receives from the merged index scans.
        </p><p>
          If all columns used in the query are covered by the used
          indexes, full table rows are not retrieved
          (<code class="literal">EXPLAIN</code> output contains <code class="literal">Using
          index</code> in <code class="literal">Extra</code> field in this
          case). Here is an example of such a query:
        </p><pre class="programlisting">SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;
</pre><p>
          If the used indexes don't cover all columns used in the query,
          full rows are retrieved only when the range conditions for all
          used keys are satisfied.
        </p><p>
          If one of the merged conditions is a condition over a primary
          key of an <code class="literal">InnoDB</code> table, it is not used for
          row retrieval, but is used to filter out rows retrieved using
          other conditions.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="index-merge-union"></a>7.2.6.2. The Index Merge Union Access Algorithm</h4></div></div></div><p>
          The applicability criteria for this algorithm are similar to
          those for the Index Merge method intersection algorithm. The
          algorithm can be employed when the table's
          <code class="literal">WHERE</code> clause was converted to several range
          conditions on different keys combined with
          <a href="functions.html#operator_or"><code class="literal">OR</code></a>, and each condition is
          one of the following:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              In this form, where the index has exactly
              <em class="replaceable"><code>N</code></em> parts (that is, all index
              parts are covered):
            </p><pre class="programlisting"><em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>const1</code></em> AND <em class="replaceable"><code>key_part2</code></em>=<em class="replaceable"><code>const2</code></em> ... AND <em class="replaceable"><code>key_partN</code></em>=<em class="replaceable"><code>constN</code></em>
</pre></li><li><p>
              Any range condition over a primary key of an
              <code class="literal">InnoDB</code> table.
            </p></li><li><p>
              A condition for which the Index Merge method intersection
              algorithm is applicable.
            </p></li></ul></div><p>
          Examples:
        </p><pre class="programlisting">SELECT * FROM t1 WHERE <em class="replaceable"><code>key1</code></em>=1 OR <em class="replaceable"><code>key2</code></em>=2 OR <em class="replaceable"><code>key3</code></em>=3;

SELECT * FROM <em class="replaceable"><code>innodb_table</code></em> WHERE (<em class="replaceable"><code>key1</code></em>=1 AND <em class="replaceable"><code>key2</code></em>=2) OR
  (<em class="replaceable"><code>key3</code></em>='foo' AND <em class="replaceable"><code>key4</code></em>='bar') AND <em class="replaceable"><code>key5</code></em>=5;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="index-merge-sort-union"></a>7.2.6.3. The Index Merge Sort-Union Access Algorithm</h4></div></div></div><p>
          This access algorithm is employed when the
          <code class="literal">WHERE</code> clause was converted to several range
          conditions combined by <a href="functions.html#operator_or"><code class="literal">OR</code></a>,
          but for which the Index Merge method union algorithm is not
          applicable.
        </p><p>
          Examples:
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col1</code></em> &lt; 10 OR <em class="replaceable"><code>key_col2</code></em> &lt; 20;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE (<em class="replaceable"><code>key_col1</code></em> &gt; 10 OR <em class="replaceable"><code>key_col2</code></em> = 20) AND <em class="replaceable"><code>nonkey_col</code></em>=30;
</pre><p>
          The difference between the sort-union algorithm and the union
          algorithm is that the sort-union algorithm must first fetch
          row IDs for all rows and sort them before returning any rows.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="condition-pushdown-optimization"></a>7.2.7. Condition Pushdown Optimization</h3></div></div></div><p>
        This optimization improves the efficiency of a direct comparison
        between a non-indexed column and a constant. In such cases, the
        condition is “<span class="quote">pushed down</span>” to the storage engine
        for evaluation. In MySQL 5.1, this optimzation can
        be used only by the <code class="literal">NDBCLUSTER</code> storage
        engine, but we intend to implement it for additional storage
        engines in future versions of MySQL.
      </p><p>
        For MySQL Cluster this optimization can eliminate the need to
        send non-matching rows over the network between the
        cluster's data nodes and the MySQL Server that issued the
        query, and can speed up queries where it is used by a factor of
        5 to 10 times over cases where condition pushdown could be but
        is not used.
      </p><p>
        Suppose that a MySQL Cluster table is defined as follows:
      </p><pre class="programlisting">CREATE TABLE t1 (
    a INT, 
    b INT, 
    KEY(a)
) ENGINE=NDBCLUSTER;
</pre><p>
        Condition pushdown can be used with a query against this table
        such as the query shown here:
      </p><pre class="programlisting">SELECT a,b FROM t1 WHERE b = 10;
</pre><p>
        This can be seen in the output of <code class="literal">EXPLAIN
        SELECT</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
</pre><p>
        However, condition pushdown <span class="emphasis"><em>cannot</em></span> be used
        with either of these two queries:
      </p><pre class="programlisting">SELECT a,b FROM t1 WHERE a = 10;
SELECT a,b FROM t1 WHERE b + 1 = 10;
</pre><p>
        With regard to the first of these two queries, condition
        pushdown is not applicable because an index exists on column
        <code class="literal">a</code>. (An index access method would be more
        efficient and so would be chosen in preference to condition
        pushdown.) In the case of the second query, condition pushdown
        cannot be employed because the comparison involving the
        non-indexed column <code class="literal">b</code> is indirect. (However,
        condition pushdown could be applied if you were to reduce
        <code class="literal">b + 1 = 10</code> to <code class="literal">b = 9</code> in the
        <code class="literal">WHERE</code> clause.)
      </p><p>
        Condition pushdown may also be employed when an indexed column
        is compared with a constant using a <code class="literal">&gt;</code> or
        <code class="literal">&lt;</code> operator:

</p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT a,b FROM t1 WHERE a&lt;2\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: t1
         type: range
possible_keys: a
          key: a
      key_len: 5
          ref: NULL
         rows: 2
        Extra: Using where with pushed condition
</pre><p>
      </p><p>
        Other comparisons which are supported for condition pushdown
        include the following:

        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> [NOT] LIKE
              <em class="replaceable"><code>pattern</code></em></code>
            </p><p>
              <em class="replaceable"><code>pattern</code></em> must be a string
              literal containing the pattern to be matched; for syntax,
              see <a href="functions.html#string-comparison-functions" title="11.4.1. String Comparison Functions">Section 11.4.1, “String Comparison Functions”</a>.
            </p></li><li><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> IS [NOT]
              NULL</code>
            </p></li><li><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> IN
              (<em class="replaceable"><code>value_list</code></em>)</code>
            </p><p>
              Each item in the <em class="replaceable"><code>value_list</code></em>
              must be a constant, literal value.
            </p></li><li><p>
              <code class="literal"><em class="replaceable"><code>column</code></em> BETWEEN
              <em class="replaceable"><code>constant1</code></em> AND
              <em class="replaceable"><code>constant2</code></em></code>
            </p><p>
              <em class="replaceable"><code>constant1</code></em> and
              <em class="replaceable"><code>constant2</code></em> must each be a
              constant, literal value.
            </p></li></ul></div><p>

        In all of the cases in the preceding list, it is possible for
        the condition to be converted into the form of one or more
        direct comparisons between a column and a constant.
      </p><p>
        Condition pushdown capability is not used by default. To enable
        it, you can start <span><strong class="command">mysqld</strong></span> with the
        <code class="option">--engine-condition-pushdown</code> option, or you can
        execute either of the following statements at runtime:

</p><pre class="programlisting">SET engine_condition_pushdown=ON;
</pre><p>

</p><pre class="programlisting">SET engine_condition_pushdown=1;
</pre><p>
      </p><p><b>Limitations. </b>
          Condition pushdown is subject to the following limitations:

          </p><div class="itemizedlist"><ul type="disc"><li><p>
                In MySQL 5.1, condition pushdown is
                supported by the <code class="literal">NDBCLUSTER</code> storage
                engine only.
              </p></li><li><p>
                Columns may be compared with constants only; however,
                this includes expressions which evaluate to constant
                values.
              </p></li><li><p>
                Columns used in comparisons cannot be of any of the
                <code class="literal">BLOB</code> or <code class="literal">TEXT</code>
                types.
              </p></li><li><p>
                A string value to be compared with a column must use the
                same collation as the column.
              </p></li><li><p>
                Joins are not directly supported; conditions involving
                multiple tables are pushed separately where possible.
                Use <code class="literal">EXPLAIN EXTENDED</code> to determine
                which conditions are actually pushed down.
              </p></li></ul></div><p>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="is-null-optimization"></a>7.2.8. <a href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a> Optimization</h3></div></div></div><a class="indexterm" name="id2056972"></a><a class="indexterm" name="id2056981"></a><p>
        MySQL can perform the same optimization on
        <em class="replaceable"><code>col_name</code></em> <a href="functions.html#operator_is-null"><code class="literal">IS
        NULL</code></a> that it can use for
        <em class="replaceable"><code>col_name</code></em> <code class="literal">=</code>
        <em class="replaceable"><code>constant_value</code></em>. For example, MySQL
        can use indexes and ranges to search for <code class="literal">NULL</code>
        with <a href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a>.
      </p><p>
        Examples:
      </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> IS NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> &lt;=&gt; NULL;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const1</code></em> OR <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>const2</code></em> OR <em class="replaceable"><code>key_col</code></em> IS NULL;
</pre><p>
        If a <code class="literal">WHERE</code> clause includes a
        <em class="replaceable"><code>col_name</code></em> <a href="functions.html#operator_is-null"><code class="literal">IS
        NULL</code></a> condition for a column that is declared as
        <code class="literal">NOT NULL</code>, that expression is optimized away.
        This optimization does not occur in cases when the column might
        produce <code class="literal">NULL</code> anyway; for example, if it comes
        from a table on the right side of a <code class="literal">LEFT
        JOIN</code>.
      </p><p>
        MySQL can also optimize the combination
        <code class="literal"><em class="replaceable"><code>col_name</code></em> =
        <em class="replaceable"><code>expr</code></em> OR
        <em class="replaceable"><code>col_name</code></em> IS NULL</code>, a form
        that is common in resolved subqueries.
        <code class="literal">EXPLAIN</code> shows <code class="literal">ref_or_null</code>
        when this optimization is used.
      </p><p>
        This optimization can handle one <a href="functions.html#operator_is-null"><code class="literal">IS
        NULL</code></a> for any key part.
      </p><p>
        Some examples of queries that are optimized, assuming that there
        is an index on columns <code class="literal">a</code> and
        <code class="literal">b</code> of table <code class="literal">t2</code>:
      </p><pre class="programlisting">SELECT * FROM t1 WHERE t1.a=<em class="replaceable"><code>expr</code></em> OR t1.a IS NULL;

SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;

SELECT * FROM t1, t2
  WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);

SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
  OR (t1.a=t2.a AND t2.a IS NULL AND ...);
</pre><p>
        <code class="literal">ref_or_null</code> works by first doing a read on
        the reference key, and then a separate search for rows with a
        <code class="literal">NULL</code> key value.
      </p><p>
        Note that the optimization can handle only one
        <a href="functions.html#operator_is-null"><code class="literal">IS NULL</code></a> level. In the
        following query, MySQL uses key lookups only on the expression
        <code class="literal">(t1.a=t2.a AND t2.a IS NULL)</code> and is not able
        to use the key part on <code class="literal">b</code>:
      </p><pre class="programlisting">SELECT * FROM t1, t2
  WHERE (t1.a=t2.a AND t2.a IS NULL)
  OR (t1.b=t2.b AND t2.b IS NULL);
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="left-join-optimization"></a>7.2.9. <code class="literal">LEFT JOIN</code> and <code class="literal">RIGHT JOIN</code>
        Optimization</h3></div></div></div><a class="indexterm" name="id2057260"></a><a class="indexterm" name="id2057269"></a><p>
        MySQL implements an <code class="literal"><em class="replaceable"><code>A</code></em> LEFT
        JOIN <em class="replaceable"><code>B</code></em> join_condition</code> as
        follows:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Table <em class="replaceable"><code>B</code></em> is set to depend on table
            <em class="replaceable"><code>A</code></em> and all tables on which
            <em class="replaceable"><code>A</code></em> depends.
          </p></li><li><p>
            Table <em class="replaceable"><code>A</code></em> is set to depend on all
            tables (except <em class="replaceable"><code>B</code></em>) that are used
            in the <code class="literal">LEFT JOIN</code> condition.
          </p></li><li><p>
            The <code class="literal">LEFT JOIN</code> condition is used to decide
            how to retrieve rows from table
            <em class="replaceable"><code>B</code></em>. (In other words, any condition
            in the <code class="literal">WHERE</code> clause is not used.)
          </p></li><li><p>
            All standard join optimizations are performed, with the
            exception that a table is always read after all tables on
            which it depends. If there is a circular dependence, MySQL
            issues an error.
          </p></li><li><p>
            All standard <code class="literal">WHERE</code> optimizations are
            performed.
          </p></li><li><p>
            If there is a row in <em class="replaceable"><code>A</code></em> that
            matches the <code class="literal">WHERE</code> clause, but there is no
            row in <em class="replaceable"><code>B</code></em> that matches the
            <code class="literal">ON</code> condition, an extra
            <em class="replaceable"><code>B</code></em> row is generated with all
            columns set to <code class="literal">NULL</code>.
          </p></li><li><p>
            If you use <code class="literal">LEFT JOIN</code> to find rows that do
            not exist in some table and you have the following test:
            <code class="literal"><em class="replaceable"><code>col_name</code></em> IS
            NULL</code> in the <code class="literal">WHERE</code> part, where
            <em class="replaceable"><code>col_name</code></em> is a column that is
            declared as <code class="literal">NOT NULL</code>, MySQL stops
            searching for more rows (for a particular key combination)
            after it has found one row that matches the <code class="literal">LEFT
            JOIN</code> condition.
          </p></li></ul></div><p>
        The implementation of <code class="literal">RIGHT JOIN</code> is analogous
        to that of <code class="literal">LEFT JOIN</code> with the roles of the
        tables reversed.
      </p><p>
        <a class="indexterm" name="id2057481"></a>

        The join optimizer calculates the order in which tables should
        be joined. The table read order forced by <code class="literal">LEFT
        JOIN</code> or <code class="literal">STRAIGHT_JOIN</code> helps the
        join optimizer do its work much more quickly, because there are
        fewer table permutations to check. Note that this means that if
        you do a query of the following type, MySQL does a full scan on
        <code class="literal">b</code> because the <code class="literal">LEFT JOIN</code>
        forces it to be read before <code class="literal">d</code>:
      </p><pre class="programlisting">SELECT *
  FROM a JOIN b LEFT JOIN c ON (c.key=a.key) 
  LEFT JOIN d ON (d.key=a.key)
  WHERE b.key=d.key;
</pre><p>
        The fix in this case is reverse the order in which
        <code class="literal">a</code> and <code class="literal">b</code> are listed in the
        <code class="literal">FROM</code> clause:
      </p><pre class="programlisting">SELECT *
  FROM b JOIN a LEFT JOIN c ON (c.key=a.key) 
  LEFT JOIN d ON (d.key=a.key)
  WHERE b.key=d.key;
</pre><p>
        For a <code class="literal">LEFT JOIN</code>, if the
        <code class="literal">WHERE</code> condition is always false for the
        generated <code class="literal">NULL</code> row, the <code class="literal">LEFT
        JOIN</code> is changed to a normal join. For example, the
        <code class="literal">WHERE</code> clause would be false in the following
        query if <code class="literal">t2.column1</code> were
        <code class="literal">NULL</code>:
      </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
</pre><p>
        Therefore, it is safe to convert the query to a normal join:
      </p><pre class="programlisting">SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
</pre><p>
        <a class="indexterm" name="id2057623"></a>

        This can be made faster because MySQL can use table
        <code class="literal">t2</code> before table <code class="literal">t1</code> if
        doing so would result in a better query plan. To provide a hint
        about the table join order, use
        <code class="literal">STRAIGHT_JOIN</code>. (See
        <a href="sql-syntax.html#select" title="12.2.7. SELECT Syntax">Section 12.2.7, “<code class="literal">SELECT</code> Syntax”</a>.)
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="nested-joins"></a>7.2.10. Nested Join Optimization</h3></div></div></div><p>
        The syntax for expressing joins allows nested joins. The
        following discussion refers to the join syntax described in
        <a href="sql-syntax.html#join" title="12.2.7.1. JOIN Syntax">Section 12.2.7.1, “<code class="literal">JOIN</code> Syntax”</a>.
      </p><p>
        The syntax of <em class="replaceable"><code>table_factor</code></em> is
        extended in comparison with the SQL Standard. The latter accepts
        only <em class="replaceable"><code>table_reference</code></em>, not a list of
        them inside a pair of parentheses. This is a conservative
        extension if we consider each comma in a list of
        <em class="replaceable"><code>table_reference</code></em> items as equivalent
        to an inner join. For example:
      </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
        is equivalent to:
      </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre><p>
        In MySQL, <code class="literal">CROSS JOIN</code> is a syntactic
        equivalent to <code class="literal">INNER JOIN</code> (they can replace
        each other). In standard SQL, they are not equivalent.
        <code class="literal">INNER JOIN</code> is used with an
        <code class="literal">ON</code> clause; <code class="literal">CROSS JOIN</code> is
        used otherwise.
      </p><p>
        In general, parentheses can be ignored in join expressions
        containing only inner join operations. After removing
        parentheses and grouping operations to the left, the join
        expression:
      </p><pre class="programlisting">t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
</pre><p>
        transforms into the expression:
      </p><pre class="programlisting">(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
</pre><p>
        Yet, the two expressions are not equivalent. To see this,
        suppose that the tables <code class="literal">t1</code>,
        <code class="literal">t2</code>, and <code class="literal">t3</code> have the
        following state:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Table <code class="literal">t1</code> contains rows
            <code class="literal">(1)</code>, <code class="literal">(2)</code>
          </p></li><li><p>
            Table <code class="literal">t2</code> contains row
            <code class="literal">(1,101)</code>
          </p></li><li><p>
            Table <code class="literal">t3</code> contains row
            <code class="literal">(101)</code>
          </p></li></ul></div><p>
        In this case, the first expression returns a result set
        including the rows <code class="literal">(1,1,101,101)</code>,
        <code class="literal">(2,NULL,NULL,NULL)</code>, whereas the second
        expression returns the rows <code class="literal">(1,1,101,101)</code>,
        <code class="literal">(2,NULL,NULL,101)</code>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM t1</code></strong>
    -&gt;      <strong class="userinput"><code>LEFT JOIN</code></strong>
    -&gt;      <strong class="userinput"><code>(t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)</code></strong>
    -&gt;      <strong class="userinput"><code>ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)</code></strong>
    -&gt;      <strong class="userinput"><code>LEFT JOIN t3</code></strong>
    -&gt;      <strong class="userinput"><code>ON t2.b=t3.b OR t2.b IS NULL;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
        In the following example, an outer join operation is used
        together with an inner join operation:
      </p><pre class="programlisting">t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
</pre><p>
        That expression cannot be transformed into the following
        expression:
      </p><pre class="programlisting">t1 LEFT JOIN t2 ON t1.a=t2.a, t3.
</pre><p>
        For the given table states, the two expressions return different
        sets of rows:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL | NULL |
+------+------+------+------+

mysql&gt; <strong class="userinput"><code>SELECT *</code></strong>
    -&gt; <strong class="userinput"><code>FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;</code></strong>
+------+------+------+------+
| a    | a    | b    | b    |
+------+------+------+------+
|    1 |    1 |  101 |  101 |
|    2 | NULL | NULL |  101 |
+------+------+------+------+
</pre><p>
        Therefore, if we omit parentheses in a join expression with
        outer join operators, we might change the result set for the
        original expression.
      </p><p>
        More exactly, we cannot ignore parentheses in the right operand
        of the left outer join operation and in the left operand of a
        right join operation. In other words, we cannot ignore
        parentheses for the inner table expressions of outer join
        operations. Parentheses for the other operand (operand for the
        outer table) can be ignored.
      </p><p>
        The following expression:
      </p><pre class="programlisting">(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
        is equivalent to this expression:
      </p><pre class="programlisting">t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)
</pre><p>
        for any tables <code class="literal">t1,t2,t3</code> and any condition
        <code class="literal">P</code> over attributes <code class="literal">t2.b</code> and
        <code class="literal">t3.b</code>.
      </p><p>
        Whenever the order of execution of the join operations in a join
        expression (<em class="replaceable"><code>join_table</code></em>) is not from
        left to right, we talk about nested joins. Consider the
        following queries:
      </p><pre class="programlisting">SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a &gt; 1

SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a &gt; 1
</pre><p>
        Those queries are considered to contain these nested joins:
      </p><pre class="programlisting">t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
</pre><p>
        The nested join is formed in the first query with a left join
        operation, whereas in the second query it is formed with an
        inner join operation.
      </p><p>
        In the first query, the parentheses can be omitted: The
        grammatical structure of the join expression will dictate the
        same order of execution for join operations. For the second
        query, the parentheses cannot be omitted, although the join
        expression here can be interpreted unambiguously without them.
        (In our extended syntax the parentheses in <code class="literal">(t2,
        t3)</code> of the second query are required, although
        theoretically the query could be parsed without them: We still
        would have unambiguous syntactical structure for the query
        because <code class="literal">LEFT JOIN</code> and <code class="literal">ON</code>
        would play the role of the left and right delimiters for the
        expression <code class="literal">(t2,t3)</code>.)
      </p><p>
        The preceding examples demonstrate these points:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            For join expressions involving only inner joins (and not
            outer joins), parentheses can be removed. You can remove
            parentheses and evaluate left to right (or, in fact, you can
            evaluate the tables in any order).
          </p></li><li><p>
            The same is not true, in general, for outer joins or for
            outer joins mixed with inner joins. Removal of parentheses
            may change the result.
          </p></li></ul></div><p>
        Queries with nested outer joins are executed in the same
        pipeline manner as queries with inner joins. More exactly, a
        variation of the nested-loop join algorithm is exploited. Recall
        by what algorithmic schema the nested-loop join executes a
        query. Suppose that we have a join query over 3 tables
        <code class="literal">T1,T2,T3</code> of the form:
      </p><pre class="programlisting">SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3).
</pre><p>
        Here, <code class="literal">P1(T1,T2)</code> and
        <code class="literal">P2(T3,T3)</code> are some join conditions (on
        expressions), whereas <code class="literal">P(t1,t2,t3)</code> is a
        condition over columns of tables <code class="literal">T1,T2,T3</code>.
      </p><p>
        The nested-loop join algorithm would execute this query in the
        following manner:
      </p><pre class="programlisting">FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
        The notation <code class="literal">t1||t2||t3</code> means “<span class="quote">a row
        constructed by concatenating the columns of rows
        <code class="literal">t1</code>, <code class="literal">t2</code>, and
        <code class="literal">t3</code>.</span>” In some of the following
        examples, <code class="literal">NULL</code> where a row name appears means
        that <code class="literal">NULL</code> is used for each column of that
        row. For example, <code class="literal">t1||t2||NULL</code> means “<span class="quote">a
        row constructed by concatenating the columns of rows
        <code class="literal">t1</code> and <code class="literal">t2</code>, and
        <code class="literal">NULL</code> for each column of
        <code class="literal">t3</code>.</span>”
      </p><p>
        Now let's consider a query with nested outer joins:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON P2(T2,T3))
              ON P1(T1,T2)
  WHERE P(T1,T2,T3).
</pre><p>
        For this query, we modify the nested-loop pattern to get:
      </p><pre class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF P(t1,t2,NULL) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
        In general, for any nested loop for the first inner table in an
        outer join operation, a flag is introduced that is turned off
        before the loop and is checked after the loop. The flag is
        turned on when for the current row from the outer table a match
        from the table representing the inner operand is found. If at
        the end of the loop cycle the flag is still off, no match has
        been found for the current row of the outer table. In this case,
        the row is complemented by <code class="literal">NULL</code> values for
        the columns of the inner tables. The result row is passed to the
        final check for the output or into the next nested loop, but
        only if the row satisfies the join condition of all embedded
        outer joins.
      </p><p>
        In our example, the outer join table expressed by the following
        expression is embedded:
      </p><pre class="programlisting">(T2 LEFT JOIN T3 ON P2(T2,T3))
</pre><p>
        Note that for the query with inner joins, the optimizer could
        choose a different order of nested loops, such as this one:
      </p><pre class="programlisting">FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
        For the queries with outer joins, the optimizer can choose only
        such an order where loops for outer tables precede loops for
        inner tables. Thus, for our query with outer joins, only one
        nesting order is possible. For the following query, the
        optimizer will evaluate two different nestings:
      </p><pre class="programlisting">SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
  WHERE P(T1,T2,T3)
</pre><p>
        The nestings are these:
      </p><pre class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
        and:
      </p><pre class="programlisting">FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
    IF P(t1,NULL,NULL) {
      t:=t1||NULL||NULL; OUTPUT t;
    }
  }
}
</pre><p>
        In both nestings, <code class="literal">T1</code> must be processed in the
        outer loop because it is used in an outer join.
        <code class="literal">T2</code> and <code class="literal">T3</code> are used in an
        inner join, so that join must be processed in the inner loop.
        However, because the join is an inner join,
        <code class="literal">T2</code> and <code class="literal">T3</code> can be processed
        in either order.
      </p><p>
        When discussing the nested-loop algorithm for inner joins, we
        omitted some details whose impact on the performance of query
        execution may be huge. We did not mention so-called
        “<span class="quote">pushed-down</span>” conditions. Suppose that our
        <code class="literal">WHERE</code> condition
        <code class="literal">P(T1,T2,T3)</code> can be represented by a
        conjunctive formula:
      </p><pre class="programlisting">P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3).
</pre><p>
        In this case, MySQL actually uses the following nested-loop
        schema for the execution of the query with inner joins:
      </p><pre class="programlisting">FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3; OUTPUT t;
      }
    }
  }
}
</pre><p>
        You see that each of the conjuncts <code class="literal">C1(T1)</code>,
        <code class="literal">C2(T2)</code>, <code class="literal">C3(T3)</code> are pushed
        out of the most inner loop to the most outer loop where it can
        be evaluated. If <code class="literal">C1(T1)</code> is a very restrictive
        condition, this condition pushdown may greatly reduce the number
        of rows from table <code class="literal">T1</code> passed to the inner
        loops. As a result, the execution time for the query may improve
        immensely.
      </p><p>
        For a query with outer joins, the <code class="literal">WHERE</code>
        condition is to be checked only after it has been found that the
        current row from the outer table has a match in the inner
        tables. Thus, the optimization of pushing conditions out of the
        inner nested loops cannot be applied directly to queries with
        outer joins. Here we have to introduce conditional pushed-down
        predicates guarded by the flags that are turned on when a match
        has been encountered.
      </p><p>
        For our example with outer joins with:
      </p><pre class="programlisting">P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
</pre><p>
        the nested-loop schema using guarded pushed-down conditions
        looks like this:
      </p><pre class="programlisting">FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2
      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3
        such that P2(t2,t3) AND (f1&amp;&amp;f2?C3(t3):TRUE) {
      IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) {
        t:=t1||t2||t3; OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
      IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) {
        t:=t1||t2||NULL; OUTPUT t;
      }
      f1=TRUE;
    }
  }
  IF (!f1 &amp;&amp; P(t1,NULL,NULL)) {
      t:=t1||NULL||NULL; OUTPUT t;
  }
}
</pre><p>
        In general, pushed-down predicates can be extracted from join
        conditions such as <code class="literal">P1(T1,T2)</code> and
        <code class="literal">P(T2,T3)</code>. In this case, a pushed-down
        predicate is guarded also by a flag that prevents checking the
        predicate for the <code class="literal">NULL</code>-complemented row
        generated by the corresponding outer join operation.
      </p><p>
        Note that access by key from one inner table to another in the
        same nested join is prohibited if it is induced by a predicate
        from the <code class="literal">WHERE</code> condition. (We could use
        conditional key access in this case, but this technique is not
        employed yet in MySQL 5.1.)
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="outer-join-simplification"></a>7.2.11. Outer Join Simplification</h3></div></div></div><p>
        Table expressions in the <code class="literal">FROM</code> clause of a
        query are simplified in many cases.
      </p><p>
        At the parser stage, queries with right outer joins operations
        are converted to equivalent queries containing only left join
        operations. In the general case, the conversion is performed
        according to the following rule:
      </p><pre class="programlisting">(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =
(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)
</pre><p>
        All inner join expressions of the form <code class="literal">T1 INNER JOIN T2
        ON P(T1,T2)</code> are replaced by the list
        <code class="literal">T1,T2</code>, <code class="literal">P(T1,T2)</code> being
        joined as a conjunct to the <code class="literal">WHERE</code> condition
        (or to the join condition of the embedding join, if there is
        any).
      </p><p>
        When the optimizer evaluates plans for join queries with outer
        join operation, it takes into consideration only the plans
        where, for each such operation, the outer tables are accessed
        before the inner tables. The optimizer options are limited
        because only such plans enables us to execute queries with outer
        joins operations by the nested loop schema.
      </p><p>
        Suppose that we have a query of the form:
      </p><pre class="programlisting">SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
  WHERE P(T1,T2) AND R(T2)
</pre><p>
        with <code class="literal">R(T2)</code> narrowing greatly the number of
        matching rows from table <code class="literal">T2</code>. If we executed
        the query as it is, the optimizer would have no other choice
        besides to access table <code class="literal">T1</code> before table
        <code class="literal">T2</code> that may lead to a very inefficient
        execution plan.
      </p><p>
        Fortunately, MySQL converts such a query into a query without an
        outer join operation if the <code class="literal">WHERE</code> condition
        is null-rejected. A condition is called null-rejected for an
        outer join operation if it evaluates to <code class="literal">FALSE</code>
        or to <code class="literal">UNKNOWN</code> for any
        <code class="literal">NULL</code>-complemented row built for the
        operation.
      </p><p>
        Thus, for this outer join:
      </p><pre class="programlisting">T1 LEFT JOIN T2 ON T1.A=T2.A
</pre><p>
        Conditions such as these are null-rejected:
      </p><pre class="programlisting">T2.B IS NOT NULL,
T2.B &gt; 3,
T2.C &lt;= T1.C,
T2.B &lt; 2 OR T2.C &gt; 1
</pre><p>
        Conditions such as these are not null-rejected:
      </p><pre class="programlisting">T2.B IS NULL,
T1.B &lt; 3 OR T2.B IS NOT NULL,
T1.B &lt; 3 OR T2.B &gt; 3
</pre><p>
        The general rules for checking whether a condition is
        null-rejected for an outer join operation are simple. A
        condition is null-rejected in the following cases:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If it is of the form <code class="literal">A IS NOT NULL</code>, where
            <code class="literal">A</code> is an attribute of any of the inner
            tables
          </p></li><li><p>
            If it is a predicate containing a reference to an inner
            table that evaluates to <code class="literal">UNKNOWN</code> when one
            of its arguments is <code class="literal">NULL</code>
          </p></li><li><p>
            If it is a conjunction containing a null-rejected condition
            as a conjunct
          </p></li><li><p>
            If it is a disjunction of null-rejected conditions
          </p></li></ul></div><p>
        A condition can be null-rejected for one outer join operation in
        a query and not null-rejected for another. In the query:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
        the <code class="literal">WHERE</code> condition is null-rejected for the
        second outer join operation but is not null-rejected for the
        first one.
      </p><p>
        If the <code class="literal">WHERE</code> condition is null-rejected for
        an outer join operation in a query, the outer join operation is
        replaced by an inner join operation.
      </p><p>
        For example, the preceding query is replaced with the query:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T1.B
  WHERE T3.C &gt; 0
</pre><p>
        For the original query, the optimizer would evaluate plans
        compatible with only one access order
        <code class="literal">T1,T2,T3</code>. For the replacing query, it
        additionally considers the access sequence
        <code class="literal">T3,T1,T2</code>.
      </p><p>
        A conversion of one outer join operation may trigger a
        conversion of another. Thus, the query:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 LEFT JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
        will be first converted to the query:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
                 INNER JOIN T3 ON T3.B=T2.B
  WHERE T3.C &gt; 0
</pre><p>
        which is equivalent to the query:
      </p><pre class="programlisting">SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
        Now the remaining outer join operation can be replaced by an
        inner join, too, because the condition
        <code class="literal">T3.B=T2.B</code> is null-rejected and we get a query
        without outer joins at all:
      </p><pre class="programlisting">SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
  WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre><p>
        Sometimes we succeed in replacing an embedded outer join
        operation, but cannot convert the embedding outer join. The
        following query:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0
</pre><p>
        is converted to:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 INNER JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A
  WHERE T3.C &gt; 0,
</pre><p>
        That can be rewritten only to the form still containing the
        embedding outer join operation:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2,T3)
              ON (T2.A=T1.A AND T3.B=T2.B)
  WHERE T3.C &gt; 0.
</pre><p>
        When trying to convert an embedded outer join operation in a
        query, we must take into account the join condition for the
        embedding outer join together with the <code class="literal">WHERE</code>
        condition. In the query:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2 LEFT JOIN T3 ON T3.B=T2.B)
              ON T2.A=T1.A AND T3.C=T1.C
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre><p>
        the <code class="literal">WHERE</code> condition is not null-rejected for
        the embedded outer join, but the join condition of the embedding
        outer join <code class="literal">T2.A=T1.A AND T3.C=T1.C</code> is
        null-rejected. So the query can be converted to:
      </p><pre class="programlisting">SELECT * FROM T1 LEFT JOIN
              (T2, T3)
              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
  WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="order-by-optimization"></a>7.2.12. <code class="literal">ORDER BY</code> Optimization</h3></div></div></div><p>
        In some cases, MySQL can use an index to satisfy an
        <code class="literal">ORDER BY</code> clause without doing any extra
        sorting.
      </p><p>
        The index can also be used even if the <code class="literal">ORDER
        BY</code> does not match the index exactly, as long as all of
        the unused portions of the index and all the extra
        <code class="literal">ORDER BY</code> columns are constants in the
        <code class="literal">WHERE</code> clause. The following queries use the
        index to resolve the <code class="literal">ORDER BY</code> part:
      </p><pre class="programlisting">SELECT * FROM t1 
  ORDER BY <em class="replaceable"><code>key_part1</code></em>,<em class="replaceable"><code>key_part2</code></em>,... ;
    
SELECT * FROM t1 
  WHERE <em class="replaceable"><code>key_part1</code></em>=<em class="replaceable"><code>constant</code></em> 
  ORDER BY <em class="replaceable"><code>key_part2</code></em>;
    
SELECT * FROM t1 
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC;
    
SELECT * FROM t1
  WHERE <em class="replaceable"><code>key_part1</code></em>=1 
  ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> DESC;
</pre><p>
        In some cases, MySQL <span class="emphasis"><em>cannot</em></span> use indexes to
        resolve the <code class="literal">ORDER BY</code>, although it still uses
        indexes to find the rows that match the <code class="literal">WHERE</code>
        clause. These cases include the following:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            You use <code class="literal">ORDER BY</code> on different keys:
          </p><pre class="programlisting">SELECT * FROM t1 ORDER BY <em class="replaceable"><code>key1</code></em>, <em class="replaceable"><code>key2</code></em>;
</pre></li><li><p>
            You use <code class="literal">ORDER BY</code> on non-consecutive parts
            of a key:
          </p><pre class="programlisting">SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key_part2</code></em>;
</pre></li><li><p>
            You mix <code class="literal">ASC</code> and <code class="literal">DESC</code>:
          </p><pre class="programlisting">SELECT * FROM t1 ORDER BY <em class="replaceable"><code>key_part1</code></em> DESC, <em class="replaceable"><code>key_part2</code></em> ASC;
</pre></li><li><p>
            The key used to fetch the rows is not the same as the one
            used in the <code class="literal">ORDER BY</code>:
          </p><pre class="programlisting">SELECT * FROM t1 WHERE <em class="replaceable"><code>key2</code></em>=<em class="replaceable"><code>constant</code></em> ORDER BY <em class="replaceable"><code>key1</code></em>;
</pre></li><li><p>
            You use <code class="literal">ORDER BY</code> with an expression that
            includes terms other than the key column name:
          </p><pre class="programlisting">SELECT * FROM t1 ORDER BY ABS(<em class="replaceable"><code>key</code></em>);
SELECT * FROM t1 ORDER BY -<em class="replaceable"><code>key</code></em>;
</pre></li><li><p>
            You are joining many tables, and the columns in the
            <code class="literal">ORDER BY</code> are not all from the first
            non-constant table that is used to retrieve rows. (This is
            the first table in the <code class="literal">EXPLAIN</code> output
            that does not have a <code class="literal">const</code> join type.)
          </p></li><li><p>
            You have different <code class="literal">ORDER BY</code> and
            <code class="literal">GROUP BY</code> expressions.
          </p></li><li><p>
            The type of table index used does not store rows in order.
            For example, this is true for a <code class="literal">HASH</code>
            index in a <code class="literal">MEMORY</code> table.
          </p></li></ul></div><p>
        Availability of an index for sorting may be affected by the use
        of column aliases. Suppose that the column
        <code class="literal">t1.a</code> is indexed. In this statement, the name
        of the column in the select list is <code class="literal">a</code>. It
        refers to <code class="literal">t1.a</code>, so for the reference to
        <code class="literal">a</code> in the <code class="literal">ORDER BY</code>, the
        index can be used:
      </p><pre class="programlisting">SELECT a FROM t1 ORDER BY a;
</pre><p>
        In this statement, the name of the column in the select list is
        also <code class="literal">a</code>, but it is the alias name. It refers
        to <code class="literal">ABS(a)</code>, so for the reference to
        <code class="literal">a</code> in the <code class="literal">ORDER BY</code>, the
        index cannot be used:
      </p><pre class="programlisting">SELECT ABS(a) AS a FROM t1 ORDER BY a;
</pre><p>
        In the following statement, the <code class="literal">ORDER BY</code>
        refers to a name that is not the name of a column in the select
        list. But there is a column in <code class="literal">t1</code> named
        <code class="literal">a</code>, so the <code class="literal">ORDER BY</code> uses
        that, and the index can be used. (The resulting sort order may
        be completely different from the order for
        <code class="literal">ABS(a)</code>, of course.)
      </p><pre class="programlisting">SELECT ABS(a) AS b FROM t1 ORDER BY a;
</pre><a class="indexterm" name="id2059427"></a><a class="indexterm" name="id2059439"></a><p>
        By default, MySQL sorts all <code class="literal">GROUP BY
        <em class="replaceable"><code>col1</code></em>,
        <em class="replaceable"><code>col2</code></em>, ...</code> queries as if you
        specified <code class="literal">ORDER BY <em class="replaceable"><code>col1</code></em>,
        <em class="replaceable"><code>col2</code></em>, ...</code> in the query as
        well. If you include an <code class="literal">ORDER BY</code> clause
        explicitly that contains the same column list, MySQL optimizes
        it away without any speed penalty, although the sorting still
        occurs. If a query includes <code class="literal">GROUP BY</code> but you
        want to avoid the overhead of sorting the result, you can
        suppress sorting by specifying <code class="literal">ORDER BY NULL</code>.
        For example:
      </p><pre class="programlisting">INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
</pre><p>
        With <code class="literal">EXPLAIN SELECT ... ORDER BY</code>, you can
        check whether MySQL can use indexes to resolve the query. It
        cannot if you see <code class="literal">Using filesort</code> in the
        <code class="literal">Extra</code> column. See
        <a href="optimization.html#using-explain" title="7.2.1. Optimizing Queries with EXPLAIN">Section 7.2.1, “Optimizing Queries with <code class="literal">EXPLAIN</code>”</a>.
      </p><a class="indexterm" name="id2059536"></a><a class="indexterm" name="id2059545"></a><p>
        MySQL has two <code class="literal">filesort</code> algorithms for sorting
        and retrieving results. The original method uses only the
        <code class="literal">ORDER BY</code> columns. The modified method uses
        not just the <code class="literal">ORDER BY</code> columns, but all the
        columns used in the query.
      </p><p>
        The optimizer selects which <code class="literal">filesort</code>
        algorithm to use. It normally uses the modified algorithm except
        when <code class="literal">BLOB</code> or <code class="literal">TEXT</code> columns
        are involved, in which case it uses the original algorithm.
      </p><p>
        The original <code class="literal">filesort</code> algorithm works as
        follows:
      </p><div class="orderedlist"><ol type="1"><li><p>
            Read all rows according to key or by table scanning. Rows
            that do not match the <code class="literal">WHERE</code> clause are
            skipped.
          </p></li><li><p>
            For each row, store a pair of values in a buffer (the sort
            key and the row pointer). The size of the buffer is the
            value of the <code class="literal">sort_buffer_size</code> system
            variable.
          </p></li><li><p>
            When the buffer gets full, run a qsort (quicksort) on it and
            store the result in a temporary file. Save a pointer to the
            sorted block. (If all pairs fit into the sort buffer, no
            temporary file is created.)
          </p></li><li><p>
            Repeat the preceding steps until all rows have been read.
          </p></li><li><p>
            Do a multi-merge of up to <code class="literal">MERGEBUFF</code> (7)
            regions to one block in another temporary file. Repeat until
            all blocks from the first file are in the second file.
          </p></li><li><p>
            Repeat the following until there are fewer than
            <code class="literal">MERGEBUFF2</code> (15) blocks left.
          </p></li><li><p>
            On the last multi-merge, only the pointer to the row (the
            last part of the sort key) is written to a result file.
          </p></li><li><p>
            Read the rows in sorted order by using the row pointers in
            the result file. To optimize this, we read in a big block of
            row pointers, sort them, and use them to read the rows in
            sorted order into a row buffer. The size of the buffer is
            the value of the <code class="literal">read_rnd_buffer_size</code>
            system variable. The code for this step is in the
            <code class="filename">sql/records.cc</code> source file.
          </p></li></ol></div><p>
        One problem with this approach is that it reads rows twice: One
        time when evaluating the <code class="literal">WHERE</code> clause, and
        again after sorting the pair values. And even if the rows were
        accessed successively the first time (for example, if a table
        scan is done), the second time they are accessed randomly. (The
        sort keys are ordered, but the row positions are not.)
      </p><p>
        The modified <code class="literal">filesort</code> algorithm incorporates
        an optimization such that it records not only the sort key value
        and row position, but also the columns required for the query.
        This avoids reading the rows twice. The modified
        <code class="literal">filesort</code> algorithm works like this:
      </p><div class="orderedlist"><ol type="1"><li><p>
            Read the rows that match the <code class="literal">WHERE</code>
            clause.
          </p></li><li><p>
            For each row, record a tuple of values consisting of the
            sort key value and row position, and also the columns
            required for the query.
          </p></li><li><p>
            Sort the tuples by sort key value
          </p></li><li><p>
            Retrieve the rows in sorted order, but read the required
            columns directly from the sorted tuples rather than by
            accessing the table a second time.
          </p></li></ol></div><p>
        Using the modified <code class="literal">filesort</code> algorithm, the
        tuples are longer than the pairs used in the original method,
        and fewer of them fit in the sort buffer (the size of which is
        given by <code class="literal">sort_buffer_size</code>). As a result, it
        is possible for the extra I/O to make the modified approach
        slower, not faster. To avoid a slowdown, the optimization is
        used only if the total size of the extra columns in the sort
        tuple does not exceed the value of the
        <code class="literal">max_length_for_sort_data</code> system variable. (A
        symptom of setting the value of this variable too high is that
        you should see high disk activity and low CPU activity.)
      </p><p>
        For slow queries for which <code class="literal">filesort</code> is not
        used, you might try lowering
        <code class="literal">max_length_for_sort_data</code> to a value that is
        appropriate to trigger a <code class="literal">filesort</code>.
      </p><p>
        If you want to increase <code class="literal">ORDER BY</code> speed, check
        whether you can get MySQL to use indexes rather than an extra
        sorting phase. If this is not possible, you can try the
        following strategies:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Increase the size of the <code class="literal">sort_buffer_size</code>
            variable.
          </p></li><li><p>
            Increase the size of the
            <code class="literal">read_rnd_buffer_size</code> variable.
          </p></li><li><p>
            Use less RAM per row by declaring columns only as large as
            they need to be to hold the values stored in them. For
            example, <code class="literal">CHAR(16)</code> is better than
            <code class="literal">CHAR(200)</code> if values never exceed 16
            characters.
          </p></li><li><p>
            Change <code class="literal">tmpdir</code> to point to a dedicated
            filesystem with large amounts of free space. Also, this
            option accepts several paths that are used in round-robin
            fashion, so you can use this feature to spread the load
            across several directories. Paths should be separated by
            colon characters (“<span class="quote"><code class="literal">:</code></span>”) on
            Unix and semicolon characters
            (“<span class="quote"><code class="literal">;</code></span>”) on Windows, NetWare,
            and OS/2. The paths should be for directories in filesystems
            that are located on different <span class="emphasis"><em>physical</em></span>
            disks, not different partitions on the same disk.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="group-by-optimization"></a>7.2.13. <code class="literal">GROUP BY</code> Optimization</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#loose-index-scan">7.2.13.1. Loose index scan</a></span></dt><dt><span class="section"><a href="optimization.html#tight-index-scan">7.2.13.2. Tight index scan</a></span></dt></dl></div><a class="indexterm" name="id2059953"></a><a class="indexterm" name="id2059962"></a><p>
        The most general way to satisfy a <code class="literal">GROUP BY</code>
        clause is to scan the whole table and create a new temporary
        table where all rows from each group are consecutive, and then
        use this temporary table to discover groups and apply aggregate
        functions (if any). In some cases, MySQL is able to do much
        better than that and to avoid creation of temporary tables by
        using index access.
      </p><p>
        The most important preconditions for using indexes for
        <code class="literal">GROUP BY</code> are that all <code class="literal">GROUP
        BY</code> columns reference attributes from the same index,
        and that the index stores its keys in order (for example, this
        is a <code class="literal">BTREE</code> index and not a
        <code class="literal">HASH</code> index). Whether use of temporary tables
        can be replaced by index access also depends on which parts of
        an index are used in a query, the conditions specified for these
        parts, and the selected aggregate functions.
      </p><p>
        In MySQL, <code class="literal">GROUP BY</code> is used for sorting, so
        the server may also apply <code class="literal">ORDER BY</code>
        optimizations to grouping. See
        <a href="optimization.html#order-by-optimization" title="7.2.12. ORDER BY Optimization">Section 7.2.12, “<code class="literal">ORDER BY</code> Optimization”</a>.
      </p><p>
        There are two ways to execute a <code class="literal">GROUP BY</code>
        query via index access, as detailed in the following sections.
        In the first method, the grouping operation is applied together
        with all range predicates (if any). The second method first
        performs a range scan, and then groups the resulting tuples.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="loose-index-scan"></a>7.2.13.1. Loose index scan</h4></div></div></div><p>
          The most efficient way to process <code class="literal">GROUP BY</code>
          is when the index is used to directly retrieve the group
          fields. With this access method, MySQL uses the property of
          some index types that the keys are ordered (for example,
          <code class="literal">BTREE</code>). This property enables use of lookup
          groups in an index without having to consider all keys in the
          index that satisfy all <code class="literal">WHERE</code> conditions.
          This access method considers only a fraction of the keys in an
          index, so it is called a <em class="firstterm">loose index
          scan</em>. When there is no <code class="literal">WHERE</code>
          clause, a loose index scan reads as many keys as the number of
          groups, which may be a much smaller number than that of all
          keys. If the <code class="literal">WHERE</code> clause contains range
          predicates (see the discussion of the <code class="literal">range</code>
          join type in <a href="optimization.html#using-explain" title="7.2.1. Optimizing Queries with EXPLAIN">Section 7.2.1, “Optimizing Queries with <code class="literal">EXPLAIN</code>”</a>), a loose index
          scan looks up the first key of each group that satisfies the
          range conditions, and again reads the least possible number of
          keys. This is possible under the following conditions:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              The query is over a single table.
            </p></li><li><p>
              The <code class="literal">GROUP BY</code> includes the first
              consecutive parts of the index. (If, instead of
              <code class="literal">GROUP BY</code>, the query has a
              <code class="literal">DISTINCT</code> clause, all distinct
              attributes refer to the beginning of the index.)
            </p></li><li><p>
              The only aggregate functions used (if any) are
              <a href="functions.html#function_min"><code class="literal">MIN()</code></a> and
              <a href="functions.html#function_max"><code class="literal">MAX()</code></a>, and all of them
              refer to the same column.
            </p></li><li><p>
              Any other parts of the index than those from the
              <code class="literal">GROUP BY</code> referenced in the query must
              be constants (that is, they must be referenced in
              equalities with constants), except for the argument of
              <a href="functions.html#function_min"><code class="literal">MIN()</code></a> or
              <a href="functions.html#function_max"><code class="literal">MAX()</code></a> functions.
            </p></li></ul></div><p>
          The <code class="literal">EXPLAIN</code> output for such queries shows
          <code class="literal">Using index for group-by</code> in the
          <code class="literal">Extra</code> column.
        </p><p>
          The following queries fall into this category, assuming that
          there is an index <code class="literal">idx(c1,c2,c3)</code> on table
          <code class="literal">t1(c1,c2,c3,c4)</code>:
        </p><pre class="programlisting">SELECT c1, c2 FROM t1 GROUP BY c1, c2;
SELECT DISTINCT c1, c2 FROM t1;
SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
SELECT c1, c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c2 FROM t1 WHERE c1 &lt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
SELECT c1, c2 FROM t1 WHERE c3 = <em class="replaceable"><code>const</code></em> GROUP BY c1, c2;
</pre><p>
          The following queries cannot be executed with this quick
          select method, for the reasons given:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              There are aggregate functions other than
              <a href="functions.html#function_min"><code class="literal">MIN()</code></a> or
              <a href="functions.html#function_max"><code class="literal">MAX()</code></a>, for example:
            </p><pre class="programlisting">SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
</pre></li><li><p>
              The fields in the <code class="literal">GROUP BY</code> clause do
              not refer to the beginning of the index, as shown here:
            </p><pre class="programlisting">SELECT c1,c2 FROM t1 GROUP BY c2, c3;
</pre></li><li><p>
              The query refers to a part of a key that comes after the
              <code class="literal">GROUP BY</code> part, and for which there is
              no equality with a constant, an example being:
            </p><pre class="programlisting">SELECT c1,c3 FROM t1 GROUP BY c1, c2;
</pre></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tight-index-scan"></a>7.2.13.2. Tight index scan</h4></div></div></div><p>
          A tight index scan may be either a full index scan or a range
          index scan, depending on the query conditions.
        </p><p>
          When the conditions for a loose index scan are not met, it is
          still possible to avoid creation of temporary tables for
          <code class="literal">GROUP BY</code> queries. If there are range
          conditions in the <code class="literal">WHERE</code> clause, this method
          reads only the keys that satisfy these conditions. Otherwise,
          it performs an index scan. Because this method reads all keys
          in each range defined by the <code class="literal">WHERE</code> clause,
          or scans the whole index if there are no range conditions, we
          term it a <em class="firstterm">tight index scan</em>. Notice that
          with a tight index scan, the grouping operation is performed
          only after all keys that satisfy the range conditions have
          been found.
        </p><p>
          For this method to work, it is sufficient that there is a
          constant equality condition for all columns in a query
          referring to parts of the key coming before or in between
          parts of the <code class="literal">GROUP BY</code> key. The constants
          from the equality conditions fill in any “<span class="quote">gaps</span>”
          in the search keys so that it is possible to form complete
          prefixes of the index. These index prefixes then can be used
          for index lookups. If we require sorting of the <code class="literal">GROUP
          BY</code> result, and it is possible to form search keys
          that are prefixes of the index, MySQL also avoids extra
          sorting operations because searching with prefixes in an
          ordered index already retrieves all the keys in order.
        </p><p>
          The following queries do not work with the loose index scan
          access method described earlier, but still work with the tight
          index scan access method (assuming that there is an index
          <code class="literal">idx(c1,c2,c3)</code> on table
          <code class="literal">t1(c1,c2,c3,c4)</code>).
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              There is a gap in the <code class="literal">GROUP BY</code>, but it
              is covered by the condition <code class="literal">c2 = 'a'</code>:
            </p><pre class="programlisting">SELECT c1, c2, c3 FROM t1 WHERE c2 = 'a' GROUP BY c1, c3;
</pre></li><li><p>
              The <code class="literal">GROUP BY</code> does not begin with the
              first part of the key, but there is a condition that
              provides a constant for that part:
            </p><pre class="programlisting">SELECT c1, c2, c3 FROM t1 WHERE c1 = 'a' GROUP BY c2, c3;
</pre></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="distinct-optimization"></a>7.2.14. <code class="literal">DISTINCT</code> Optimization</h3></div></div></div><a class="indexterm" name="id2060487"></a><a class="indexterm" name="id2060496"></a><p>
        <code class="literal">DISTINCT</code> combined with <code class="literal">ORDER
        BY</code> needs a temporary table in many cases.
      </p><p>
        Because <code class="literal">DISTINCT</code> may use <code class="literal">GROUP
        BY</code>, you should be aware of how MySQL works with
        columns in <code class="literal">ORDER BY</code> or
        <code class="literal">HAVING</code> clauses that are not part of the
        selected columns. See <a href="functions.html#group-by-hidden-fields" title="11.12.3. GROUP BY and HAVING with Hidden
        Fields">Section 11.12.3, “<code class="literal">GROUP BY</code> and <code class="literal">HAVING</code> with Hidden
        Fields”</a>.
      </p><p>
        In most cases, a <code class="literal">DISTINCT</code> clause can be
        considered as a special case of <code class="literal">GROUP BY</code>. For
        example, the following two queries are equivalent:
      </p><pre class="programlisting">SELECT DISTINCT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em>;

SELECT c1, c2, c3 FROM t1
WHERE c1 &gt; <em class="replaceable"><code>const</code></em> GROUP BY c1, c2, c3;
</pre><p>
        Due to this equivalence, the optimizations applicable to
        <code class="literal">GROUP BY</code> queries can be also applied to
        queries with a <code class="literal">DISTINCT</code> clause. Thus, for
        more details on the optimization possibilities for
        <code class="literal">DISTINCT</code> queries, see
        <a href="optimization.html#group-by-optimization" title="7.2.13. GROUP BY Optimization">Section 7.2.13, “<code class="literal">GROUP BY</code> Optimization”</a>.
      </p><p>
        When combining <code class="literal">LIMIT
        <em class="replaceable"><code>row_count</code></em></code> with
        <code class="literal">DISTINCT</code>, MySQL stops as soon as it finds
        <em class="replaceable"><code>row_count</code></em> unique rows.
      </p><p>
        If you do not use columns from all tables named in a query,
        MySQL stops scanning any unused tables as soon as it finds the
        first match. In the following case, assuming that
        <code class="literal">t1</code> is used before <code class="literal">t2</code>
        (which you can check with <code class="literal">EXPLAIN</code>), MySQL
        stops reading from <code class="literal">t2</code> (for any particular row
        in <code class="literal">t1</code>) when it finds the first row in
        <code class="literal">t2</code>:
      </p><pre class="programlisting">SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="in-subquery-optimization"></a>7.2.15. Optimizing <code class="literal">IN</code>/<code class="literal">=ANY</code> Subqueries</h3></div></div></div><a class="indexterm" name="id2060704"></a><a class="indexterm" name="id2060712"></a><p>
        Certain optimizations are applicable to comparisons that use the
        <code class="literal">IN</code> operator to test subquery results (or that
        use <code class="literal">=ANY</code>, which is equivalent). This section
        discusses these optimizations, particularly with regard to the
        challenges that <code class="literal">NULL</code> values present.
        Suggestions on what you can do to help the optimizer are given
        at the end of the discussion.
      </p><p>
        Consider the following subquery comparison:
      </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
        MySQL evaluates queries “<span class="quote">from outside to inside.</span>”
        That is, it first obtains the value of the outer expression
        <em class="replaceable"><code>outer_expr</code></em>, and then runs the
        subquery and captures the rows that it produces.
      </p><p>
        A very useful optimization is to “<span class="quote">inform</span>” the
        subquery that the only rows of interest are those where the
        inner expression <em class="replaceable"><code>inner_expr</code></em> is equal
        to <em class="replaceable"><code>outer_expr</code></em>. This is done by
        pushing down an appropriate equality into the subquery's
        <code class="literal">WHERE</code> clause. That is, the comparison is
        converted to this:
      </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
        After the conversion, MySQL can use the pushed-down equality to
        limit the number of rows that it must examine when evaluating
        the subquery.
      </p><p>
        More generally, a comparison of <em class="replaceable"><code>N</code></em>
        values to a subquery that returns
        <em class="replaceable"><code>N</code></em>-value rows is subject to the same
        conversion. If <em class="replaceable"><code>oe_i</code></em> and
        <em class="replaceable"><code>ie_i</code></em> represent corresponding outer
        and inner expression values, this subquery comparison:
      </p><pre class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN
  (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
        Becomes:
      </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND <em class="replaceable"><code>oe_1</code></em> = <em class="replaceable"><code>ie_1</code></em>
                          AND ...
                          AND <em class="replaceable"><code>oe_N</code></em> = <em class="replaceable"><code>ie_N</code></em>)
</pre><p>
        The following discussion assumes a single pair of outer and
        inner expression values for simplicity.
      </p><p>
        The conversion just described has its limitations. It is valid
        only if we ignore possible <code class="literal">NULL</code> values. That
        is, the “<span class="quote">pushdown</span>” strategy works as long as both
        of these two conditions are true:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <em class="replaceable"><code>outer_expr</code></em> and
            <em class="replaceable"><code>inner_expr</code></em> cannot be
            <code class="literal">NULL</code>.
          </p></li><li><p>
            You do not need to distinguish <code class="literal">NULL</code> from
            <code class="literal">FALSE</code> subquery results. (If the subquery
            is a part of an <a href="functions.html#operator_or"><code class="literal">OR</code></a> or
            <a href="functions.html#operator_and"><code class="literal">AND</code></a> expression in the
            <code class="literal">WHERE</code> clause, MySQL assumes that you
            don't care.)
          </p></li></ul></div><p>
        When either or both of those conditions do not hold,
        optimization is more complex.
      </p><p>
        Suppose that <em class="replaceable"><code>outer_expr</code></em> is known to
        be a non-<code class="literal">NULL</code> value but the subquery does not
        produce a row such that <em class="replaceable"><code>outer_expr</code></em> =
        <em class="replaceable"><code>inner_expr</code></em>. Then
        <code class="literal"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT
        ...)</code> evaluates as follows:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">NULL</code>, if the <code class="literal">SELECT</code>
            produces any row where <em class="replaceable"><code>inner_expr</code></em>
            is <code class="literal">NULL</code>
          </p></li><li><p>
            <code class="literal">FALSE</code>, if the <code class="literal">SELECT</code>
            produces only non-<code class="literal">NULL</code> values or produces
            nothing
          </p></li></ul></div><p>
        In this situation, the approach of looking for rows with
        <code class="literal"><em class="replaceable"><code>outer_expr</code></em> =
        <em class="replaceable"><code>inner_expr</code></em></code> is no longer
        valid. It is necessary to look for such rows, but if none are
        found, also look for rows where
        <em class="replaceable"><code>inner_expr</code></em> is
        <code class="literal">NULL</code>. Roughly speaking, the subquery can be
        converted to:
      </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND
        (<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em> OR <em class="replaceable"><code>inner_expr</code></em> IS NULL))
</pre><p>
        The need to evaluate the extra <a href="functions.html#operator_is-null"><code class="literal">IS
        NULL</code></a> condition is why MySQL has the
        <code class="literal">ref_or_null</code> access method:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN</code></strong>
    -&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>outer_expr</code></em> IN (SELECT t2.maybe_null_key</code></strong>
    -&gt;                       <strong class="userinput"><code>FROM t2, t3 WHERE ...)</code></strong>
    -&gt; FROM t1;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: ref_or_null
possible_keys: maybe_null_key
          key: maybe_null_key
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Using index
...
</pre><p>
        The <code class="literal">unique_subquery</code> and
        <code class="literal">index_subquery</code> subquery-specific access
        methods also have or-null variants. However, they are not
        visible in <code class="literal">EXPLAIN</code> output, so you must use
        <code class="literal">EXPLAIN EXTENDED</code> followed by <code class="literal">SHOW
        WARNINGS</code> (note the <code class="literal">checking NULL</code> in
        the warning message):
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN EXTENDED</code></strong>
    -&gt; <strong class="userinput"><code>SELECT <em class="replaceable"><code>outer_expr</code></em> IN (SELECT maybe_null_key FROM t2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: index_subquery
possible_keys: maybe_null_key
          key: maybe_null_key
      key_len: 5
          ref: func
         rows: 2
        Extra: Using index

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: select (`test`.`t1`.`outer_expr`,
         (((`test`.`t1`.`outer_expr`) in t2 on
         maybe_null_key checking NULL))) AS `outer_expr IN (SELECT
         maybe_null_key FROM t2)` from `test`.`t1`
</pre><p>
        The additional <code class="literal">OR ... IS NULL</code> condition makes
        query execution slightly more complicated (and some
        optimizations within the subquery become inapplicable), but
        generally this is tolerable.
      </p><p>
        The situation is much worse when
        <em class="replaceable"><code>outer_expr</code></em> can be
        <code class="literal">NULL</code>. According to the SQL interpretation of
        <code class="literal">NULL</code> as “<span class="quote">unknown value,</span>”
        <code class="literal">NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em>
        ...)</code> should evaluate to:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">NULL</code>, if the <code class="literal">SELECT</code>
            produces any rows
          </p></li><li><p>
            <code class="literal">FALSE</code>, if the <code class="literal">SELECT</code>
            produces no rows
          </p></li></ul></div><p>
        For proper evaluation, it is necessary to be able to check
        whether the <code class="literal">SELECT</code> has produced any rows at
        all, so <code class="literal"><em class="replaceable"><code>outer_expr</code></em> =
        <em class="replaceable"><code>inner_expr</code></em></code> cannot be pushed
        down into the subquery. This is a problem, because many real
        world subqueries become very slow unless the equality can be
        pushed down.
      </p><p>
        Essentially, there must be different ways to execute the
        subquery depending on the value of
        <em class="replaceable"><code>outer_expr</code></em>. In MySQL 5.1
        before 5.1.16, the optimizer chose speed over distinguishing a
        <code class="literal">NULL</code> from <code class="literal">FALSE</code> result, so
        for some queries, you might get a <code class="literal">FALSE</code>
        result rather than <code class="literal">NULL</code>.
      </p><p>
        As of MySQL 5.1.16, the optimizer chooses SQL compliance over
        speed, so it accounts for the possibility that
        <em class="replaceable"><code>outer_expr</code></em> might be
        <code class="literal">NULL</code>.
      </p><p>
        If <em class="replaceable"><code>outer_expr</code></em> is
        <code class="literal">NULL</code>, to evaluate the following expression,
        it is necessary to run the <code class="literal">SELECT</code> to
        determine whether it produces any rows:
      </p><pre class="programlisting">NULL IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
        It is necessary to run the original <code class="literal">SELECT</code>
        here, without any pushed-down equalities of the kind mentioned
        earlier.
      </p><p>
        On the other hand, when <em class="replaceable"><code>outer_expr</code></em> is
        not <code class="literal">NULL</code>, it is absolutely essential that
        this comparison:
      </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
        be converted to this expression that uses a pushed-down
        condition:
      </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em> AND <em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>)
</pre><p>
        Without this conversion, subqueries will be slow. To solve the
        dilemma of whether to push down or not push down conditions into
        the subquery, the conditions are wrapped in
        “<span class="quote">trigger</span>” functions. Thus, an expression of the
        following form:
      </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
        is converted into:
      </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>outer_expr</code></em>=<em class="replaceable"><code>inner_expr</code></em>))
</pre><p>
        More generally, if the subquery comparison is based on several
        pairs of outer and inner expressions, the conversion takes this
        comparison:
      </p><pre class="programlisting">(<em class="replaceable"><code>oe_1</code></em>, ..., <em class="replaceable"><code>oe_N</code></em>) IN (SELECT <em class="replaceable"><code>ie_1</code></em>, ..., <em class="replaceable"><code>ie_N</code></em> FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>)
</pre><p>
        and converts it to this expression:
      </p><pre class="programlisting">EXISTS (SELECT 1 FROM ... WHERE <em class="replaceable"><code>subquery_where</code></em>
                          AND trigcond(<em class="replaceable"><code>oe_1</code></em>=<em class="replaceable"><code>ie_1</code></em>)
                          AND ...
                          AND trigcond(<em class="replaceable"><code>oe_N</code></em>=<em class="replaceable"><code>ie_N</code></em>)
       )
</pre><p>
        Each <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code>
        is a special function that evaluates to the following values:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <em class="replaceable"><code>X</code></em> when the “<span class="quote">linked</span>”
            outer expression <em class="replaceable"><code>oe_i</code></em> is not
            <code class="literal">NULL</code>
          </p></li><li><p>
            <code class="literal">TRUE</code> when the “<span class="quote">linked</span>” outer
            expression <em class="replaceable"><code>oe_i</code></em> is
            <code class="literal">NULL</code>
          </p></li></ul></div><p>
        Note that trigger functions are <span class="emphasis"><em>not</em></span>
        triggers of the kind that you create with <code class="literal">CREATE
        TRIGGER</code>.
      </p><p>
        Equalities that are wrapped into <code class="literal">trigcond()</code>
        functions are not first class predicates for the query
        optimizer. Most optimizations cannot deal with predicates that
        may be turned on and off at query execution time, so they assume
        any <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>)</code> to
        be an unknown function and ignore it. At the moment, triggered
        equalities can be used by those optimizations:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Reference optimizations:
            <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em>
            [OR <em class="replaceable"><code>Y</code></em> IS NULL])</code> can be
            used to construct <code class="literal">ref</code>,
            <code class="literal">eq_ref</code>, or <code class="literal">ref_or_null</code>
            table accesses.
          </p></li><li><p>
            Index lookup-based subquery execution engines:
            <code class="literal">trigcond(<em class="replaceable"><code>X</code></em>=<em class="replaceable"><code>Y</code></em>)</code>
            can be used to construct <code class="literal">unique_subquery</code>
            or <code class="literal">index_subquery</code> accesses.
          </p></li><li><p>
            Table-condition generator: If the subquery is a join of
            several tables, the triggered condition will be checked as
            soon as possible.
          </p></li></ul></div><p>
        When the optimizer uses a triggered condition to create some
        kind of index lookup-based access (as for the first two items of
        the preceding list), it must have a fallback strategy for the
        case when the condition is turned off. This fallback strategy is
        always the same: Do a full table scan. In
        <code class="literal">EXPLAIN</code> output, the fallback shows up as
        <code class="literal">Full scan on NULL key</code> in the
        <code class="literal">Extra</code> column:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT t1.col1,</code></strong>
    -&gt; <strong class="userinput"><code>t1.col1 IN (SELECT t2.key1 FROM t2 WHERE t2.col2=t1.col2) FROM t1\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: t1
        ...
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: t2
         type: index_subquery
possible_keys: key1
          key: key1
      key_len: 5
          ref: func
         rows: 2
        Extra: Using where; Full scan on NULL key
</pre><p>
        If you run <code class="literal">EXPLAIN EXTENDED</code> followed by
        <code class="literal">SHOW WARNINGS</code>, you can see the triggered
        condition:
      </p><pre class="programlisting">*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: select `test`.`t1`.`col1` AS `col1`,
         &lt;in_optimizer&gt;(`test`.`t1`.`col1`,
         &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`test`.`t1`.`col1`) in t2
         on key1 checking NULL
         where (`test`.`t2`.`col2` = `test`.`t1`.`col2`) having
         trigcond(&lt;is_not_null_test&gt;(`test`.`t2`.`key1`))))) AS
         `t1.col1 IN (select t2.key1 from t2 where t2.col2=t1.col2)`
         from `test`.`t1`
</pre><p>
        The use of triggered conditions has some performance
        implications. A <code class="literal">NULL IN (SELECT ...)</code>
        expression now may cause a full table scan (which is slow) when
        it previously did not. This is the price paid for correct
        results (the goal of the trigger-condition strategy was to
        improve compliance and not speed).
      </p><p>
        For multiple-table subqueries, execution of <code class="literal">NULL IN
        (SELECT ...)</code> will be particularly slow because the
        join optimizer doesn't optimize for the case where the outer
        expression is <code class="literal">NULL</code>. It assumes that subquery
        evaluations with <code class="literal">NULL</code> on the left side are
        very rare, even if there are statistics that indicate otherwise.
        On the other hand, if the outer expression might be
        <code class="literal">NULL</code> but never actually is, there is no
        performance penalty.
      </p><p>
        To help the query optimizer better execute your queries, use
        these tips:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            A column must be declared as <code class="literal">NOT NULL</code> if
            it really is. (This also helps other aspects of the
            optimizer.)
          </p></li><li><p>
            If you don't need to distinguish a <code class="literal">NULL</code>
            from <code class="literal">FALSE</code> subquery result, you can
            easily avoid the slow execution path. Replace a comparison
            that looks like this:
          </p><pre class="programlisting"><em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...)
</pre><p>
            with this expression:
          </p><pre class="programlisting">(<em class="replaceable"><code>outer_expr</code></em> IS NOT NULL) AND (<em class="replaceable"><code>outer_expr</code></em> IN (SELECT <em class="replaceable"><code>inner_expr</code></em> FROM ...))
</pre><p>
            Then <code class="literal">NULL IN (SELECT ...)</code> will never be
            evaluated because MySQL stops evaluating
            <a href="functions.html#operator_and"><code class="literal">AND</code></a> parts as soon as the
            expression result is clear.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="limit-optimization"></a>7.2.16. <code class="literal">LIMIT</code> Optimization</h3></div></div></div><a class="indexterm" name="id2062000"></a><a class="indexterm" name="id2062009"></a><p>
        In some cases, MySQL handles a query differently when you are
        using <code class="literal">LIMIT
        <em class="replaceable"><code>row_count</code></em></code> and not using
        <code class="literal">HAVING</code>:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If you are selecting only a few rows with
            <code class="literal">LIMIT</code>, MySQL uses indexes in some cases
            when normally it would prefer to do a full table scan.
          </p></li><li><p>
            If you use <code class="literal">LIMIT
            <em class="replaceable"><code>row_count</code></em></code> with
            <code class="literal">ORDER BY</code>, MySQL ends the sorting as soon
            as it has found the first
            <em class="replaceable"><code>row_count</code></em> rows of the sorted
            result, rather than sorting the entire result. If ordering
            is done by using an index, this is very fast. If a filesort
            must be done, all rows that match the query without the
            <code class="literal">LIMIT</code> clause must be selected, and most
            or all of them must be sorted, before it can be ascertained
            that the first <em class="replaceable"><code>row_count</code></em> rows
            have been found. In either case, after the initial rows have
            been found, there is no need to sort any remainder of the
            result set, and MySQL does not do so.
          </p></li><li><p>
            When combining <code class="literal">LIMIT
            <em class="replaceable"><code>row_count</code></em></code> with
            <code class="literal">DISTINCT</code>, MySQL stops as soon as it finds
            <em class="replaceable"><code>row_count</code></em> unique rows.
          </p></li><li><p>
            In some cases, a <code class="literal">GROUP BY</code> can be resolved
            by reading the key in order (or doing a sort on the key) and
            then calculating summaries until the key value changes. In
            this case, <code class="literal">LIMIT
            <em class="replaceable"><code>row_count</code></em></code> does not
            calculate any unnecessary <code class="literal">GROUP BY</code>
            values.
          </p></li><li><p>
            As soon as MySQL has sent the required number of rows to the
            client, it aborts the query unless you are using
            <code class="literal">SQL_CALC_FOUND_ROWS</code>.
          </p></li><li><p>
            <code class="literal">LIMIT 0</code> quickly returns an empty set.
            This can be useful for checking the validity of a query.
            When using one of the MySQL APIs, it can also be employed
            for obtaining the types of the result columns. (This trick
            does not work in the MySQL Monitor (the
            <span><strong class="command">mysql</strong></span> program), which merely displays
            <code class="literal">Empty set</code> in such cases; you should
            instead use <code class="literal">SHOW COLUMNS</code> or
            <code class="literal">DESCRIBE</code> for this purpose.)
          </p></li><li><p>
            When the server uses temporary tables to resolve the query,
            it uses the <code class="literal">LIMIT
            <em class="replaceable"><code>row_count</code></em></code> clause to
            calculate how much space is required.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="how-to-avoid-table-scan"></a>7.2.17. How to Avoid Table Scans</h3></div></div></div><a class="indexterm" name="id2062230"></a><p>
        The output from <code class="literal">EXPLAIN</code> shows
        <code class="literal">ALL</code> in the <code class="literal">type</code> column
        when MySQL uses a table scan to resolve a query. This usually
        happens under the following conditions:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            The table is so small that it is faster to perform a table
            scan than to bother with a key lookup. This is common for
            tables with fewer than 10 rows and a short row length.
          </p></li><li><p>
            There are no usable restrictions in the
            <code class="literal">ON</code> or <code class="literal">WHERE</code> clause for
            indexed columns.
          </p></li><li><p>
            You are comparing indexed columns with constant values and
            MySQL has calculated (based on the index tree) that the
            constants cover too large a part of the table and that a
            table scan would be faster. See
            <a href="optimization.html#where-optimizations" title="7.2.4. WHERE Clause Optimization">Section 7.2.4, “<code class="literal">WHERE</code> Clause Optimization”</a>.
          </p></li><li><p>
            You are using a key with low cardinality (many rows match
            the key value) through another column. In this case, MySQL
            assumes that by using the key it probably will do many key
            lookups and that a table scan would be faster.
          </p></li></ul></div><p class="mnmas"><b>MySQL Enterprise</b>
          For expert advice on avoiding excessive table scans subscribe
          to the MySQL Enterprise Monitor. For more information, see
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p><p>
        For small tables, a table scan often is appropriate and the
        performance impact is negligible. For large tables, try the
        following techniques to avoid having the optimizer incorrectly
        choose a table scan:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Use <code class="literal">ANALYZE TABLE
            <em class="replaceable"><code>tbl_name</code></em></code> to update the
            key distributions for the scanned table. See
            <a href="sql-syntax.html#analyze-table" title="12.5.2.1. ANALYZE TABLE Syntax">Section 12.5.2.1, “<code class="literal">ANALYZE TABLE</code> Syntax”</a>.
          </p></li><li><p>
            Use <code class="literal">FORCE INDEX</code> for the scanned table to
            tell MySQL that table scans are very expensive compared to
            using the given index:
          </p><pre class="programlisting">SELECT * FROM t1, t2 FORCE INDEX (<em class="replaceable"><code>index_for_column</code></em>)
  WHERE t1.<em class="replaceable"><code>col_name</code></em>=t2.<em class="replaceable"><code>col_name</code></em>;
</pre><p>
            See <a href="sql-syntax.html#index-hints" title="12.2.7.2. Index Hint Syntax">Section 12.2.7.2, “Index Hint Syntax”</a>.
          </p></li><li><p>
            Start <span><strong class="command">mysqld</strong></span> with the
            <code class="option">--max-seeks-for-key=1000</code> option or use
            <code class="literal">SET max_seeks_for_key=1000</code> to tell the
            optimizer to assume that no key scan causes more than 1,000
            key seeks. See <a href="server-administration.html#server-system-variables" title="5.1.3. System Variables">Section 5.1.3, “System Variables”</a>.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="information-schema-optimization"></a>7.2.18. <code class="literal">INFORMATION_SCHEMA</code> Optimization</h3></div></div></div><p>
        In MySQL 5.1.23, changes to the implementation of
        <code class="literal">INFORMATION_SCHEMA</code> were made that optimize
        certain types of queries for
        <code class="literal">INFORMATION_SCHEMA</code> tables so that they
        execute more quickly. This section provides guidelines on
        writing queries that take advantage of these optimizations. In
        general, the strategies outlined here minimize the need for the
        server to access the filesystem to obtain the information that
        makes up the contents of <code class="literal">INFORMATION_SCHEMA</code>
        tables. By writing queries that enable the server to avoid
        directory scans or opening table files, you will obtain better
        performance.
      </p><p>
        <span class="bold"><strong>1) Try to use constant lookup values for
        database and table names in the <code class="literal">WHERE</code>
        clause</strong></span>
      </p><p>
        You can take advantage of this principle as follows:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            To look up databases or tables, use expressions that
            evaluate to a constant, such as literal values, functions
            that return a constant, or scalar subqueries.
          </p></li><li><p>
            Avoid queries that use a non-constant database name lookup
            value (or no lookup value) because they require a scan of
            the data directory to find matching database directory
            names.
          </p></li><li><p>
            Within a database, avoid queries that use a non-constant
            table name lookup value (or no lookup value) because they
            require a scan of the database directory to find matching
            table files.
          </p></li></ul></div><p>
        This principle applies to the
        <code class="literal">INFORMATION_SCHEMA</code> tables shown in the
        following table, which shows the columns for which a constant
        lookup value enables the server to avoid a directory scan. For
        example, if you are selecting from <code class="literal">TABLES</code>,
        using a constant lookup value for
        <code class="literal">TABLE_SCHEMA</code> in the <code class="literal">WHERE</code>
        clause enables a data directory scan to be avoided.
      </p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Table</strong></span></td><td><span class="bold"><strong>Column to specify to avoid data directory
                scan</strong></span></td><td><span class="bold"><strong>Column to specify to avoid database directory
                scan</strong></span></td></tr><tr><td><code class="literal">COLUMNS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td><code class="literal">KEY_COLUMN_USAGE</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td><code class="literal">PARTITIONS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td><code class="literal">REFERENTIAL_CONSTRAINTS</code></td><td><code class="literal">CONSTRAINT_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td><code class="literal">STATISTICS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td><code class="literal">TABLES</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td><code class="literal">TABLE_CONSTRAINTS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr><tr><td><code class="literal">TRIGGERS</code></td><td><code class="literal">EVENT_OBJECT_SCHEMA</code></td><td><code class="literal">EVENT_OBJECT_TABLE</code></td></tr><tr><td><code class="literal">VIEWS</code></td><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">TABLE_NAME</code></td></tr></tbody></table></div><p>
        The benefit of a query that is limited to a specific constant
        database name is that checks need be made only for the named
        database directory. Example:
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test';
</pre><p>
        Use of the literal database name <code class="literal">test</code> enables
        the server to check only the <code class="literal">test</code> database
        directory, regardless of how many databases there might be. By
        contrast, the following query is less efficient because it
        requires a scan of the data directory to determine which
        database names match the pattern <code class="literal">'test%'</code>:
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA LIKE 'test%';
</pre><p>
        For a query that is limited to a specific constant table name,
        checks need be made only for the named table within the
        corresponding database directory. Example:
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME = 't1';
</pre><p>
        Use of the literal table name <code class="literal">t1</code> enables the
        server to check only the files for the <code class="literal">t1</code>
        table, regardless of how many tables there might be in the
        <code class="literal">test</code> database. By contrast, the following
        query requires a scan of the <code class="literal">test</code> database
        directory to determine which table names match the pattern
        <code class="literal">'t%'</code>:
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME LIKE 't%';
</pre><p>
        The following query requires a scan of the database directory to
        determine matching database names for the pattern
        <code class="literal">'test%'</code>, and for each matching database, it
        requires a scan of the database directory to determine matching
        table names for the pattern <code class="literal">'t%'</code>:
      </p><pre class="programlisting">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test%' AND TABLE_NAME LIKE 't%';
</pre><p>
        <span class="bold"><strong>2) Write queries that minimize the number
        of table files that must be opened</strong></span>
      </p><p>
        For queries that refer to certain
        <code class="literal">INFORMATION_SCHEMA</code> table columns, several
        optimizations are available that minimize the number of table
        files that must be opened. Example:
      </p><pre class="programlisting">SELECT TABLE_NAME, ENGINE FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'test';
</pre><p>
        In this case, after the server has scanned the database
        directory to determine the names of the tables in the database,
        those names become available with no further filesystem lookups.
        Thus, <code class="literal">TABLE_NAME</code> requires no files to be
        opened. The <code class="literal">ENGINE</code> (storage engine) value can
        be determined by opening the table's <code class="filename">.frm</code>
        file, without touching other table files such as the
        <code class="filename">.MYD</code> or <code class="filename">.MYI</code> file.
      </p><p>
        Some values, such as <code class="literal">INDEX_LENGTH</code> for
        <code class="literal">MyISAM</code> tables, require opening the
        <code class="filename">.MYD</code> or <code class="filename">.MYI</code> file as
        well.
      </p><p>
        The file-opening optimization types are denoted thus:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">SKIP_OPEN_TABLE</code>: Table files do not need
            to be opened. The information has already become available
            within the query by scanning the database directory.
          </p></li><li><p>
            <code class="literal">OPEN_FRM_ONLY</code>: Only the table's
            <code class="filename">.frm</code> file need be opened.
          </p></li><li><p>
            <code class="literal">OPEN_TRIGGER_ONLY</code>: Only the table's
            <code class="filename">.TRG</code> file need be opened.
          </p></li><li><p>
            <code class="literal">OPEN_FULL_TABLE</code>: The unoptimized
            information lookup. The <code class="filename">.frm</code>,
            <code class="filename">.MYD</code>, and <code class="filename">.MYI</code>
            files must be opened.
          </p></li></ul></div><p>
        The following list indicates how the preceding optimization
        types apply to <code class="literal">INFORMATION_SCHEMA</code> table
        columns. For tables and columns not named, none of the
        optimizations apply.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">COLUMNS</code>: <code class="literal">OPEN_FRM_ONLY</code>
            applies to all columns
          </p></li><li><p>
            <code class="literal">KEY_COLUMN_USAGE</code>:
            <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
          </p></li><li><p>
            <code class="literal">PARTITIONS</code>:
            <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
          </p></li><li><p>
            <code class="literal">REFERENTIAL_CONSTRAINTS</code>:
            <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
          </p></li><li><p>
            <code class="literal">STATISTICS</code>:
          </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Column</strong></span></td><td><span class="bold"><strong>Optimization type</strong></span></td></tr><tr><td><code class="literal">TABLE_CATALOG</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">TABLE_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">NON_UNIQUE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">INDEX_SCHEMA</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">INDEX_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">SEQ_IN_INDEX</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">COLUMN_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">COLLATION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">CARDINALITY</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">SUB_PART</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">PACKED</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">NULLABLE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">INDEX_TYPE</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">COMMENT</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr></tbody></table></div></li><li><p>
            <code class="literal">TABLES</code>:
          </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Column</strong></span></td><td><span class="bold"><strong>Optimization type</strong></span></td></tr><tr><td><code class="literal">TABLE_CATALOG</code></td><td><code class="literal">SKIP_OPEN_TABLE</code></td></tr><tr><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">SKIP_OPEN_TABLE</code></td></tr><tr><td><code class="literal">TABLE_NAME</code></td><td><code class="literal">SKIP_OPEN_TABLE</code></td></tr><tr><td><code class="literal">TABLE_TYPE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">ENGINE</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">VERSION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">ROW_FORMAT</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">TABLE_ROWS</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">AVG_ROW_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">DATA_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">MAX_DATA_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">INDEX_LENGTH</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">DATA_FREE</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">AUTO_INCREMENT</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">CREATE_TIME</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">UPDATE_TIME</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">CHECK_TIME</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">TABLE_COLLATION</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">CHECKSUM</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">CREATE_OPTIONS</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">TABLE_COMMENT</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr></tbody></table></div></li><li><p>
            <code class="literal">TABLE_CONSTRAINTS</code>:
            <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
          </p></li><li><p>
            <code class="literal">TRIGGERS</code>:
            <code class="literal">OPEN_FULL_TABLE</code> applies to all columns
          </p></li><li><p>
            <code class="literal">VIEWS</code>:
          </p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td><span class="bold"><strong>Column</strong></span></td><td><span class="bold"><strong>Optimization type</strong></span></td></tr><tr><td><code class="literal">TABLE_CATALOG</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">TABLE_SCHEMA</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">TABLE_NAME</code></td><td><code class="literal">OPEN_FRM_ONLY</code></td></tr><tr><td><code class="literal">VIEW_DEFINITION</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">CHECK_OPTION</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">IS_UPDATABLE</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">DEFINER</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">SECURITY_TYPE</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">CHARACTER_SET_CLIENT</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr><tr><td><code class="literal">COLLATION_CONNECTION</code></td><td><code class="literal">OPEN_FULL_TABLE</code></td></tr></tbody></table></div></li></ul></div><p>
        <span class="bold"><strong>3) Use <code class="literal">EXPLAIN</code> to
        determine whether the server can use
        <code class="literal">INFORMATION_SCHEMA</code> optimizations for a
        query</strong></span>
      </p><p>
        The <code class="literal">Extra</code> value in <code class="literal">EXPLAIN</code>
        output indicates which, if any, of the optimizations described
        earlier the server can use to evaluate
        <code class="literal">INFORMATION_SCHEMA</code> queries. The following
        examples demonstrate the kinds of information you can expect to
        see in the <code class="literal">Extra</code> value.
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME FROM INFORMATION_SCHEMA.VIEWS WHERE</code></strong>
    -&gt; <strong class="userinput"><code>TABLE_SCHEMA = 'test' AND TABLE_NAME = 'v1'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: VIEWS
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA,TABLE_NAME
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned 0 databases
</pre><p>
        Use of constant database and table lookup values enables the
        server to avoid directory scans. For references to
        <code class="literal">VIEWS.TABLE_NAME</code>, only the
        <code class="filename">.frm</code> file need be opened.
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.TABLES\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: TABLES
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Open_full_table; Scanned all databases
</pre><p>
        No lookup values are provided (there is no
        <code class="literal">WHERE</code> clause), so the server must scan the
        data directory and each database directory. For each table thus
        identified, the table name and row format are selected.
        <code class="literal">TABLE_NAME</code> requires no further table files to
        be opened (the <code class="literal">SKIP_OPEN_TABLE</code> optimization
        applies). <code class="literal">ROW_FORMAT</code> requires all table files
        to be opened (<code class="literal">OPEN_FULL_TABLE</code> applies).
        <code class="literal">EXPLAIN</code> reports
        <code class="literal">OPEN_FULL_TABLE</code> because it is more expensive
        than <code class="literal">SKIP_OPEN_TABLE</code>.
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT TABLE_NAME, TABLE_TYPE FROM INFORMATION_SCHEMA.TABLES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'test'\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: TABLES
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned 1 database
</pre><p>
        No table name lookup value is provided, so the server must scan
        the <code class="literal">test</code> database directory. For the
        <code class="literal">TABLE_NAME</code> and <code class="literal">TABLE_TYPE</code>
        columns, the <code class="literal">SKIP_OPEN_TABLE</code> and
        <code class="literal">OPEN_FRM_ONLY</code> optimizations apply,
        respectively. <code class="literal">EXPLAIN</code> reports
        <code class="literal">OPEN_FRM_ONLY</code> because it is more expensive.
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT B.TABLE_NAME</code></strong>
    -&gt; <strong class="userinput"><code>FROM INFORMATION_SCHEMA.TABLES AS A, INFORMATION_SCHEMA.COLUMNS AS B</code></strong>
    -&gt; <strong class="userinput"><code>WHERE A.TABLE_SCHEMA = 'test'</code></strong>
    -&gt; <strong class="userinput"><code>AND A.TABLE_NAME = 't1'</code></strong>
    -&gt; <strong class="userinput"><code>AND B.TABLE_NAME = A.TABLE_NAME\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: A
         type: ALL
possible_keys: NULL
          key: TABLE_SCHEMA,TABLE_NAME
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Skip_open_table; Scanned 0 databases
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: B
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: Using where; Open_frm_only; Scanned all databases;
               Using join buffer
</pre><p>
        For the first <code class="literal">EXPLAIN</code> output row: Constant
        database and table lookup values enable the server to avoid
        directory scans for <code class="literal">TABLES</code> values. References
        to <code class="literal">TABLES.TABLE_NAME</code> require no further table
        files.
      </p><p>
        For the second <code class="literal">EXPLAIN</code> output row: All
        <code class="literal">COLUMNS</code> table values are
        <code class="literal">OPEN_FRM_ONLY</code> lookups, so
        <code class="literal">COLUMNS.TABLE_NAME</code> requires the
        <code class="filename">.frm</code> file to be opened.
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>EXPLAIN SELECT * FROM INFORMATION_SCHEMA.COLLATIONS\G</code></strong>
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: COLLATIONS
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
        Extra: 
</pre><p>
        In this case, no optimizations apply because
        <code class="literal">COLLATIONS</code> is not one of the
        <code class="literal">INFORMATION_SCHEMA</code> tables for which
        optimizations are available.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="insert-speed"></a>7.2.19. Speed of <code class="literal">INSERT</code> Statements</h3></div></div></div><a class="indexterm" name="id2064524"></a><a class="indexterm" name="id2064533"></a><a class="indexterm" name="id2064546"></a><p>
        The time required for inserting a row is determined by the
        following factors, where the numbers indicate approximate
        proportions:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Connecting: (3)
          </p></li><li><p>
            Sending query to server: (2)
          </p></li><li><p>
            Parsing query: (2)
          </p></li><li><p>
            Inserting row: (1 × size of row)
          </p></li><li><p>
            Inserting indexes: (1 × number of indexes)
          </p></li><li><p>
            Closing: (1)
          </p></li></ul></div><p>
        This does not take into consideration the initial overhead to
        open tables, which is done once for each concurrently running
        query.
      </p><p>
        The size of the table slows down the insertion of indexes by log
        <em class="replaceable"><code>N</code></em>, assuming B-tree indexes.
      </p><p>
        You can use the following methods to speed up inserts:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If you are inserting many rows from the same client at the
            same time, use <code class="literal">INSERT</code> statements with
            multiple <code class="literal">VALUES</code> lists to insert several
            rows at a time. This is considerably faster (many times
            faster in some cases) than using separate single-row
            <code class="literal">INSERT</code> statements. If you are adding data
            to a non-empty table, you can tune the
            <code class="literal">bulk_insert_buffer_size</code> variable to make
            data insertion even faster. See
            <a href="server-administration.html#server-system-variables" title="5.1.3. System Variables">Section 5.1.3, “System Variables”</a>.
          </p></li><li><p>
            If multiple clients are inserting a lot of rows, you can get
            higher speed by using the <code class="literal">INSERT DELAYED</code>
            statement. See <a href="sql-syntax.html#insert-delayed" title="12.2.4.2. INSERT DELAYED Syntax">Section 12.2.4.2, “<code class="literal">INSERT DELAYED</code> Syntax”</a>.
          </p></li><li><p>
            For a <code class="literal">MyISAM</code> table, you can use
            concurrent inserts to add rows at the same time that
            <code class="literal">SELECT</code> statements are running, if there
            are no deleted rows in middle of the data file. See
            <a href="optimization.html#concurrent-inserts" title="7.3.3. Concurrent Inserts">Section 7.3.3, “Concurrent Inserts”</a>.
          </p></li><li><p>
            When loading a table from a text file, use <code class="literal">LOAD
            DATA INFILE</code>. This is usually 20 times faster than
            using <code class="literal">INSERT</code> statements. See
            <a href="sql-syntax.html#load-data" title="12.2.5. LOAD DATA INFILE Syntax">Section 12.2.5, “<code class="literal">LOAD DATA INFILE</code> Syntax”</a>.
          </p></li><li><p>
            With some extra work, it is possible to make <code class="literal">LOAD
            DATA INFILE</code> run even faster for a
            <code class="literal">MyISAM</code> table when the table has many
            indexes. Use the following procedure:
          </p><div class="orderedlist"><ol type="1"><li><p>
                Optionally create the table with <code class="literal">CREATE
                TABLE</code>.
              </p></li><li><p>
                Execute a <code class="literal">FLUSH TABLES</code> statement or a
                <span><strong class="command">mysqladmin flush-tables</strong></span> command.
              </p></li><li><p>
                Use <span><strong class="command">myisamchk --keys-used=0 -rq
                <em class="replaceable"><code>/path/to/db/tbl_name</code></em>.</strong></span>
                This removes all use of indexes for the table.
              </p></li><li><p>
                Insert data into the table with <code class="literal">LOAD DATA
                INFILE</code>. This does not update any indexes and
                therefore is very fast.
              </p></li><li><p>
                If you intend only to read from the table in the future,
                use <span><strong class="command">myisampack</strong></span> to compress it. See
                <a href="storage-engines.html#compressed-format" title="13.4.3.3. Compressed Table Characteristics">Section 13.4.3.3, “Compressed Table Characteristics”</a>.
              </p></li><li><p>
                Re-create the indexes with <span><strong class="command">myisamchk -rq
                <em class="replaceable"><code>/path/to/db/tbl_name</code></em></strong></span>.
                This creates the index tree in memory before writing it
                to disk, which is much faster that updating the index
                during <code class="literal">LOAD DATA INFILE</code> because it
                avoids lots of disk seeks. The resulting index tree is
                also perfectly balanced.
              </p></li><li><p>
                Execute a <code class="literal">FLUSH TABLES</code> statement or a
                <span><strong class="command">mysqladmin flush-tables</strong></span> command.
              </p></li></ol></div><p>
            <code class="literal">LOAD DATA INFILE</code> performs the preceding
            optimization automatically if the <code class="literal">MyISAM</code>
            table into which you insert data is empty. The main
            difference between automatic optimization and using the
            procedure explicitly is that you can let
            <span><strong class="command">myisamchk</strong></span> allocate much more temporary
            memory for the index creation than you might want the server
            to allocate for index re-creation when it executes the
            <code class="literal">LOAD DATA INFILE</code> statement.
          </p><p>
            You can also disable or enable the non-unique indexes for a
            <code class="literal">MyISAM</code> table by using the following
            statements rather than <span><strong class="command">myisamchk</strong></span>. If you
            use these statements, you can skip the <code class="literal">FLUSH
            TABLE</code> operations:
          </p><pre class="programlisting">ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> DISABLE KEYS;
ALTER TABLE <em class="replaceable"><code>tbl_name</code></em> ENABLE KEYS;
</pre></li><li><p>
            To speed up <code class="literal">INSERT</code> operations that are
            performed with multiple statements for non-transactional
            tables, lock your tables:
          </p><pre class="programlisting">LOCK TABLES a WRITE;
INSERT INTO a VALUES (1,23),(2,34),(4,33);
INSERT INTO a VALUES (8,26),(6,29);
...
UNLOCK TABLES;
</pre><p>
            This benefits performance because the index buffer is
            flushed to disk only once, after all
            <code class="literal">INSERT</code> statements have completed.
            Normally, there would be as many index buffer flushes as
            there are <code class="literal">INSERT</code> statements. Explicit
            locking statements are not needed if you can insert all rows
            with a single <code class="literal">INSERT</code>.
          </p><p>
            To obtain faster insertions for transactional tables, you
            should use <code class="literal">START TRANSACTION</code> and
            <code class="literal">COMMIT</code> instead of <code class="literal">LOCK
            TABLES</code>.
          </p><p>
            Locking also lowers the total time for multiple-connection
            tests, although the maximum wait time for individual
            connections might go up because they wait for locks. Suppose
            that five clients attempt to perform inserts simultaneously
            as follows:
          </p><div class="itemizedlist"><ul type="circle"><li><p>
                Connection 1 does 1000 inserts
              </p></li><li><p>
                Connections 2, 3, and 4 do 1 insert
              </p></li><li><p>
                Connection 5 does 1000 inserts
              </p></li></ul></div><p>
            If you do not use locking, connections 2, 3, and 4 finish
            before 1 and 5. If you use locking, connections 2, 3, and 4
            probably do not finish before 1 or 5, but the total time
            should be about 40% faster.
          </p><p>
            <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, and
            <code class="literal">DELETE</code> operations are very fast in MySQL,
            but you can obtain better overall performance by adding
            locks around everything that does more than about five
            successive inserts or updates. If you do very many
            successive inserts, you could do a <code class="literal">LOCK
            TABLES</code> followed by an <code class="literal">UNLOCK
            TABLES</code> once in a while (each 1,000 rows or so) to
            allow other threads access to the table. This would still
            result in a nice performance gain.
          </p><p>
            <code class="literal">INSERT</code> is still much slower for loading
            data than <code class="literal">LOAD DATA INFILE</code>, even when
            using the strategies just outlined.
          </p></li><li><p>
            To increase performance for <code class="literal">MyISAM</code>
            tables, for both <code class="literal">LOAD DATA INFILE</code> and
            <code class="literal">INSERT</code>, enlarge the key cache by
            increasing the <code class="literal">key_buffer_size</code> system
            variable. See <a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">Section 7.5.2, “Tuning Server Parameters”</a>.
          </p></li></ul></div><p class="mnmas"><b>MySQL Enterprise</b>
          For more advice on optimizing the performance of your server,
          subscribe to the MySQL Enterprise Monitor. Numerous advisors
          are dedicated to monitoring performance. For more information,
          see <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="update-speed"></a>7.2.20. Speed of <code class="literal">UPDATE</code> Statements</h3></div></div></div><p>
        An update statement is optimized like a
        <code class="literal">SELECT</code> query with the additional overhead of
        a write. The speed of the write depends on the amount of data
        being updated and the number of indexes that are updated.
        Indexes that are not changed do not get updated.
      </p><p>
        Another way to get fast updates is to delay updates and then do
        many updates in a row later. Performing multiple updates
        together is much quicker than doing one at a time if you lock
        the table.
      </p><p>
        For a <code class="literal">MyISAM</code> table that uses dynamic row
        format, updating a row to a longer total length may split the
        row. If you do this often, it is very important to use
        <code class="literal">OPTIMIZE TABLE</code> occasionally. See
        <a href="sql-syntax.html#optimize-table" title="12.5.2.5. OPTIMIZE TABLE Syntax">Section 12.5.2.5, “<code class="literal">OPTIMIZE TABLE</code> Syntax”</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="delete-speed"></a>7.2.21. Speed of <code class="literal">DELETE</code> Statements</h3></div></div></div><p>
        The time required to delete individual rows is exactly
        proportional to the number of indexes. To delete rows more
        quickly, you can increase the size of the key cache by
        increasing the <code class="literal">key_buffer_size</code> system
        variable. See <a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">Section 7.5.2, “Tuning Server Parameters”</a>.
      </p><p>
        To delete all rows from a table, <code class="literal">TRUNCATE TABLE
        <em class="replaceable"><code>tbl_name</code></em></code> is faster than
        than <code class="literal">DELETE FROM Truncate operations are not
        transaction-safe; an error occurs when attempting one in the
        course of an active transaction or active table lock.
        <em class="replaceable"><code>tbl_name</code></em></code>. See
        <a href="sql-syntax.html#truncate" title="12.2.9. TRUNCATE Syntax">Section 12.2.9, “<code class="literal">TRUNCATE</code> Syntax”</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="miscellaneous-optimization-tips"></a>7.2.22. Other Optimization Tips</h3></div></div></div><a class="indexterm" name="id2065283"></a><a class="indexterm" name="id2065295"></a><p>
        This section lists a number of miscellaneous tips for improving
        query processing speed:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Use persistent connections to the database to avoid
            connection overhead. If you cannot use persistent
            connections and you are initiating many new connections to
            the database, you may want to change the value of the
            <code class="literal">thread_cache_size</code> variable. See
            <a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">Section 7.5.2, “Tuning Server Parameters”</a>.
          </p></li><li><p>
            Always check whether all your queries really use the indexes
            that you have created in the tables. In MySQL, you can do
            this with the <code class="literal">EXPLAIN</code> statement. See
            <a href="optimization.html#using-explain" title="7.2.1. Optimizing Queries with EXPLAIN">Section 7.2.1, “Optimizing Queries with <code class="literal">EXPLAIN</code>”</a>.
          </p></li><li><p>
            Try to avoid complex <code class="literal">SELECT</code> queries on
            <code class="literal">MyISAM</code> tables that are updated
            frequently, to avoid problems with table locking that occur
            due to contention between readers and writers.
          </p></li><li><p>
            <code class="literal">MyISAM</code> supports concurrent inserts: If a
            table has no free blocks in the middle of the data file, you
            can <code class="literal">INSERT</code> new rows into it at the same
            time that other threads are reading from the table. If it is
            important to be able to do this, you should consider using
            the table in ways that avoid deleting rows. Another
            possibility is to run <code class="literal">OPTIMIZE TABLE</code> to
            defragment the table after you have deleted a lot of rows
            from it. This behavior is altered by setting the
            <code class="literal">concurrent_insert</code> variable. You can force
            new rows to be appended (and therefore allow concurrent
            inserts), even in tables that have deleted rows. See
            <a href="optimization.html#concurrent-inserts" title="7.3.3. Concurrent Inserts">Section 7.3.3, “Concurrent Inserts”</a>.
          </p><p class="mnmas"><b>MySQL Enterprise</b>
              For optimization tips geared to your specific
              circumstances subscribe to the MySQL Enterprise Monitor.
              For more information, see
              <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
            </p></li><li><p>
            To fix any compression issues that may have occurred with
            <code class="literal">ARCHIVE</code> tables, you can use
            <code class="literal">OPTIMIZE TABLE</code>. See
            <a href="storage-engines.html#archive-storage-engine" title="13.10. The ARCHIVE Storage Engine">Section 13.10, “The <code class="literal">ARCHIVE</code> Storage Engine”</a>.
          </p></li><li><p>
            Use <code class="literal">ALTER TABLE ... ORDER BY
            <em class="replaceable"><code>expr1</code></em>,
            <em class="replaceable"><code>expr2</code></em>, ...</code> if you
            usually retrieve rows in
            <code class="literal"><em class="replaceable"><code>expr1</code></em>,
            <em class="replaceable"><code>expr2</code></em>, ...</code> order. By
            using this option after extensive changes to the table, you
            may be able to get higher performance.
          </p></li><li><p>
            In some cases, it may make sense to introduce a column that
            is “<span class="quote">hashed</span>” based on information from other
            columns. If this column is short, reasonably unique, and
            indexed, it may be much faster than a “<span class="quote">wide</span>”
            index on many columns. In MySQL, it is very easy to use this
            extra column:
          </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
  WHERE <em class="replaceable"><code>hash_col</code></em>=MD5(CONCAT(<em class="replaceable"><code>col1</code></em>,<em class="replaceable"><code>col2</code></em>))
  AND <em class="replaceable"><code>col1</code></em>='<em class="replaceable"><code>constant</code></em>' AND <em class="replaceable"><code>col2</code></em>='<em class="replaceable"><code>constant</code></em>';
</pre></li><li><p>
            For <code class="literal">MyISAM</code> tables that change frequently,
            you should try to avoid all variable-length columns
            (<code class="literal">VARCHAR</code>, <code class="literal">BLOB</code>, and
            <code class="literal">TEXT</code>). The table uses dynamic row format
            if it includes even a single variable-length column. See
            <a href="storage-engines.html" title="Chapter 13. Storage Engines">Chapter 13, <i>Storage Engines</i></a>.
          </p></li><li><p>
            It is normally not useful to split a table into different
            tables just because the rows become large. In accessing a
            row, the biggest performance hit is the disk seek needed to
            find the first byte of the row. After finding the data, most
            modern disks can read the entire row fast enough for most
            applications. The only cases where splitting up a table
            makes an appreciable difference is if it is a
            <code class="literal">MyISAM</code> table using dynamic row format
            that you can change to a fixed row size, or if you very
            often need to scan the table but do not need most of the
            columns. See <a href="storage-engines.html" title="Chapter 13. Storage Engines">Chapter 13, <i>Storage Engines</i></a>.
          </p></li><li><p>
            If you often need to calculate results such as counts based
            on information from a lot of rows, it may be preferable to
            introduce a new table and update the counter in real time.
            An update of the following form is very fast:
          </p><pre class="programlisting">UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>count_col</code></em>=<em class="replaceable"><code>count_col</code></em>+1 WHERE <em class="replaceable"><code>key_col</code></em>=<em class="replaceable"><code>constant</code></em>;
</pre><p>
            This is very important when you use MySQL storage engines
            such as <code class="literal">MyISAM</code> that has only table-level
            locking (multiple readers with single writers). This also
            gives better performance with most database systems, because
            the row locking manager in this case has less to do.
          </p></li><li><p>
            If you need to collect statistics from large log tables, use
            summary tables instead of scanning the entire log table.
            Maintaining the summaries should be much faster than trying
            to calculate statistics “<span class="quote">live.</span>” Regenerating
            new summary tables from the logs when things change
            (depending on business decisions) is faster than changing
            the running application.
          </p></li><li><p>
            If possible, you should classify reports as
            “<span class="quote">live</span>” or as “<span class="quote">statistical,</span>” where
            data needed for statistical reports is created only from
            summary tables that are generated periodically from the live
            data.
          </p></li><li><p>
            Take advantage of the fact that columns have default values.
            Insert values explicitly only when the value to be inserted
            differs from the default. This reduces the parsing that
            MySQL must do and improves the insert speed.
          </p></li><li><p>
            In some cases, it is convenient to pack and store data into
            a <code class="literal">BLOB</code> column. In this case, you must
            provide code in your application to pack and unpack
            information, but this may save a lot of accesses at some
            stage. This is practical when you have data that does not
            conform well to a rows-and-columns table structure.
          </p></li><li><p>
            Normally, you should try to keep all data non-redundant
            (observing what is referred to in database theory as
            <em class="firstterm">third normal form</em>). However, there
            may be situations in which it can be advantageous to
            duplicate information or create summary tables to gain more
            speed.
          </p></li><li><p>
            Stored routines or UDFs (user-defined functions) may be a
            good way to gain performance for some tasks. See
            <a href="stored-procedures.html" title="Chapter 23. Stored Procedures and Functions">Chapter 23, <i>Stored Procedures and Functions</i></a>, and
            <a href="extending-mysql.html#adding-functions" title="31.3. Adding New Functions to MySQL">Section 31.3, “Adding New Functions to MySQL”</a>, for more information.
          </p></li><li><p>
            You can increase performance by caching queries or answers
            in your application and then executing many inserts or
            updates together. If your database system supports table
            locks, this should help to ensure that the index cache is
            only flushed once after all updates. You can also take
            advantage of MySQL's query cache to achieve similar results;
            see <a href="optimization.html#query-cache" title="7.5.4. The MySQL Query Cache">Section 7.5.4, “The MySQL Query Cache”</a>.
          </p></li><li><p>
            Use <code class="literal">INSERT DELAYED</code> when you do not need
            to know when your data is written. This reduces the overall
            insertion impact because many rows can be written with a
            single disk write.
          </p></li><li><p>
            Use <code class="literal">INSERT LOW_PRIORITY</code> when you want to
            give <code class="literal">SELECT</code> statements higher priority
            than your inserts.
          </p><p>
            Use <code class="literal">SELECT HIGH_PRIORITY</code> to get
            retrievals that jump the queue. That is, the
            <code class="literal">SELECT</code> is executed even if there is
            another client waiting to do a write.
          </p><p>
            <code class="literal">LOW_PRIORITY</code> and
            <code class="literal">HIGH_PRIORITY</code> have an effect only for
            storage engines that use only table-level locking
            (<code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>,
            <code class="literal">MERGE</code>).
          </p></li><li><p>
            Use multiple-row <code class="literal">INSERT</code> statements to
            store many rows with one SQL statement. Many SQL servers
            support this, including MySQL.
          </p></li><li><p>
            Use <code class="literal">LOAD DATA INFILE</code> to load large
            amounts of data. This is faster than using
            <code class="literal">INSERT</code> statements.
          </p></li><li><p>
            Use <code class="literal">AUTO_INCREMENT</code> columns so that each
            row in a table can be identified by a single unique value.
            unique values.
          </p></li><li><p>
            Use <code class="literal">OPTIMIZE TABLE</code> once in a while to
            avoid fragmentation with dynamic-format
            <code class="literal">MyISAM</code> tables. See
            <a href="storage-engines.html#myisam-table-formats" title="13.4.3. MyISAM Table Storage Formats">Section 13.4.3, “<code class="literal">MyISAM</code> Table Storage Formats”</a>.
          </p></li><li><p>
            Use <code class="literal">MEMORY</code> tables when possible to get
            more speed. See <a href="storage-engines.html#memory-storage-engine" title="13.7. The MEMORY (HEAP) Storage Engine">Section 13.7, “The <code class="literal">MEMORY</code> (<code class="literal">HEAP</code>) Storage Engine”</a>.
            <code class="literal">MEMORY</code> tables are useful for non-critical
            data that is accessed often, such as information about the
            last displayed banner for users who don't have cookies
            enabled in their Web browser. User sessions are another
            alternative available in many Web application environments
            for handling volatile state data.
          </p></li><li><p>
            With Web servers, images and other binary assets should
            normally be stored as files. That is, store only a reference
            to the file rather than the file itself in the database.
            Most Web servers are better at caching files than database
            contents, so using files is generally faster.
          </p></li><li><p>
            Columns with identical information in different tables
            should be declared to have identical data types so that
            joins based on the corresponding columns will be faster.
          </p></li><li><p>
            Try to keep column names simple. For example, in a table
            named <code class="literal">customer</code>, use a column name of
            <code class="literal">name</code> instead of
            <code class="literal">customer_name</code>. To make your names
            portable to other SQL servers, you should keep them shorter
            than 18 characters.
          </p></li><li><p>
            If you need really high speed, you should take a look at the
            low-level interfaces for data storage that the different SQL
            servers support. For example, by accessing the MySQL
            <code class="literal">MyISAM</code> storage engine directly, you could
            get a speed increase of two to five times compared to using
            the SQL interface. To be able to do this, the data must be
            on the same server as the application, and usually it should
            only be accessed by one process (because external file
            locking is really slow). One could eliminate these problems
            by introducing low-level <code class="literal">MyISAM</code> commands
            in the MySQL server (this could be one easy way to get more
            performance if needed). By carefully designing the database
            interface, it should be quite easy to support this type of
            optimization.
          </p></li><li><p>
            If you are using numerical data, it is faster in many cases
            to access information from a database (using a live
            connection) than to access a text file. Information in the
            database is likely to be stored in a more compact format
            than in the text file, so accessing it involves fewer disk
            accesses. You also save code in your application because you
            need not parse your text files to find line and column
            boundaries.
          </p></li><li><p>
            Replication can provide a performance benefit for some
            operations. You can distribute client retrievals among
            replication servers to split up the load. To avoid slowing
            down the master while making backups, you can make backups
            using a slave server. See <a href="replication.html" title="Chapter 19. Replication">Chapter 19, <i>Replication</i></a>.
          </p></li><li><p>
            Declaring a <code class="literal">MyISAM</code> table with the
            <code class="literal">DELAY_KEY_WRITE=1</code> table option makes
            index updates faster because they are not flushed to disk
            until the table is closed. The downside is that if something
            kills the server while such a table is open, you should
            ensure that the table is okay by running the server with the
            <code class="option">--myisam-recover</code> option, or by running
            <span><strong class="command">myisamchk</strong></span> before restarting the server.
            (However, even in this case, you should not lose anything by
            using <code class="literal">DELAY_KEY_WRITE</code>, because the key
            information can always be generated from the data rows.)
          </p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="locking-issues"></a>7.3. Locking Issues</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#internal-locking">7.3.1. Internal Locking Methods</a></span></dt><dt><span class="section"><a href="optimization.html#table-locking">7.3.2. Table Locking Issues</a></span></dt><dt><span class="section"><a href="optimization.html#concurrent-inserts">7.3.3. Concurrent Inserts</a></span></dt><dt><span class="section"><a href="optimization.html#external-locking">7.3.4. External Locking</a></span></dt></dl></div><p>
      MySQL manages contention for table contents using locking:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          Internal locking is performed within the MySQL server itself
          to manage contention for table contents by multiple threads.
          This type of locking is internal because it is performed
          entirely by the server and involves no other programs. See
          <a href="optimization.html#internal-locking" title="7.3.1. Internal Locking Methods">Section 7.3.1, “Internal Locking Methods”</a>.
        </p></li><li><p>
          External locking occurs when the server and other programs
          lock table files to coordinate among themselves which program
          can access the tables at which time. See
          <a href="optimization.html#external-locking" title="7.3.4. External Locking">Section 7.3.4, “External Locking”</a>. See
          <a href="optimization.html#external-locking" title="7.3.4. External Locking">Section 7.3.4, “External Locking”</a>.
        </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="internal-locking"></a>7.3.1. Internal Locking Methods</h3></div></div></div><a class="indexterm" name="id2066126"></a><a class="indexterm" name="id2066135"></a><a class="indexterm" name="id2066147"></a><a class="indexterm" name="id2066156"></a><a class="indexterm" name="id2066169"></a><a class="indexterm" name="id2066178"></a><a class="indexterm" name="id2066186"></a><a class="indexterm" name="id2066199"></a><p>
        This section discusses internal locking; that is, locking
        performed within the MySQL server itself to manage contention
        for table contents by multiple threads. This type of locking is
        internal because it is performed entirely by the server and
        involves no other programs. External locking occurs when the
        server and other programs lock table files to coordinate among
        themselves which program can access the tables at which time.
        See <a href="optimization.html#external-locking" title="7.3.4. External Locking">Section 7.3.4, “External Locking”</a>.
      </p><p>
        MySQL uses table-level locking for <code class="literal">MyISAM</code> and
        <code class="literal">MEMORY</code> tables, and row-level locking for
        <code class="literal">InnoDB</code> tables.
      </p><p>
        In many cases, you can make an educated guess about which
        locking type is best for an application, but generally it is
        difficult to say that a given lock type is better than another.
        Everything depends on the application and different parts of an
        application may require different lock types.
      </p><p>
        To decide whether you want to use a storage engine with
        row-level locking, you should look at what your application does
        and what mix of select and update statements it uses. For
        example, most Web applications perform many selects, relatively
        few deletes, updates based mainly on key values, and inserts
        into a few specific tables. The base MySQL
        <code class="literal">MyISAM</code> setup is very well tuned for this.
      </p><p class="mnmas"><b>MySQL Enterprise</b>
          The MySQL Enterprise Monitor provides expert advice on when to
          use table-level locking and when to use row-level locking. To
          subscribe see
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p><p>
        Table locking in MySQL is deadlock-free for storage engines that
        use table-level locking. Deadlock avoidance is managed by always
        requesting all needed locks at once at the beginning of a query
        and always locking the tables in the same order.
      </p><p>
        MySQL grants table write locks as follows:
      </p><div class="orderedlist"><ol type="1"><li><p>
            If there are no locks on the table, put a write lock on it.
          </p></li><li><p>
            Otherwise, put the lock request in the write lock queue.
          </p></li></ol></div><p>
        MySQL grants table read locks as follows:
      </p><div class="orderedlist"><ol type="1"><li><p>
            If there are no write locks on the table, put a read lock on
            it.
          </p></li><li><p>
            Otherwise, put the lock request in the read lock queue.
          </p></li></ol></div><p>
        When a lock is released, the lock is made available to the
        requests in the write lock queue and then to the requests in the
        read lock queue. This means that if you have many updates for a
        table, <code class="literal">SELECT</code> statements wait until there are
        no more updates.
      </p><p>
        You can analyze the table lock contention on your system by
        checking the <code class="literal">Table_locks_immediate</code> and
        <code class="literal">Table_locks_waited</code> status variables, which
        indicate the number of times that requests for table locks could
        be granted immediately and the number that had to wait,
        respectively:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Table%';</code></strong>
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
</pre><a class="indexterm" name="id2066384"></a><a class="indexterm" name="id2066393"></a><p>
        The <code class="literal">MyISAM</code> storage engine supports concurrent
        inserts to reduce contention between readers and writers for a
        given table: If a <code class="literal">MyISAM</code> table has no free
        blocks in the middle of the data file, rows are always inserted
        at the end of the data file. In this case, you can freely mix
        concurrent <code class="literal">INSERT</code> and
        <code class="literal">SELECT</code> statements for a
        <code class="literal">MyISAM</code> table without locks. That is, you can
        insert rows into a <code class="literal">MyISAM</code> table at the same
        time other clients are reading from it. Holes can result from
        rows having been deleted from or updated in the middle of the
        table. If there are holes, concurrent inserts are disabled but
        are re-enabled automatically when all holes have been filled
        with new data.. This behavior is altered by the
        <code class="literal">concurrent_insert</code> system variable. See
        <a href="optimization.html#concurrent-inserts" title="7.3.3. Concurrent Inserts">Section 7.3.3, “Concurrent Inserts”</a>.
      </p><p>
        If you acquire a table lock explicitly with <code class="literal">LOCK
        TABLES</code>, you can request a <code class="literal">READ
        LOCAL</code> lock rather than a <code class="literal">READ</code> lock
        to enable other sessions to perform concurrent inserts while you
        have the table locked.
      </p><p>
        To perform many <code class="literal">INSERT</code> and
        <code class="literal">SELECT</code> operations on a table
        <code class="literal">real_table</code> when concurrent inserts are not
        possible, you can insert rows into a temporary table
        <code class="literal">temp_table</code> and update the real table with the
        rows from the temporary table periodically. This can be done
        with the following code:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOCK TABLES real_table WRITE, temp_table WRITE;</code></strong>
mysql&gt; <strong class="userinput"><code>INSERT INTO real_table SELECT * FROM temp_table;</code></strong>
mysql&gt; <strong class="userinput"><code>DELETE FROM temp_table;</code></strong>
mysql&gt; <strong class="userinput"><code>UNLOCK TABLES;</code></strong>
</pre><p>
        <code class="literal">InnoDB</code> uses row locks. Deadlocks are possible
        for <code class="literal">InnoDB</code> because it automatically acquires
        locks during the processing of SQL statements, not at the start
        of the transaction.
      </p><p>
        Advantages of row-level locking:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Fewer lock conflicts when different sessions access
            different rows
          </p></li><li><p>
            Fewer changes for rollbacks
          </p></li><li><p>
            Possible to lock a single row for a long time
          </p></li></ul></div><p>
        Disadvantages of row-level locking:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Requires more memory than table-level locks
          </p></li><li><p>
            Slower than table-level locks when used on a large part of
            the table because you must acquire many more locks
          </p></li><li><p>
            Definitely much slower than other locks if you often do
            <code class="literal">GROUP BY</code> operations on a large part of
            the data or if you must scan the entire table frequently
          </p></li></ul></div><p>
        Table locks are superior to row-level locks in the following
        cases:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Most statements for the table are reads
          </p></li><li><p>
            Statements for the table are a mix of reads and writes,
            where writes are updates or deletes for a single row that
            can be fetched with one key read:
          </p><pre class="programlisting">UPDATE <em class="replaceable"><code>tbl_name</code></em> SET <em class="replaceable"><code>column</code></em>=<em class="replaceable"><code>value</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
DELETE FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>unique_key_col</code></em>=<em class="replaceable"><code>key_value</code></em>;
</pre></li><li><p>
            <code class="literal">SELECT</code> combined with concurrent
            <code class="literal">INSERT</code> statements, and very few
            <code class="literal">UPDATE</code> or <code class="literal">DELETE</code>
            statements
          </p></li><li><p>
            Many scans or <code class="literal">GROUP BY</code> operations on the
            entire table without any writers
          </p></li></ul></div><p>
        With higher-level locks, you can more easily tune applications
        by supporting locks of different types, because the lock
        overhead is less than for row-level locks.
      </p><p>
        Options other than row-level locking:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Versioning (such as that used in MySQL for concurrent
            inserts) where it is possible to have one writer at the same
            time as many readers. This means that the database or table
            supports different views for the data depending on when
            access begins. Other common terms for this are “<span class="quote">time
            travel,</span>” “<span class="quote">copy on write,</span>” or “<span class="quote">copy
            on demand.</span>”
          </p></li><li><p>
            Copy on demand is in many cases superior to row-level
            locking. However, in the worst case, it can use much more
            memory than using normal locks.
          </p></li><li><p>
            Instead of using row-level locks, you can employ
            application-level locks, such as those provided by
            <a href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> and
            <a href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a> in MySQL.
            These are advisory locks, so they work only with
            applications that cooperate with each other. See
            <a href="functions.html#miscellaneous-functions" title="11.11.4. Miscellaneous Functions">Section 11.11.4, “Miscellaneous Functions”</a>.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="table-locking"></a>7.3.2. Table Locking Issues</h3></div></div></div><a class="indexterm" name="id2066802"></a><p>
        To achieve a very high lock speed, MySQL uses table locking
        (instead of page, row, or column locking) for all storage
        engines except <code class="literal">InnoDB</code> and
        <code class="literal">NDBCLUSTER</code>.
      </p><p>
        For <code class="literal">InnoDB</code> tables, MySQL only uses table
        locking if you explicitly lock the table with <code class="literal">LOCK
        TABLES</code>. For these storage engines, we recommend that
        you not use <code class="literal">LOCK TABLES</code> at all, because
        <code class="literal">InnoDB</code> uses automatic row-level locking to
        ensure transaction isolation.
      </p><p>
        For large tables, table locking is much better than row locking
        for most applications, but there are some pitfalls:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Table locking enables many threads to read from a table at
            the same time, but if a thread wants to write to a table, it
            must first get exclusive access. During the update, all
            other threads that want to access this particular table must
            wait until the update is done.
          </p></li><li><p>
            Table updates normally are considered to be more important
            than table retrievals, so they are given higher priority.
            This should ensure that updates to a table are not
            “<span class="quote">starved</span>” even if there is heavy
            <code class="literal">SELECT</code> activity for the table.
          </p></li><li><p>
            Table locking causes problems in cases such as when a thread
            is waiting because the disk is full and free space needs to
            become available before the thread can proceed. In this
            case, all threads that want to access the problem table are
            also put in a waiting state until more disk space is made
            available.
          </p></li></ul></div><p>
        Table locking is also disadvantageous under the following
        scenario:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            A client issues a <code class="literal">SELECT</code> that takes a
            long time to run.
          </p></li><li><p>
            Another client then issues an <code class="literal">UPDATE</code> on
            the same table. This client waits until the
            <code class="literal">SELECT</code> is finished.
          </p></li><li><p>
            Another client issues another <code class="literal">SELECT</code>
            statement on the same table. Because
            <code class="literal">UPDATE</code> has higher priority than
            <code class="literal">SELECT</code>, this <code class="literal">SELECT</code>
            waits for the <code class="literal">UPDATE</code> to finish,
            <span class="emphasis"><em>and</em></span> for the first
            <code class="literal">SELECT</code> to finish.
          </p></li></ul></div><p>
        The following items describe some ways to avoid or reduce
        contention caused by table locking:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Try to get the <code class="literal">SELECT</code> statements to run
            faster so that they lock tables for a shorter time. You
            might have to create some summary tables to do this.
          </p></li><li><p>
            Start <span><strong class="command">mysqld</strong></span> with
            <code class="option">--low-priority-updates</code>. For storage engines
            that use only table-level locking
            (<code class="literal">MyISAM</code>, <code class="literal">MEMORY</code>,
            <code class="literal">MERGE</code>), this gives all statements that
            update (modify) a table lower priority than
            <code class="literal">SELECT</code> statements. In this case, the
            second <code class="literal">SELECT</code> statement in the preceding
            scenario would execute before the <code class="literal">UPDATE</code>
            statement, and would not need to wait for the first
            <code class="literal">SELECT</code> to finish.
          </p></li><li><p>
            You can specify that all updates issued in a specific
            connection should be done with low priority by using the
            <code class="literal">SET LOW_PRIORITY_UPDATES=1</code> statement. See
            <a href="server-administration.html#server-session-variables" title="5.1.4. Session System Variables">Section 5.1.4, “Session System Variables”</a>.
          </p></li><li><p>
            You can give a specific <code class="literal">INSERT</code>,
            <code class="literal">UPDATE</code>, or <code class="literal">DELETE</code>
            statement lower priority with the
            <code class="literal">LOW_PRIORITY</code> attribute.
          </p></li><li><p>
            You can give a specific <code class="literal">SELECT</code> statement
            higher priority with the <code class="literal">HIGH_PRIORITY</code>
            attribute. See <a href="sql-syntax.html#select" title="12.2.7. SELECT Syntax">Section 12.2.7, “<code class="literal">SELECT</code> Syntax”</a>.
          </p></li><li><p>
            You can start <span><strong class="command">mysqld</strong></span> with a low value for
            the <code class="literal">max_write_lock_count</code> system variable
            to force MySQL to temporarily elevate the priority of all
            <code class="literal">SELECT</code> statements that are waiting for a
            table after a specific number of inserts to the table occur.
            This allows <code class="literal">READ</code> locks after a certain
            number of <code class="literal">WRITE</code> locks.
          </p></li><li><p>
            If you have problems with <code class="literal">INSERT</code> combined
            with <code class="literal">SELECT</code>, you might want to consider
            switching to <code class="literal">MyISAM</code> tables, which support
            concurrent <code class="literal">SELECT</code> and
            <code class="literal">INSERT</code> statements. (See
            <a href="optimization.html#concurrent-inserts" title="7.3.3. Concurrent Inserts">Section 7.3.3, “Concurrent Inserts”</a>.)
          </p></li><li><p>
            If you mix inserts and deletes on the same table,
            <code class="literal">INSERT DELAYED</code> may be of great help. See
            <a href="sql-syntax.html#insert-delayed" title="12.2.4.2. INSERT DELAYED Syntax">Section 12.2.4.2, “<code class="literal">INSERT DELAYED</code> Syntax”</a>.
          </p></li><li><p>
            If you have problems with mixed <code class="literal">SELECT</code>
            and <code class="literal">DELETE</code> statements, the
            <code class="literal">LIMIT</code> option to <code class="literal">DELETE</code>
            may help. See <a href="sql-syntax.html#delete" title="12.2.1. DELETE Syntax">Section 12.2.1, “<code class="literal">DELETE</code> Syntax”</a>.
          </p></li><li><p>
            Using <code class="literal">SQL_BUFFER_RESULT</code> with
            <code class="literal">SELECT</code> statements can help to make the
            duration of table locks shorter. See
            <a href="sql-syntax.html#select" title="12.2.7. SELECT Syntax">Section 12.2.7, “<code class="literal">SELECT</code> Syntax”</a>.
          </p></li><li><p>
            You could change the locking code in
            <code class="filename">mysys/thr_lock.c</code> to use a single queue.
            In this case, write locks and read locks would have the same
            priority, which might help some applications.
          </p></li></ul></div><p>
        Here are some tips concerning table locks in MySQL:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Concurrent users are not a problem if you do not mix updates
            with selects that need to examine many rows in the same
            table.
          </p></li><li><p>
            You can use <code class="literal">LOCK TABLES</code> to increase
            speed, because many updates within a single lock is much
            faster than updating without locks. Splitting table contents
            into separate tables may also help.
          </p></li><li><p>
            If you encounter speed problems with table locks in MySQL,
            you may be able to improve performance by converting some of
            your tables to <code class="literal">InnoDB</code>. See
            <a href="storage-engines.html#innodb" title="13.5. The InnoDB Storage Engine">Section 13.5, “The <code class="literal">InnoDB</code> Storage Engine”</a>.
          </p><p class="mnmas"><b>MySQL Enterprise</b>
              Lock contention can seriously degrade performance. The
              MySQL Enterprise Monitor provides expert advice on
              avoiding this problem. To subscribe, see
              <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="concurrent-inserts"></a>7.3.3. Concurrent Inserts</h3></div></div></div><a class="indexterm" name="id2067398"></a><a class="indexterm" name="id2067406"></a><p>
        The <code class="literal">MyISAM</code> storage engine supports concurrent
        inserts to reduce contention between readers and writers for a
        given table: If a <code class="literal">MyISAM</code> table has no holes
        in the data file (deleted rows in the middle), inserts can be
        performed to add rows to the end of the table at the same time
        that <code class="literal">SELECT</code> statements are reading rows from
        the table.
      </p><p>
        The <code class="literal">concurrent_insert</code> system variable can be
        set to modify the concurrent-insert processing. By default, the
        variable is set to 1 and concurrent inserts are handled as just
        described. If <code class="literal">concurrent_insert</code> is set to 0,
        concurrent inserts are disabled. If the variable is set to 2,
        concurrent inserts at the end of the table are allowed even for
        tables that have deleted rows. See also the description of the
        <a href="server-administration.html#option_mysqld_concurrent_insert"><code class="literal">concurrent_insert</code></a>
        system variable.
      </p><p>
        Under circumstances where concurrent inserts can be used, there
        is seldom any need to use the <code class="literal">DELAYED</code>
        modifier for <code class="literal">INSERT</code> statements. See
        <a href="sql-syntax.html#insert-delayed" title="12.2.4.2. INSERT DELAYED Syntax">Section 12.2.4.2, “<code class="literal">INSERT DELAYED</code> Syntax”</a>.
      </p><p>
        If you are using the binary log, concurrent inserts are
        converted to normal inserts for <code class="literal">CREATE ...
        SELECT</code> or <code class="literal">INSERT ... SELECT</code>
        statements. This is done to ensure that you can re-create an
        exact copy of your tables by applying the log during a backup
        operation. See <a href="server-administration.html#binary-log" title="5.2.4. The Binary Log">Section 5.2.4, “The Binary Log”</a>. In addition, for
        those statements a read lock is placed on the selected-from
        table such that inserts into that table are blocked. The effect
        is that concurrent inserts for that table must wait as well.
      </p><p>
        With <code class="literal">LOAD DATA INFILE</code>, if you specify
        <code class="literal">CONCURRENT</code> with a <code class="literal">MyISAM</code>
        table that satisfies the condition for concurrent inserts (that
        is, it contains no free blocks in the middle), other threads can
        retrieve data from the table while <code class="literal">LOAD DATA</code>
        is executing. Use of the <code class="literal">CONCURRENT</code> option
        affects the performance of <code class="literal">LOAD DATA</code> a bit,
        even if no other thread is using the table at the same time.
      </p><p>
        If you specify <code class="literal">HIGH_PRIORITY</code>, it overrides
        the effect of the <code class="option">--low-priority-updates</code> option
        if the server was started with that option. It also causes
        concurrent inserts not to be used.
      </p><p>
        For <code class="literal">LOCK TABLE</code>, the difference between
        <code class="literal">READ LOCAL</code> and <code class="literal">READ</code> is
        that <code class="literal">READ LOCAL</code> allows non-conflicting
        <code class="literal">INSERT</code> statements (concurrent inserts) to
        execute while the lock is held. However, this cannot be used if
        you are going to manipulate the database using processes
        external to the server while you hold the lock.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="external-locking"></a>7.3.4. External Locking</h3></div></div></div><a class="indexterm" name="id2067618"></a><a class="indexterm" name="id2067627"></a><p>
        External locking is the use of filesystem locking to manage
        contention for database tables by multiple processes. External
        locking is used in situations where a single process such as the
        MySQL server cannot be assumed to be the only process that
        requires access to tables. Here are some examples:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If you run multiple servers that use the same database
            directory (not recommended), each server must have external
            locking enabled.
          </p></li><li><p>
            If you use <span><strong class="command">myisamchk</strong></span> to perform table
            maintenance operations on <code class="literal">MyISAM</code> tables,
            you must either ensure that the server is not running, or
            that the server has external locking enabled so that it
            locks table files as necessary to coordinate with
            <span><strong class="command">myisamchk</strong></span> for access to the tables. The
            same is true for use of <span><strong class="command">myisampack</strong></span> to
            pack <code class="literal">MyISAM</code> tables.
          </p></li></ul></div><p>
        With external locking in effect, each process that requires
        access to a table acquires a filesystem lock for the table files
        before proceeding to access the table. If all necessary locks
        cannot be acquired, the process is blocked from accessing the
        table until the locks can be obtained (after the process that
        currently holds the locks releases them).
      </p><p>
        External locking affects server performance because the server
        must sometimes wait for other processes before it can access
        tables.
      </p><p>
        External locking is unnecessary if you run a single server to
        access a given data directory (which is the usual case) and if
        no other programs such as <span><strong class="command">myisamchk</strong></span> need to
        modify tables while the server is running. If you only
        <span class="emphasis"><em>read</em></span> tables with other programs, external
        locking is not required, although <span><strong class="command">myisamchk</strong></span>
        might report warnings if the server changes tables while
        <span><strong class="command">myisamchk</strong></span> is reading them.
      </p><p>
        With external locking disabled, to use
        <span><strong class="command">myisamchk</strong></span>, you must either stop the server
        while <span><strong class="command">myisamchk</strong></span> executes or else lock and
        flush the tables before running <span><strong class="command">myisamchk</strong></span>.
        (See <a href="optimization.html#system-optimization" title="7.5.1. System Factors and Startup Parameter Tuning">Section 7.5.1, “System Factors and Startup Parameter Tuning”</a>.) To avoid this
        requirement, use the <code class="literal">CHECK TABLE</code> and
        <code class="literal">REPAIR TABLE</code> statements to check and repair
        <code class="literal">MyISAM</code> tables.
      </p><p>
        For <span><strong class="command">mysqld</strong></span>, external locking is controlled by
        the value of the <code class="literal">skip_external_locking</code> system
        variable. (Before MySQL 4.0.3, this variable is named
        <code class="literal">skip_locking</code>.) When this variable is enabled,
        external locking is disabled, and vice versa. From MySQL 4.0 on,
        external locking is disabled by default. Before MySQL 4.0,
        external locking is enabled by default on Linux or when MySQL is
        configured to use MIT-pthreads.
      </p><p>
        Use of external locking can be controlled at server startup by
        using the <code class="option">--external-locking</code> or
        <code class="option">--skip-external-locking</code> option. (Before MySQL
        4.0.3, these options are named <code class="option">--enable-locking</code>
        and <code class="literal">--skip-locking</code>.)
      </p><p>
        If you do use external locking option to enable updates to
        <code class="literal">MyISAM</code> tables from many MySQL processes, you
        must ensure that the following conditions are satisfied:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            You should not use the query cache for queries that use
            tables that are updated by another process.
          </p></li><li><p>
            You should not start the server with the
            <code class="option">--delay-key-write=ALL</code> option or use the
            <code class="literal">DELAY_KEY_WRITE=1</code> table option for any
            shared tables. Otherise, index corruption can occur.
          </p></li></ul></div><p>
        The easiest way to satisfy these conditions is to always use
        <code class="option">--external-locking</code> together with
        <code class="option">--delay-key-write=OFF</code> and
        <code class="option">--query-cache-size=0</code>. (This is not done by
        default because in many setups it is useful to have a mixture of
        the preceding options.)
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-database-structure"></a>7.4. Optimizing Database Structure</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#design">7.4.1. Design Choices</a></span></dt><dt><span class="section"><a href="optimization.html#data-size">7.4.2. Make Your Data as Small as Possible</a></span></dt><dt><span class="section"><a href="optimization.html#indexes">7.4.3. Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-column-indexes">7.4.4. Multiple-Column Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-indexes">7.4.5. How MySQL Uses Indexes</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-key-cache">7.4.6. The <code class="literal">MyISAM</code> Key Cache</a></span></dt><dt><span class="section"><a href="optimization.html#myisam-index-statistics">7.4.7. <code class="literal">MyISAM</code> Index Statistics Collection</a></span></dt><dt><span class="section"><a href="optimization.html#table-cache">7.4.8. How MySQL Opens and Closes Tables</a></span></dt><dt><span class="section"><a href="optimization.html#creating-many-tables">7.4.9. Drawbacks to Creating Many Tables in the Same Database</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="design"></a>7.4.1. Design Choices</h3></div></div></div><a class="indexterm" name="id2067901"></a><a class="indexterm" name="id2067914"></a><a class="indexterm" name="id2067922"></a><p>
        MySQL keeps row data and index data in separate files. Many
        (almost all) other database systems mix row and index data in
        the same file. We believe that the MySQL choice is better for a
        very wide range of modern systems.
      </p><p>
        Another way to store the row data is to keep the information for
        each column in a separate area (examples are SDBM and Focus).
        This causes a performance hit for every query that accesses more
        than one column. Because this degenerates so quickly when more
        than one column is accessed, we believe that this model is not
        good for general-purpose databases.
      </p><p>
        The more common case is that the index and data are stored
        together (as in Oracle/Sybase, et al). In this case, you find
        the row information at the leaf page of the index. The good
        thing with this layout is that it, in many cases, depending on
        how well the index is cached, saves a disk read. The bad things
        with this layout are:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Table scanning is much slower because you have to read
            through the indexes to get at the data.
          </p></li><li><p>
            You cannot use only the index table to retrieve data for a
            query.
          </p></li><li><p>
            You use more space because you must duplicate indexes from
            the nodes (you cannot store the row in the nodes).
          </p></li><li><p>
            Deletes degenerate the table over time (because indexes in
            nodes are usually not updated on delete).
          </p></li><li><p>
            It is more difficult to cache only the index data.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="data-size"></a>7.4.2. Make Your Data as Small as Possible</h3></div></div></div><a class="indexterm" name="id2068007"></a><a class="indexterm" name="id2068019"></a><a class="indexterm" name="id2068032"></a><a class="indexterm" name="id2068044"></a><a class="indexterm" name="id2068056"></a><p>
        One of the most basic optimizations is to design your tables to
        take as little space on the disk as possible. This can result in
        huge improvements because disk reads are faster, and smaller
        tables normally require less main memory while their contents
        are being actively processed during query execution. Indexing
        also is a lesser resource burden if done on smaller columns.
      </p><p>
        MySQL supports many different storage engines (table types) and
        row formats. For each table, you can decide which storage and
        indexing method to use. Choosing the proper table format for
        your application may give you a big performance gain. See
        <a href="storage-engines.html" title="Chapter 13. Storage Engines">Chapter 13, <i>Storage Engines</i></a>.
      </p><p>
        You can get better performance for a table and minimize storage
        space by using the techniques listed here:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Use the most efficient (smallest) data types possible. MySQL
            has many specialized types that save disk space and memory.
            For example, use the smaller integer types if possible to
            get smaller tables. <code class="literal">MEDIUMINT</code> is often a
            better choice than <code class="literal">INT</code> because a
            <code class="literal">MEDIUMINT</code> column uses 25% less space.
          </p></li><li><p>
            Declare columns to be <code class="literal">NOT NULL</code> if
            possible. It makes everything faster and you save one bit
            per column. If you really need <code class="literal">NULL</code> in
            your application, you should definitely use it. Just avoid
            having it on all columns by default.
          </p></li><li><p>
            For <code class="literal">MyISAM</code> tables, if you do not have any
            variable-length columns (<code class="literal">VARCHAR</code>,
            <code class="literal">TEXT</code>, or <code class="literal">BLOB</code>
            columns), a fixed-size row format is used. This is faster
            but unfortunately may waste some space. See
            <a href="storage-engines.html#myisam-table-formats" title="13.4.3. MyISAM Table Storage Formats">Section 13.4.3, “<code class="literal">MyISAM</code> Table Storage Formats”</a>. You can hint that
            you want to have fixed length rows even if you have
            <code class="literal">VARCHAR</code> columns with the <code class="literal">CREATE
            TABLE</code> option <code class="literal">ROW_FORMAT=FIXED</code>.
          </p></li><li><p>
            <code class="literal">InnoDB</code> tables use a compact storage
            format. In versions of MySQL earlier than 5.0.3,
            <code class="literal">InnoDB</code> rows contain some redundant
            information, such as the number of columns and the length of
            each column, even for fixed-size columns. By default, tables
            are created in the compact format
            (<code class="literal">ROW_FORMAT=COMPACT</code>). If you wish to
            downgrade to older versions of MySQL, you can request the
            old format with <code class="literal">ROW_FORMAT=REDUNDANT</code>.
          </p><p>
            The presence of the compact row format decreases row storage
            space by about 20% at the cost of increasing CPU use for
            some operations. If your workload is a typical one that is
            limited by cache hit rates and disk speed it is likely to be
            faster. If it is a rare case that is limited by CPU speed,
            it might be slower.
          </p><p>
            The compact <code class="literal">InnoDB</code> format also changes
            how <code class="literal">CHAR</code> columns containing UTF-8 data
            are stored. With <code class="literal">ROW_FORMAT=REDUNDANT</code>, a
            UTF-8 <code class="literal">CHAR(<em class="replaceable"><code>N</code></em>)</code>
            occupies 3 × <em class="replaceable"><code>N</code></em> bytes, given
            that the maximum length of a UTF-8 encoded character is
            three bytes. Many languages can be written primarily using
            single-byte UTF-8 characters, so a fixed storage length
            often wastes space. With
            <code class="literal">ROW_FORMAT=COMPACT</code> format,
            <code class="literal">InnoDB</code> allocates a variable amount of
            storage in the range from <em class="replaceable"><code>N</code></em> to 3
            × <em class="replaceable"><code>N</code></em> bytes for these columns
            by stripping trailing spaces if necessary. The minimum
            storage length is kept as <em class="replaceable"><code>N</code></em> bytes
            to facilitate in-place updates in typical cases.
          </p></li><li><p>
            The primary index of a table should be as short as possible.
            This makes identification of each row easy and efficient.
          </p></li><li><p>
            Create only the indexes that you really need. Indexes are
            good for retrieval but bad when you need to store data
            quickly. If you access a table mostly by searching on a
            combination of columns, create an index on them. The first
            part of the index should be the column most used. If you
            <span class="emphasis"><em>always</em></span> use many columns when selecting
            from the table, you should use the column with more
            duplicates first to obtain better compression of the index.
          </p></li><li><p>
            If it is very likely that a string column has a unique
            prefix on the first number of characters, it's better to
            index only this prefix, using MySQL's support for creating
            an index on the leftmost part of the column (see
            <a href="sql-syntax.html#create-index" title="12.1.7. CREATE INDEX Syntax">Section 12.1.7, “<code class="literal">CREATE INDEX</code> Syntax”</a>). Shorter indexes are faster,
            not only because they require less disk space, but because
            they also give you more hits in the index cache, and thus
            fewer disk seeks. See <a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">Section 7.5.2, “Tuning Server Parameters”</a>.
          </p></li><li><p>
            In some circumstances, it can be beneficial to split into
            two a table that is scanned very often. This is especially
            true if it is a dynamic-format table and it is possible to
            use a smaller static format table that can be used to find
            the relevant rows when scanning the table.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="indexes"></a>7.4.3. Column Indexes</h3></div></div></div><a class="indexterm" name="id2068359"></a><a class="indexterm" name="id2068372"></a><a class="indexterm" name="id2068384"></a><p>
        All MySQL data types can be indexed. Use of indexes on the
        relevant columns is the best way to improve the performance of
        <code class="literal">SELECT</code> operations.
      </p><p>
        The maximum number of indexes per table and the maximum index
        length is defined per storage engine. See
        <a href="storage-engines.html" title="Chapter 13. Storage Engines">Chapter 13, <i>Storage Engines</i></a>. All storage engines support
        at least 16 indexes per table and a total index length of at
        least 256 bytes. Most storage engines have higher limits.
      </p><a class="indexterm" name="id2068414"></a><a class="indexterm" name="id2068426"></a><a class="indexterm" name="id2068439"></a><a class="indexterm" name="id2068451"></a><p>
        With
        <code class="literal"><em class="replaceable"><code>col_name</code></em>(<em class="replaceable"><code>N</code></em>)</code>
        syntax in an index specification, you can create an index that
        uses only the first <em class="replaceable"><code>N</code></em> characters of a
        string column. Indexing only a prefix of column values in this
        way can make the index file much smaller. When you index a
        <code class="literal">BLOB</code> or <code class="literal">TEXT</code> column, you
        <span class="emphasis"><em>must</em></span> specify a prefix length for the index.
        For example:
      </p><pre class="programlisting">CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre><p>
        Prefixes can be up to 1000 bytes long (767 bytes for
        <code class="literal">InnoDB</code> tables). Note that prefix limits are
        measured in bytes, whereas the prefix length in <code class="literal">CREATE
        TABLE</code> statements is interpreted as number of
        characters. <span class="emphasis"><em>Be sure to take this into account when
        specifying a prefix length for a column that uses a multi-byte
        character set</em></span>.
      </p><p>
        You can also create <code class="literal">FULLTEXT</code> indexes. These
        are used for full-text searches. Only the
        <code class="literal">MyISAM</code> storage engine supports
        <code class="literal">FULLTEXT</code> indexes and only for
        <code class="literal">CHAR</code>, <code class="literal">VARCHAR</code>, and
        <code class="literal">TEXT</code> columns. Indexing always takes place
        over the entire column and column prefix indexing is not
        supported. For details, see <a href="functions.html#fulltext-search" title="11.8. Full-Text Search Functions">Section 11.8, “Full-Text Search Functions”</a>.
      </p><p>
        You can also create indexes on spatial data types. Currently,
        only <code class="literal">MyISAM</code> supports R-tree indexes on
        spatial types. Other storage engines use B-trees for indexing
        spatial types (except for <code class="literal">ARCHIVE</code> and
        <code class="literal">NDBCLUSTER</code>, which do not support spatial type
        indexing).
      </p><p>
        The <code class="literal">MEMORY</code> storage engine uses
        <code class="literal">HASH</code> indexes by default, but also supports
        <code class="literal">BTREE</code> indexes.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="multiple-column-indexes"></a>7.4.4. Multiple-Column Indexes</h3></div></div></div><a class="indexterm" name="id2068628"></a><a class="indexterm" name="id2068637"></a><a class="indexterm" name="id2068649"></a><p>
        MySQL can create composite indexes (that is, indexes on multiple
        columns). An index may consist of up to 15 columns. For certain
        data types, you can index a prefix of the column (see
        <a href="optimization.html#indexes" title="7.4.3. Column Indexes">Section 7.4.3, “Column Indexes”</a>).
      </p><p>
        A multiple-column index can be considered a sorted array
        containing values that are created by concatenating the values
        of the indexed columns.
      </p><p>
        MySQL uses multiple-column indexes in such a way that queries
        are fast when you specify a known quantity for the first column
        of the index in a <code class="literal">WHERE</code> clause, even if you
        do not specify values for the other columns.
      </p><p>
        Suppose that a table has the following specification:
      </p><pre class="programlisting">CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
</pre><p>
        The <code class="literal">name</code> index is an index over the
        <code class="literal">last_name</code> and <code class="literal">first_name</code>
        columns. The index can be used for queries that specify values
        in a known range for <code class="literal">last_name</code>, or for both
        <code class="literal">last_name</code> and <code class="literal">first_name</code>.
        Therefore, the <code class="literal">name</code> index is used in the
        following queries:
      </p><pre class="programlisting">SELECT * FROM test WHERE last_name='Widenius';

SELECT * FROM test
  WHERE last_name='Widenius' AND first_name='Michael';

SELECT * FROM test
  WHERE last_name='Widenius'
  AND (first_name='Michael' OR first_name='Monty');

SELECT * FROM test
  WHERE last_name='Widenius'
  AND first_name &gt;='M' AND first_name &lt; 'N';
</pre><p>
        However, the <code class="literal">name</code> index is
        <span class="emphasis"><em>not</em></span> used in the following queries:
      </p><pre class="programlisting">SELECT * FROM test WHERE first_name='Michael';

SELECT * FROM test
  WHERE last_name='Widenius' OR first_name='Michael';
</pre><p>
        The manner in which MySQL uses indexes to improve query
        performance is discussed further in
        <a href="optimization.html#mysql-indexes" title="7.4.5. How MySQL Uses Indexes">Section 7.4.5, “How MySQL Uses Indexes”</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-indexes"></a>7.4.5. How MySQL Uses Indexes</h3></div></div></div><a class="indexterm" name="id2068793"></a><p>
        Indexes are used to find rows with specific column values
        quickly. Without an index, MySQL must begin with the first row
        and then read through the entire table to find the relevant
        rows. The larger the table, the more this costs. If the table
        has an index for the columns in question, MySQL can quickly
        determine the position to seek to in the middle of the data file
        without having to look at all the data. If a table has 1,000
        rows, this is at least 100 times faster than reading
        sequentially. If you need to access most of the rows, it is
        faster to read sequentially, because this minimizes disk seeks.
      </p><p>
        Most MySQL indexes (<code class="literal">PRIMARY KEY</code>,
        <code class="literal">UNIQUE</code>, <code class="literal">INDEX</code>, and
        <code class="literal">FULLTEXT</code>) are stored in B-trees. Exceptions
        are that indexes on spatial data types use R-trees, and that
        <code class="literal">MEMORY</code> tables also support hash indexes.
      </p><p>
        Strings are automatically prefix- and end-space compressed. See
        <a href="sql-syntax.html#create-index" title="12.1.7. CREATE INDEX Syntax">Section 12.1.7, “<code class="literal">CREATE INDEX</code> Syntax”</a>.
      </p><p>
        In general, indexes are used as described in the following
        discussion. Characteristics specific to hash indexes (as used in
        <code class="literal">MEMORY</code> tables) are described at the end of
        this section.
      </p><p>
        MySQL uses indexes for these operations:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            To find the rows matching a <code class="literal">WHERE</code> clause
            quickly.
          </p></li><li><p>
            To eliminate rows from consideration. If there is a choice
            between multiple indexes, MySQL normally uses the index that
            finds the smallest number of rows.
          </p></li><li><p>
            To retrieve rows from other tables when performing joins.
            MySQL can use indexes on columns more efficiently if they
            are declared as the same type and size. In this context,
            <code class="literal">VARCHAR</code> and <code class="literal">CHAR</code> are
            considered the same if they are declared as the same size.
            For example, <code class="literal">VARCHAR(10)</code> and
            <code class="literal">CHAR(10)</code> are the same size, but
            <code class="literal">VARCHAR(10)</code> and
            <code class="literal">CHAR(15)</code> are not.
          </p><p>
            Comparison of dissimilar columns may prevent use of indexes
            if values cannot be compared directly without conversion.
            Suppose that a numeric column is compared to a string
            column. For a given value such as <code class="literal">1</code> in
            the numeric column, it might compare equal to any number of
            values in the string column such as <code class="literal">'1'</code>,
            <code class="literal">' 1'</code>, <code class="literal">'00001'</code>, or
            <code class="literal">'01.e1'</code>. This rules out use of any
            indexes for the string column.
          </p></li><li><p>
            To find the <a href="functions.html#function_min"><code class="literal">MIN()</code></a> or
            <a href="functions.html#function_max"><code class="literal">MAX()</code></a> value for a specific
            indexed column <em class="replaceable"><code>key_col</code></em>. This is
            optimized by a preprocessor that checks whether you are
            using <code class="literal">WHERE <em class="replaceable"><code>key_part_N</code></em> =
            <em class="replaceable"><code>constant</code></em></code> on all key
            parts that occur before <em class="replaceable"><code>key_col</code></em>
            in the index. In this case, MySQL does a single key lookup
            for each <a href="functions.html#function_min"><code class="literal">MIN()</code></a> or
            <a href="functions.html#function_max"><code class="literal">MAX()</code></a> expression and
            replaces it with a constant. If all expressions are replaced
            with constants, the query returns at once. For example:
          </p><pre class="programlisting">SELECT MIN(<em class="replaceable"><code>key_part2</code></em>),MAX(<em class="replaceable"><code>key_part2</code></em>)
  FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_part1</code></em>=10;
</pre></li><li><p>
            To sort or group a table if the sorting or grouping is done
            on a leftmost prefix of a usable key (for example,
            <code class="literal">ORDER BY <em class="replaceable"><code>key_part1</code></em>,
            <em class="replaceable"><code>key_part2</code></em></code>). If all key
            parts are followed by <code class="literal">DESC</code>, the key is
            read in reverse order. See
            <a href="optimization.html#order-by-optimization" title="7.2.12. ORDER BY Optimization">Section 7.2.12, “<code class="literal">ORDER BY</code> Optimization”</a>.
          </p></li><li><p>
            In some cases, a query can be optimized to retrieve values
            without consulting the data rows. If a query uses only
            columns from a table that are numeric and that form a
            leftmost prefix for some key, the selected values may be
            retrieved from the index tree for greater speed:
          </p><pre class="programlisting">SELECT <em class="replaceable"><code>key_part3</code></em> FROM <em class="replaceable"><code>tbl_name</code></em> 
  WHERE <em class="replaceable"><code>key_part1</code></em>=1
</pre></li></ul></div><p>
        Suppose that you issue the following <code class="literal">SELECT</code>
        statement:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;</code></strong>
</pre><p>
        If a multiple-column index exists on <code class="literal">col1</code> and
        <code class="literal">col2</code>, the appropriate rows can be fetched
        directly. If separate single-column indexes exist on
        <code class="literal">col1</code> and <code class="literal">col2</code>, the
        optimizer will attempt to use the Index Merge optimization (see
        <a href="optimization.html#index-merge-optimization" title="7.2.6. Index Merge Optimization">Section 7.2.6, “Index Merge Optimization”</a>), or attempt to find
        the most restrictive index by deciding which index finds fewer
        rows and using that index to fetch the rows.
      </p><a class="indexterm" name="id2069181"></a><a class="indexterm" name="id2069194"></a><p>
        If the table has a multiple-column index, any leftmost prefix of
        the index can be used by the optimizer to find rows. For
        example, if you have a three-column index on <code class="literal">(col1,
        col2, col3)</code>, you have indexed search capabilities on
        <code class="literal">(col1)</code>, <code class="literal">(col1, col2)</code>, and
        <code class="literal">(col1, col2, col3)</code>.
      </p><p>
        MySQL cannot use an index if the columns do not form a leftmost
        prefix of the index. Suppose that you have the
        <code class="literal">SELECT</code> statements shown here:
      </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col1=<em class="replaceable"><code>val1</code></em> AND col2=<em class="replaceable"><code>val2</code></em>;

SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em>;
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE col2=<em class="replaceable"><code>val2</code></em> AND col3=<em class="replaceable"><code>val3</code></em>;
</pre><p>
        If an index exists on <code class="literal">(col1, col2, col3)</code>,
        only the first two queries use the index. The third and fourth
        queries do involve indexed columns, but
        <code class="literal">(col2)</code> and <code class="literal">(col2, col3)</code>
        are not leftmost prefixes of <code class="literal">(col1, col2,
        col3)</code>.
      </p><a class="indexterm" name="id2069314"></a><a class="indexterm" name="id2069326"></a><a class="indexterm" name="id2069339"></a><a class="indexterm" name="id2069351"></a><p>
        A B-tree index can be used for column comparisons in expressions
        that use the
        <a href="functions.html#operator_equal"><code class="literal">=</code></a>,
        <a href="functions.html#operator_greater-than"><code class="literal">&gt;</code></a>,
        <a href="functions.html#operator_greater-than-or-equal"><code class="literal">&gt;=</code></a>,
        <a href="functions.html#operator_less-than"><code class="literal">&lt;</code></a>,
        <a href="functions.html#operator_less-than-or-equal"><code class="literal">&lt;=</code></a>,
        or <a href="functions.html#operator_between"><code class="literal">BETWEEN</code></a> operators. The
        index also can be used for
        <a href="functions.html#operator_like"><code class="literal">LIKE</code></a> comparisons if the
        argument to <a href="functions.html#operator_like"><code class="literal">LIKE</code></a> is a constant
        string that does not start with a wildcard character. For
        example, the following <code class="literal">SELECT</code> statements use
        indexes:
      </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE 'Pat%_ck%';
</pre><p>
        In the first statement, only rows with <code class="literal">'Patrick' &lt;=
        <em class="replaceable"><code>key_col</code></em> &lt; 'Patricl'</code> are
        considered. In the second statement, only rows with
        <code class="literal">'Pat' &lt;= <em class="replaceable"><code>key_col</code></em> &lt;
        'Pau'</code> are considered.
      </p><p>
        The following <code class="literal">SELECT</code> statements do not use
        indexes:
      </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE '%Patrick%';
SELECT * FROM <em class="replaceable"><code>tbl_name</code></em> WHERE <em class="replaceable"><code>key_col</code></em> LIKE <em class="replaceable"><code>other_col</code></em>;
</pre><p>
        In the first statement, the
        <a href="functions.html#operator_like"><code class="literal">LIKE</code></a> value begins with a
        wildcard character. In the second statement, the
        <a href="functions.html#operator_like"><code class="literal">LIKE</code></a> value is not a constant.
      </p><p>
        If you use <code class="literal">... LIKE
        '%<em class="replaceable"><code>string</code></em>%'</code> and
        <em class="replaceable"><code>string</code></em> is longer than three
        characters, MySQL uses the <em class="firstterm">Turbo Boyer-Moore
        algorithm</em> to initialize the pattern for the string
        and then uses this pattern to perform the search more quickly.
      </p><a class="indexterm" name="id2069551"></a><a class="indexterm" name="id2069563"></a><p>
        A search using <code class="literal"><em class="replaceable"><code>col_name</code></em> IS
        NULL</code> employs indexes if
        <em class="replaceable"><code>col_name</code></em> is indexed.
      </p><p>
        Any index that does not span all
        <a href="functions.html#operator_and"><code class="literal">AND</code></a> levels in the
        <code class="literal">WHERE</code> clause is not used to optimize the
        query. In other words, to be able to use an index, a prefix of
        the index must be used in every
        <a href="functions.html#operator_and"><code class="literal">AND</code></a> group.
      </p><p>
        The following <code class="literal">WHERE</code> clauses use indexes:
      </p><pre class="programlisting">... WHERE <em class="replaceable"><code>index_part1</code></em>=1 AND <em class="replaceable"><code>index_part2</code></em>=2 AND <em class="replaceable"><code>other_column</code></em>=3
    /* <em class="replaceable"><code>index</code></em> = 1 OR <em class="replaceable"><code>index</code></em> = 2 */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10 AND <em class="replaceable"><code>index</code></em>=2
    /* optimized like "<em class="replaceable"><code>index_part1</code></em>='hello'" */
... WHERE <em class="replaceable"><code>index_part1</code></em>='hello' AND <em class="replaceable"><code>index_part3</code></em>=5
    /* Can use index on <em class="replaceable"><code>index1</code></em> but not on <em class="replaceable"><code>index2</code></em> or <em class="replaceable"><code>index3</code></em> */
... WHERE <em class="replaceable"><code>index1</code></em>=1 AND <em class="replaceable"><code>index2</code></em>=2 OR <em class="replaceable"><code>index1</code></em>=3 AND <em class="replaceable"><code>index3</code></em>=3;
</pre><p>
        These <code class="literal">WHERE</code> clauses do
        <span class="emphasis"><em>not</em></span> use indexes:
      </p><pre class="programlisting">    /* <em class="replaceable"><code>index_part1</code></em> is not used */
... WHERE <em class="replaceable"><code>index_part2</code></em>=1 AND <em class="replaceable"><code>index_part3</code></em>=2

    /*  Index is not used in both parts of the WHERE clause  */
... WHERE <em class="replaceable"><code>index</code></em>=1 OR A=10

    /* No index spans all rows  */
... WHERE <em class="replaceable"><code>index_part1</code></em>=1 OR <em class="replaceable"><code>index_part2</code></em>=10
</pre><p>
        Sometimes MySQL does not use an index, even if one is available.
        One circumstance under which this occurs is when the optimizer
        estimates that using the index would require MySQL to access a
        very large percentage of the rows in the table. (In this case, a
        table scan is likely to be much faster because it requires fewer
        seeks.) However, if such a query uses <code class="literal">LIMIT</code>
        to retrieve only some of the rows, MySQL uses an index anyway,
        because it can much more quickly find the few rows to return in
        the result.
      </p><p>
        Hash indexes have somewhat different characteristics from those
        just discussed:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            They are used only for equality comparisons that use the
            <code class="literal">=</code> or <code class="literal">&lt;=&gt;</code>
            operators (but are <span class="emphasis"><em>very</em></span> fast). They are
            not used for comparison operators such as
            <code class="literal">&lt;</code> that find a range of values.
          </p></li><li><p>
            The optimizer cannot use a hash index to speed up
            <code class="literal">ORDER BY</code> operations. (This type of index
            cannot be used to search for the next entry in order.)
          </p></li><li><p>
            MySQL cannot determine approximately how many rows there are
            between two values (this is used by the range optimizer to
            decide which index to use). This may affect some queries if
            you change a <code class="literal">MyISAM</code> table to a
            hash-indexed <code class="literal">MEMORY</code> table.
          </p></li><li><p>
            Only whole keys can be used to search for a row. (With a
            B-tree index, any leftmost prefix of the key can be used to
            find rows.)
          </p></li></ul></div><p class="mnmas"><b>MySQL Enterprise</b>
          Often, it is not possible to predict exactly what indexes will
          be required or will be most efficient — actual table
          usage is the best indicator. The MySQL Enterprise Monitor
          provides expert advice on this topic. For more information,
          see <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-key-cache"></a>7.4.6. The <code class="literal">MyISAM</code> Key Cache</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#shared-key-cache">7.4.6.1. Shared Key Cache Access</a></span></dt><dt><span class="section"><a href="optimization.html#multiple-key-caches">7.4.6.2. Multiple Key Caches</a></span></dt><dt><span class="section"><a href="optimization.html#midpoint-insertion">7.4.6.3. Midpoint Insertion Strategy</a></span></dt><dt><span class="section"><a href="optimization.html#index-preloading">7.4.6.4. Index Preloading</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-block-size">7.4.6.5. Key Cache Block Size</a></span></dt><dt><span class="section"><a href="optimization.html#key-cache-restructuring">7.4.6.6. Restructuring a Key Cache</a></span></dt></dl></div><a class="indexterm" name="id2069868"></a><a class="indexterm" name="id2069877"></a><p>
        To minimize disk I/O, the <code class="literal">MyISAM</code> storage
        engine exploits a strategy that is used by many database
        management systems. It employs a cache mechanism to keep the
        most frequently accessed table blocks in memory:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            For index blocks, a special structure called the
            <em class="firstterm">key cache</em> (or <em class="firstterm">key
            buffer</em>) is maintained. The structure contains a
            number of block buffers where the most-used index blocks are
            placed.
          </p></li><li><p>
            For data blocks, MySQL uses no special cache. Instead it
            relies on the native operating system filesystem cache.
          </p></li></ul></div><p>
        This section first describes the basic operation of the
        <code class="literal">MyISAM</code> key cache. Then it discusses features
        that improve key cache performance and that enable you to better
        control cache operation:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Multiple threads can access the cache concurrently.
          </p></li><li><p>
            You can set up multiple key caches and assign table indexes
            to specific caches.
          </p></li></ul></div><p>
        To control the size of the key cache, use the
        <code class="literal">key_buffer_size</code> system variable. If this
        variable is set equal to zero, no key cache is used. The key
        cache also is not used if the <code class="literal">key_buffer_size</code>
        value is too small to allocate the minimal number of block
        buffers (8).
      </p><p class="mnmas"><b>MySQL Enterprise</b>
          For expert advice on identifying the optimum size for
          <code class="literal">key_buffer_size</code>, subscribe to the MySQL
          Enterprise Monitor. See
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p><p>
        When the key cache is not operational, index files are accessed
        using only the native filesystem buffering provided by the
        operating system. (In other words, table index blocks are
        accessed using the same strategy as that employed for table data
        blocks.)
      </p><p>
        An index block is a contiguous unit of access to the
        <code class="literal">MyISAM</code> index files. Usually the size of an
        index block is equal to the size of nodes of the index B-tree.
        (Indexes are represented on disk using a B-tree data structure.
        Nodes at the bottom of the tree are leaf nodes. Nodes above the
        leaf nodes are non-leaf nodes.)
      </p><p>
        All block buffers in a key cache structure are the same size.
        This size can be equal to, greater than, or less than the size
        of a table index block. Usually one these two values is a
        multiple of the other.
      </p><p>
        When data from any table index block must be accessed, the
        server first checks whether it is available in some block buffer
        of the key cache. If it is, the server accesses data in the key
        cache rather than on disk. That is, it reads from the cache or
        writes into it rather than reading from or writing to disk.
        Otherwise, the server chooses a cache block buffer containing a
        different table index block (or blocks) and replaces the data
        there by a copy of required table index block. As soon as the
        new index block is in the cache, the index data can be accessed.
      </p><p>
        If it happens that a block selected for replacement has been
        modified, the block is considered “<span class="quote">dirty.</span>” In this
        case, prior to being replaced, its contents are flushed to the
        table index from which it came.
      </p><p>
        Usually the server follows an <em class="firstterm">LRU (Least Recently
        Used)</em> strategy: When choosing a block for
        replacement, it selects the least recently used index block. To
        make this choice easier, the key cache module maintains a
        special queue (<em class="firstterm">LRU chain</em>) of all used
        blocks. When a block is accessed, it is placed at the end of the
        queue. When blocks need to be replaced, blocks at the beginning
        of the queue are the least recently used and become the first
        candidates for eviction.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="shared-key-cache"></a>7.4.6.1. Shared Key Cache Access</h4></div></div></div><p>
          Threads can access key cache buffers simultaneously, subject
          to the following conditions:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              A buffer that is not being updated can be accessed by
              multiple threads.
            </p></li><li><p>
              A buffer that is being updated causes threads that need to
              use it to wait until the update is complete.
            </p></li><li><p>
              Multiple threads can initiate requests that result in
              cache block replacements, as long as they do not interfere
              with each other (that is, as long as they need different
              index blocks, and thus cause different cache blocks to be
              replaced).
            </p></li></ul></div><p>
          Shared access to the key cache enables the server to improve
          throughput significantly.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="multiple-key-caches"></a>7.4.6.2. Multiple Key Caches</h4></div></div></div><p>
          Shared access to the key cache improves performance but does
          not eliminate contention among threads entirely. They still
          compete for control structures that manage access to the key
          cache buffers. To reduce key cache access contention further,
          MySQL also provides multiple key caches. This feature enables
          you to assign different table indexes to different key caches.
        </p><p>
          Where there are multiple key caches, the server must know
          which cache to use when processing queries for a given
          <code class="literal">MyISAM</code> table. By default, all
          <code class="literal">MyISAM</code> table indexes are cached in the
          default key cache. To assign table indexes to a specific key
          cache, use the <code class="literal">CACHE INDEX</code> statement (see
          <a href="sql-syntax.html#cache-index" title="12.5.6.1. CACHE INDEX Syntax">Section 12.5.6.1, “<code class="literal">CACHE INDEX</code> Syntax”</a>). For example, the following
          statement assigns indexes from the tables
          <code class="literal">t1</code>, <code class="literal">t2</code>, and
          <code class="literal">t3</code> to the key cache named
          <code class="literal">hot_cache</code>:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>CACHE INDEX t1, t2, t3 IN hot_cache;</code></strong>
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre><p>
          The key cache referred to in a <code class="literal">CACHE INDEX</code>
          statement can be created by setting its size with a
          <code class="literal">SET GLOBAL</code> parameter setting statement or
          by using server startup options. For example:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=128*1024;</code></strong>
</pre><p>
          To destroy a key cache, set its size to zero:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL keycache1.key_buffer_size=0;</code></strong>
</pre><p>
          Note that you cannot destroy the default key cache. Any
          attempt to do this will be ignored:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL key_buffer_size = 0;</code></strong>

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'key_buffer_size';</code></strong>
+-----------------+---------+
| Variable_name   | Value   |
+-----------------+---------+
| key_buffer_size | 8384512 |
+-----------------+---------+
</pre><p>
          Key cache variables are structured system variables that have
          a name and components. For
          <code class="literal">keycache1.key_buffer_size</code>,
          <code class="literal">keycache1</code> is the cache variable name and
          <code class="literal">key_buffer_size</code> is the cache component. See
          <a href="server-administration.html#structured-system-variables" title="5.1.5.1. Structured System Variables">Section 5.1.5.1, “Structured System Variables”</a>, for a
          description of the syntax used for referring to structured key
          cache system variables.
        </p><p>
          By default, table indexes are assigned to the main (default)
          key cache created at the server startup. When a key cache is
          destroyed, all indexes assigned to it are reassigned to the
          default key cache.
        </p><p>
          For a busy server, we recommend a strategy that uses three key
          caches:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              A “<span class="quote">hot</span>” key cache that takes up 20% of the
              space allocated for all key caches. Use this for tables
              that are heavily used for searches but that are not
              updated.
            </p></li><li><p>
              A “<span class="quote">cold</span>” key cache that takes up 20% of the
              space allocated for all key caches. Use this cache for
              medium-sized, intensively modified tables, such as
              temporary tables.
            </p></li><li><p>
              A “<span class="quote">warm</span>” key cache that takes up 60% of the
              key cache space. Employ this as the default key cache, to
              be used by default for all other tables.
            </p></li></ul></div><p>
          One reason the use of three key caches is beneficial is that
          access to one key cache structure does not block access to the
          others. Statements that access tables assigned to one cache do
          not compete with statements that access tables assigned to
          another cache. Performance gains occur for other reasons as
          well:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              The hot cache is used only for retrieval queries, so its
              contents are never modified. Consequently, whenever an
              index block needs to be pulled in from disk, the contents
              of the cache block chosen for replacement need not be
              flushed first.
            </p></li><li><p>
              For an index assigned to the hot cache, if there are no
              queries requiring an index scan, there is a high
              probability that the index blocks corresponding to
              non-leaf nodes of the index B-tree remain in the cache.
            </p></li><li><p>
              An update operation most frequently executed for temporary
              tables is performed much faster when the updated node is
              in the cache and need not be read in from disk first. If
              the size of the indexes of the temporary tables are
              comparable with the size of cold key cache, the
              probability is very high that the updated node is in the
              cache.
            </p></li></ul></div><p>
          <code class="literal">CACHE INDEX</code> sets up an association between
          a table and a key cache, but the association is lost each time
          the server restarts. If you want the association to take
          effect each time the server starts, one way to accomplish this
          is to use an option file: Include variable settings that
          configure your key caches, and an <code class="literal">init-file</code>
          option that names a file containing <code class="literal">CACHE
          INDEX</code> statements to be executed. For example:
        </p><pre class="programlisting">key_buffer_size = 4G
hot_cache.key_buffer_size = 2G
cold_cache.key_buffer_size = 2G
init_file=/<em class="replaceable"><code>path</code></em>/<em class="replaceable"><code>to</code></em>/<em class="replaceable"><code>data-directory</code></em>/mysqld_init.sql
</pre><p class="mnmas"><b>MySQL Enterprise</b>
            For advice on how best to configure your
            <code class="filename">my.cnf/my.ini </code> option file subscribe to
            MySQL Enterprise Monitor. Recommendations are based on
            actual table usage. For more information, see
            <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
          </p><p>
          The statements in <code class="filename">mysqld_init.sql</code> are
          executed each time the server starts. The file should contain
          one SQL statement per line. The following example assigns
          several tables each to <code class="literal">hot_cache</code> and
          <code class="literal">cold_cache</code>:
        </p><pre class="programlisting">CACHE INDEX db1.t1, db1.t2, db2.t3 IN hot_cache
CACHE INDEX db1.t4, db2.t5, db2.t6 IN cold_cache
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="midpoint-insertion"></a>7.4.6.3. Midpoint Insertion Strategy</h4></div></div></div><p>
          By default, the key cache management system uses the LRU
          strategy for choosing key cache blocks to be evicted, but it
          also supports a more sophisticated method called the
          <em class="firstterm">midpoint insertion strategy.</em>
        </p><p>
          When using the midpoint insertion strategy, the LRU chain is
          divided into two parts: a hot sub-chain and a warm sub-chain.
          The division point between two parts is not fixed, but the key
          cache management system takes care that the warm part is not
          “<span class="quote">too short,</span>” always containing at least
          <code class="literal">key_cache_division_limit</code> percent of the key
          cache blocks. <code class="literal">key_cache_division_limit</code> is a
          component of structured key cache variables, so its value is a
          parameter that can be set per cache.
        </p><p>
          When an index block is read from a table into the key cache,
          it is placed at the end of the warm sub-chain. After a certain
          number of hits (accesses of the block), it is promoted to the
          hot sub-chain. At present, the number of hits required to
          promote a block (3) is the same for all index blocks.
        </p><p>
          A block promoted into the hot sub-chain is placed at the end
          of the chain. The block then circulates within this sub-chain.
          If the block stays at the beginning of the sub-chain for a
          long enough time, it is demoted to the warm chain. This time
          is determined by the value of the
          <code class="literal">key_cache_age_threshold</code> component of the
          key cache.
        </p><p>
          The threshold value prescribes that, for a key cache
          containing <em class="replaceable"><code>N</code></em> blocks, the block at
          the beginning of the hot sub-chain not accessed within the
          last <code class="literal"><em class="replaceable"><code>N</code></em> ×
          key_cache_age_threshold / 100</code> hits is to be moved to
          the beginning of the warm sub-chain. It then becomes the first
          candidate for eviction, because blocks for replacement always
          are taken from the beginning of the warm sub-chain.
        </p><p>
          The midpoint insertion strategy allows you to keep more-valued
          blocks always in the cache. If you prefer to use the plain LRU
          strategy, leave the
          <code class="literal">key_cache_division_limit</code> value set to its
          default of 100.
        </p><p>
          The midpoint insertion strategy helps to improve performance
          when execution of a query that requires an index scan
          effectively pushes out of the cache all the index blocks
          corresponding to valuable high-level B-tree nodes. To avoid
          this, you must use a midpoint insertion strategy with the
          <code class="literal">key_cache_division_limit</code> set to much less
          than 100. Then valuable frequently hit nodes are preserved in
          the hot sub-chain during an index scan operation as well.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="index-preloading"></a>7.4.6.4. Index Preloading</h4></div></div></div><p>
          If there are enough blocks in a key cache to hold blocks of an
          entire index, or at least the blocks corresponding to its
          non-leaf nodes, it makes sense to preload the key cache with
          index blocks before starting to use it. Preloading allows you
          to put the table index blocks into a key cache buffer in the
          most efficient way: by reading the index blocks from disk
          sequentially.
        </p><p>
          Without preloading, the blocks are still placed into the key
          cache as needed by queries. Although the blocks will stay in
          the cache, because there are enough buffers for all of them,
          they are fetched from disk in random order, and not
          sequentially.
        </p><p>
          To preload an index into a cache, use the <code class="literal">LOAD INDEX
          INTO CACHE</code> statement. For example, the following
          statement preloads nodes (index blocks) of indexes of the
          tables <code class="literal">t1</code> and <code class="literal">t2</code>:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;</code></strong>
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre><p>
          The <code class="literal">IGNORE LEAVES</code> modifier causes only
          blocks for the non-leaf nodes of the index to be preloaded.
          Thus, the statement shown preloads all index blocks from
          <code class="literal">t1</code>, but only blocks for the non-leaf nodes
          from <code class="literal">t2</code>.
        </p><p>
          If an index has been assigned to a key cache using a
          <code class="literal">CACHE INDEX</code> statement, preloading places
          index blocks into that cache. Otherwise, the index is loaded
          into the default key cache.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-block-size"></a>7.4.6.5. Key Cache Block Size</h4></div></div></div><p>
          It is possible to specify the size of the block buffers for an
          individual key cache using the
          <code class="literal">key_cache_block_size</code> variable. This permits
          tuning of the performance of I/O operations for index files.
        </p><p>
          The best performance for I/O operations is achieved when the
          size of read buffers is equal to the size of the native
          operating system I/O buffers. But setting the size of key
          nodes equal to the size of the I/O buffer does not always
          ensure the best overall performance. When reading the big leaf
          nodes, the server pulls in a lot of unnecessary data,
          effectively preventing reading other leaf nodes.
        </p><p>
          Currently, you cannot control the size of the index blocks in
          a table. This size is set by the server when the
          <code class="filename">.MYI</code> index file is created, depending on
          the size of the keys in the indexes present in the table
          definition. In most cases, it is set equal to the I/O buffer
          size.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="key-cache-restructuring"></a>7.4.6.6. Restructuring a Key Cache</h4></div></div></div><p>
          A key cache can be restructured at any time by updating its
          parameter values. For example:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL cold_cache.key_buffer_size=4*1024*1024;</code></strong>
</pre><p>
          If you assign to either the <code class="literal">key_buffer_size</code>
          or <code class="literal">key_cache_block_size</code> key cache component
          a value that differs from the component's current value, the
          server destroys the cache's old structure and creates a new
          one based on the new values. If the cache contains any dirty
          blocks, the server saves them to disk before destroying and
          re-creating the cache. Restructuring does not occur if you
          change other key cache parameters.
        </p><p>
          When restructuring a key cache, the server first flushes the
          contents of any dirty buffers to disk. After that, the cache
          contents become unavailable. However, restructuring does not
          block queries that need to use indexes assigned to the cache.
          Instead, the server directly accesses the table indexes using
          native filesystem caching. Filesystem caching is not as
          efficient as using a key cache, so although queries execute, a
          slowdown can be anticipated. After the cache has been
          restructured, it becomes available again for caching indexes
          assigned to it, and the use of filesystem caching for the
          indexes ceases.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="myisam-index-statistics"></a>7.4.7. <code class="literal">MyISAM</code> Index Statistics Collection</h3></div></div></div><p>
        Storage engines collect statistics about tables for use by the
        optimizer. Table statistics are based on value groups, where a
        value group is a set of rows with the same key prefix value. For
        optimizer purposes, an important statistic is the average value
        group size.
      </p><p>
        MySQL uses the average value group size in the following ways:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            To estimate how may rows must be read for each
            <code class="literal">ref</code> access
          </p></li><li><p>
            To estimate how many row a partial join will produce; that
            is, the number of rows that an operation of this form will
            produce:
          </p><pre class="programlisting">(...) JOIN <em class="replaceable"><code>tbl_name</code></em> ON <em class="replaceable"><code>tbl_name</code></em>.<em class="replaceable"><code>key</code></em> = <em class="replaceable"><code>expr</code></em>
</pre></li></ul></div><p>
        As the average value group size for an index increases, the
        index is less useful for those two purposes because the average
        number of rows per lookup increases: For the index to be good
        for optimization purposes, it is best that each index value
        target a small number of rows in the table. When a given index
        value yields a large number of rows, the index is less useful
        and MySQL is less likely to use it.
      </p><p>
        The average value group size is related to table cardinality,
        which is the number of value groups. The <code class="literal">SHOW
        INDEX</code> statement displays a cardinality value based on
        <em class="replaceable"><code>N</code></em>/<em class="replaceable"><code>S</code></em>, where
        <em class="replaceable"><code>N</code></em> is the number of rows in the table
        and <em class="replaceable"><code>S</code></em> is the average value group
        size. That ratio yields an approximate number of value groups in
        the table.
      </p><p>
        For a join based on the <code class="literal">&lt;=&gt;</code> comparison
        operator, <code class="literal">NULL</code> is not treated differently
        from any other value: <code class="literal">NULL &lt;=&gt; NULL</code>,
        just as <code class="literal"><em class="replaceable"><code>N</code></em> &lt;=&gt;
        <em class="replaceable"><code>N</code></em></code> for any other
        <em class="replaceable"><code>N</code></em>.
      </p><p>
        However, for a join based on the <code class="literal">=</code> operator,
        <code class="literal">NULL</code> is different from
        non-<code class="literal">NULL</code> values:
        <code class="literal"><em class="replaceable"><code>expr1</code></em> =
        <em class="replaceable"><code>expr2</code></em></code> is not true when
        <em class="replaceable"><code>expr1</code></em> or
        <em class="replaceable"><code>expr2</code></em> (or both) are
        <code class="literal">NULL</code>. This affects <code class="literal">ref</code>
        accesses for comparisons of the form
        <code class="literal"><em class="replaceable"><code>tbl_name.key</code></em> =
        <em class="replaceable"><code>expr</code></em></code>: MySQL will not access
        the table if the current value of
        <em class="replaceable"><code>expr</code></em> is <code class="literal">NULL</code>,
        because the comparison cannot be true.
      </p><p>
        For <code class="literal">=</code> comparisons, it does not matter how
        many <code class="literal">NULL</code> values are in the table. For
        optimization purposes, the relevant value is the average size of
        the non-<code class="literal">NULL</code> value groups. However, MySQL
        does not currently allow that average size to be collected or
        used.
      </p><p>
        For <code class="literal">MyISAM</code> tables, you have some control over
        collection of table statistics by means of the
        <code class="literal">myisam_stats_method</code> system variable. This
        variable has two possible values, which differ as follows:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            When <code class="literal">myisam_stats_method</code> is
            <code class="literal">nulls_equal</code>, all <code class="literal">NULL</code>
            values are treated as identical (that is, they all form a
            single value group).
          </p><p>
            If the <code class="literal">NULL</code> value group size is much
            higher than the average non-<code class="literal">NULL</code> value
            group size, this method skews the average value group size
            upward. This makes index appear to the optimizer to be less
            useful than it really is for joins that look for
            non-<code class="literal">NULL</code> values. Consequently, the
            <code class="literal">nulls_equal</code> method may cause the
            optimizer not to use the index for <code class="literal">ref</code>
            accesses when it should.
          </p></li><li><p>
            When <code class="literal">myisam_stats_method</code> is
            <code class="literal">nulls_unequal</code>, <code class="literal">NULL</code>
            values are not considered the same. Instead, each
            <code class="literal">NULL</code> value forms a separate value group
            of size 1.
          </p><p>
            If you have many <code class="literal">NULL</code> values, this method
            skews the average value group size downward. If the average
            non-<code class="literal">NULL</code> value group size is large,
            counting <code class="literal">NULL</code> values each as a group of
            size 1 causes the optimizer to overestimate the value of the
            index for joins that look for non-<code class="literal">NULL</code>
            values. Consequently, the <code class="literal">nulls_unequal</code>
            method may cause the optimizer to use this index for
            <code class="literal">ref</code> lookups when other methods may be
            better.
          </p></li></ul></div><p>
        If you tend to use many joins that use
        <code class="literal">&lt;=&gt;</code> rather than <code class="literal">=</code>,
        <code class="literal">NULL</code> values are not special in comparisons
        and one <code class="literal">NULL</code> is equal to another. In this
        case, <code class="literal">nulls_equal</code> is the appropriate
        statistics method.
      </p><p>
        The <code class="literal">myisam_stats_method</code> system variable has
        global and session values. Setting the global value affects
        <code class="literal">MyISAM</code> statistics collection for all
        <code class="literal">MyISAM</code> tables. Setting the session value
        affects statistics collection only for the current client
        connection. This means that you can force a table's statistics
        to be regenerated with a given method without affecting other
        clients by setting the session value of
        <code class="literal">myisam_stats_method</code>.
      </p><p>
        To regenerate table statistics, you can use any of the following
        methods:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Execute <span><strong class="command">myisamchk
            --stats_method=<em class="replaceable"><code>method_name</code></em>
            --analyze</strong></span>
          </p></li><li><p>
            Change the table to cause its statistics to go out of date
            (for example, insert a row and then delete it), and then set
            <code class="literal">myisam_stats_method</code> and issue an
            <code class="literal">ANALYZE TABLE</code> statement
          </p></li></ul></div><p>
        Some caveats regarding the use of
        <code class="literal">myisam_stats_method</code>:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            You can force table statistics to be collected explicitly,
            as just described. However, MySQL may also collect
            statistics automatically. For example, if during the course
            of executing statements for a table, some of those
            statements modify the table, MySQL may collect statistics.
            (This may occur for bulk inserts or deletes, or some
            <code class="literal">ALTER TABLE</code> statements, for example.) If
            this happens, the statistics are collected using whatever
            value <code class="literal">myisam_stats_method</code> has at the
            time. Thus, if you collect statistics using one method, but
            <code class="literal">myisam_stats_method</code> is set to the other
            method when a table's statistics are collected automatically
            later, the other method will be used.
          </p></li><li><p>
            There is no way to tell which method was used to generate
            statistics for a given <code class="literal">MyISAM</code> table.
          </p></li><li><p>
            <code class="literal">myisam_stats_method</code> applies only to
            <code class="literal">MyISAM</code> tables. Other storage engines have
            only one method for collecting table statistics. Usually it
            is closer to the <code class="literal">nulls_equal</code> method.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="table-cache"></a>7.4.8. How MySQL Opens and Closes Tables</h3></div></div></div><a class="indexterm" name="id2071350"></a><a class="indexterm" name="id2071359"></a><a class="indexterm" name="id2071371"></a><a class="indexterm" name="id2071384"></a><a class="indexterm" name="id2071396"></a><a class="indexterm" name="id2071409"></a><a class="indexterm" name="id2071418"></a><a class="indexterm" name="id2071430"></a><p>
        When you execute a <span><strong class="command">mysqladmin status</strong></span> command,
        you should see something like this:
      </p><pre class="programlisting">Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
</pre><p>
        The <code class="literal">Open tables</code> value of 12 can be somewhat
        puzzling if you have only six tables.
      </p><p>
        MySQL is multi-threaded, so there may be many clients issuing
        queries for a given table simultaneously. To minimize the
        problem with multiple client threads having different states on
        the same table, the table is opened independently by each
        concurrent thread. This uses additional memory but normally
        increases performance. With <code class="literal">MyISAM</code> tables,
        one extra file descriptor is required for the data file for each
        client that has the table open. (By contrast, the index file
        descriptor is shared between all threads.)
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          <code class="literal">table_open_cache</code> was previously known as
          <code class="literal">table_cache</code> in MySQL 5.1.2 and earlier.
        </p></div><p>
        The <code class="literal">table_open_cache</code>,
        <code class="literal">max_connections</code>, and
        <code class="literal">max_tmp_tables</code> system variables affect the
        maximum number of files the server keeps open. If you increase
        one or more of these values, you may run up against a limit
        imposed by your operating system on the per-process number of
        open file descriptors. Many operating systems allow you to
        increase the open-files limit, although the method varies widely
        from system to system. Consult your operating system
        documentation to determine whether it is possible to increase
        the limit and how to do so.
      </p><p>
        <code class="literal">table_open_cache</code> is related to
        <code class="literal">max_connections</code>. For example, for 200
        concurrent running connections, you should have a table cache
        size of at least <code class="literal">200 ×
        <em class="replaceable"><code>N</code></em></code>, where
        <em class="replaceable"><code>N</code></em> is the maximum number of tables per
        join in any of the queries which you execute. You must also
        reserve some extra file descriptors for temporary tables and
        files.
      </p><p>
        Make sure that your operating system can handle the number of
        open file descriptors implied by the
        <code class="literal">table_open_cache</code> setting. If
        <code class="literal">table_open_cache</code> is set too high, MySQL may
        run out of file descriptors and refuse connections, fail to
        perform queries, and be very unreliable. You also have to take
        into account that the <code class="literal">MyISAM</code> storage engine
        needs two file descriptors for each unique open table. You can
        increase the number of file descriptors available to MySQL using
        the <code class="option">--open-files-limit</code> startup option to
        <span><strong class="command">mysqld</strong></span>. See
        <a href="error-handling.html#not-enough-file-handles" title="B.1.2.18. 'File' Not Found and
          Similar Errors">Section B.1.2.18, “<span class="errortext">'<em class="replaceable"><code>File</code></em>' Not Found</span> and
          Similar Errors”</a>.
      </p><p>
        The cache of open tables is kept at a level of
        <code class="literal">table_open_cache</code> entries. The default value
        is 64; this can be changed with the
        <code class="option">--table_open_cache</code> option to
        <span><strong class="command">mysqld</strong></span>. Note that MySQL may temporarily open
        more tables than this to execute queries.
      </p><p class="mnmas"><b>MySQL Enterprise</b>
          Performance may suffer if <code class="literal">table_open_cache</code>
          is set too low. For expert advice on the optimum value for
          this variable, subscribe to the MySQL Enterprise Monitor. For
          more information see
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p><p>
        MySQL closes an unused table and removes it from the table cache
        under the following circumstances:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            When the cache is full and a thread tries to open a table
            that is not in the cache.
          </p></li><li><p>
            When the cache contains more than
            <code class="literal">table_open_cache</code> entries and a table in
            the cache is no longer being used by any threads.
          </p></li><li><p>
            When a table flushing operation occurs. This happens when
            someone issues a <code class="literal">FLUSH TABLES</code> statement
            or executes a <span><strong class="command">mysqladmin flush-tables</strong></span> or
            <span><strong class="command">mysqladmin refresh</strong></span> command.
          </p></li></ul></div><p>
        When the table cache fills up, the server uses the following
        procedure to locate a cache entry to use:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Tables that are not currently in use are released, beginning
            with the table least recently used.
          </p></li><li><p>
            If a new table needs to be opened, but the cache is full and
            no tables can be released, the cache is temporarily extended
            as necessary. When the cache is in a temporarily extended
            state and a table goes from a used to unused state, the
            table is closed and released from the cache.
          </p></li></ul></div><p>
        A <code class="literal">MyISAM</code> table is opened for each concurrent
        access. This means the table needs to be opened twice if two
        threads access the same table or if a thread accesses the table
        twice in the same query (for example, by joining the table to
        itself). Each concurrent open requires an entry in the table
        cache. The first open of any <code class="literal">MyISAM</code> table
        takes two file descriptors: one for the data file and one for
        the index file. Each additional use of the table takes only one
        file descriptor for the data file. The index file descriptor is
        shared among all threads.
      </p><p>
        If you are opening a table with the <code class="literal">HANDLER
        <em class="replaceable"><code>tbl_name</code></em> OPEN</code> statement, a
        dedicated table object is allocated for the thread. This table
        object is not shared by other threads and is not closed until
        the thread calls <code class="literal">HANDLER
        <em class="replaceable"><code>tbl_name</code></em> CLOSE</code> or the
        thread terminates. When this happens, the table is put back in
        the table cache (if the cache is not full). See
        <a href="sql-syntax.html#handler" title="12.2.3. HANDLER Syntax">Section 12.2.3, “<code class="literal">HANDLER</code> Syntax”</a>.
      </p><p>
        You can determine whether your table cache is too small by
        checking the <span><strong class="command">mysqld</strong></span> status variable
        <code class="literal">Opened_tables</code>, which indicates the number of
        table-opening operations since the server started:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW GLOBAL STATUS LIKE 'Opened_tables';</code></strong>
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
</pre><p>
        If the value is very large or increases rapidly, even when you
        have not issued many <code class="literal">FLUSH TABLES</code> statements,
        you should increase the table cache size. See
        <a href="server-administration.html#server-system-variables" title="5.1.3. System Variables">Section 5.1.3, “System Variables”</a>, and
        <a href="server-administration.html#server-status-variables" title="5.1.6. Status Variables">Section 5.1.6, “Status Variables”</a>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="creating-many-tables"></a>7.4.9. Drawbacks to Creating Many Tables in the Same Database</h3></div></div></div><a class="indexterm" name="id2071827"></a><p>
        If you have many <code class="literal">MyISAM</code> tables in the same
        database directory, open, close, and create operations are slow.
        If you execute <code class="literal">SELECT</code> statements on many
        different tables, there is a little overhead when the table
        cache is full, because for every table that has to be opened,
        another must be closed. You can reduce this overhead by
        increasing the number of entries allowed in the table cache.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="optimizing-the-server"></a>7.5. Optimizing the MySQL Server</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#system-optimization">7.5.1. System Factors and Startup Parameter Tuning</a></span></dt><dt><span class="section"><a href="optimization.html#server-parameters">7.5.2. Tuning Server Parameters</a></span></dt><dt><span class="section"><a href="optimization.html#controlling-optimizer">7.5.3. Controlling Query Optimizer Performance</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache">7.5.4. The MySQL Query Cache</a></span></dt><dt><span class="section"><a href="optimization.html#thread-information">7.5.5. Examining Thread Information</a></span></dt><dt><span class="section"><a href="optimization.html#compile-and-link-options">7.5.6. How Compiling and Linking Affects the Speed of MySQL</a></span></dt><dt><span class="section"><a href="optimization.html#connection-threads">7.5.7. How MySQL Uses Threads for Client Connections</a></span></dt><dt><span class="section"><a href="optimization.html#memory-use">7.5.8. How MySQL Uses Memory</a></span></dt><dt><span class="section"><a href="optimization.html#internal-temporary-tables">7.5.9. How MySQL Uses Internal Temporary Tables</a></span></dt><dt><span class="section"><a href="optimization.html#dns">7.5.10. How MySQL Uses DNS</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="system-optimization"></a>7.5.1. System Factors and Startup Parameter Tuning</h3></div></div></div><a class="indexterm" name="id2071876"></a><a class="indexterm" name="id2071889"></a><a class="indexterm" name="id2071898"></a><p>
        We start with system-level factors, because some of these
        decisions must be made very early to achieve large performance
        gains. In other cases, a quick look at this section may suffice.
        However, it is always nice to have a sense of how much can be
        gained by changing factors that apply at this level.
      </p><p>
        The operating system to use is very important. To get the best
        use of multiple-CPU machines, you should use Solaris (because
        its threads implementation works well) or Linux (because the 2.4
        and later kernels have good SMP support). Note that older Linux
        kernels have a 2GB filesize limit by default. If you have such a
        kernel and a need for files larger than 2GB, you should get the
        Large File Support (LFS) patch for the ext2 filesystem. Other
        filesystems such as ReiserFS and XFS do not have this 2GB
        limitation.
      </p><p>
        Before using MySQL in production, we advise you to test it on
        your intended platform.
      </p><a class="indexterm" name="id2071929"></a><p>
        Other tips:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If you have enough RAM, you could remove all swap devices.
            Some operating systems use a swap device in some contexts
            even if you have free memory.
          </p></li><li><p>
            Avoid external locking. Since MySQL 4.0, the default has
            been for external locking to be disabled on all systems. The
            <code class="option">--external-locking</code> and
            <code class="option">--skip-external-locking</code> options explicitly
            enable and disable external locking.
          </p><p>
            Note that disabling external locking does not affect MySQL's
            functionality as long as you run only one server. Just
            remember to take down the server (or lock and flush the
            relevant tables) before you run
            <span><strong class="command">myisamchk</strong></span>. On some systems it is
            mandatory to disable external locking because it does not
            work, anyway.
          </p><p>
            The only case in which you cannot disable external locking
            is when you run multiple MySQL <span class="emphasis"><em>servers</em></span>
            (not clients) on the same data, or if you run
            <span><strong class="command">myisamchk</strong></span> to check (not repair) a table
            without telling the server to flush and lock the tables
            first. Note that using multiple MySQL servers to access the
            same data concurrently is generally <span class="emphasis"><em>not</em></span>
            recommended, except when using MySQL Cluster.
          </p><p>
            The <code class="literal">LOCK TABLES</code> and <code class="literal">UNLOCK
            TABLES</code> statements use internal locking, so you can
            use them even if external locking is disabled.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="server-parameters"></a>7.5.2. Tuning Server Parameters</h3></div></div></div><a class="indexterm" name="id2072027"></a><a class="indexterm" name="id2072039"></a><a class="indexterm" name="id2072051"></a><a class="indexterm" name="id2072064"></a><p>
        You can determine the default buffer sizes used by the
        <span><strong class="command">mysqld</strong></span> server using this command:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --verbose --help</code></strong>
</pre><a class="indexterm" name="id2072094"></a><a class="indexterm" name="id2072103"></a><p>
        This command produces a list of all <span><strong class="command">mysqld</strong></span>
        options and configurable system variables. The output includes
        the default variable values and looks something like this:
      </p><pre class="programlisting">help                              TRUE
abort-slave-event-count           0
allow-suspicious-udfs             FALSE
auto-increment-increment          1
auto-increment-offset             1
automatic-sp-privileges           TRUE
basedir                           /home/mysql/
bind-address                      (No default value)
character-set-client-handshake    TRUE
character-set-server              latin1
character-sets-dir                /home/mysql/share/mysql/charsets/
chroot                            (No default value)
collation-server                  latin1_swedish_ci
completion-type                   0
concurrent-insert                 1
console                           FALSE
datadir                           /home/mysql/var/
default-character-set             latin1
default-collation                 latin1_swedish_ci
default-time-zone                 (No default value)
disconnect-slave-event-count      0
enable-locking                    FALSE
enable-pstack                     FALSE
engine-condition-pushdown         TRUE
external-locking                  FALSE
gdb                               FALSE
large-pages                       FALSE
init-connect                      (No default value)
init-file                         (No default value)
init-slave                        (No default value)
innodb                            TRUE
innodb_checksums                  TRUE
innodb_data_home_dir              (No default value)
innodb_doublewrite                TRUE
innodb_fast_shutdown              1
innodb_file_per_table             FALSE
innodb_flush_log_at_trx_commit    1
innodb_flush_method               (No default value)
innodb_locks_unsafe_for_binlog    FALSE
innodb_log_group_home_dir         (No default value)
innodb_max_dirty_pages_pct        90
innodb_max_purge_lag              0
innodb_status_file                FALSE
innodb_table_locks                TRUE
innodb_support_xa                 TRUE
isam                              FALSE
language                          /home/mysql/share/mysql/english
local-infile                      TRUE
log                               /home/mysql/var/master1.log
log-bin                           /home/mysql/var/master1
log-bin-index                     (No default value)
log-bin-trust-routine-creators    FALSE
log-error                         /home/mysql/var/master1.err
log-isam                          myisam.log
log-queries-not-using-indexes     FALSE
log-short-format                  FALSE
log-slave-updates                 FALSE
log-slow-admin-statements         FALSE
log-slow-queries                  (No default value)
log-tc                            tc.log
log-tc-size                       24576
log-update                        (No default value)
log-warnings                      1
low-priority-updates              FALSE
master-connect-retry              60
master-host                       (No default value)
master-info-file                  master.info
master-password                   (No default value)
master-port                       3306
master-retry-count                86400
master-ssl                        FALSE
master-ssl-ca                     (No default value)
master-ssl-capath                 (No default value)
master-ssl-cert                   (No default value)
master-ssl-cipher                 (No default value)
master-ssl-key                    (No default value)
master-user                       test
max-binlog-dump-events            0
memlock                           FALSE
myisam-recover                    OFF
ndbcluster                        FALSE
ndb-connectstring                 (No default value)
ndb-mgmd-host                     (No default value)
ndb-nodeid                        0
ndb-autoincrement-prefetch-sz     32
ndb-distibution                   KEYHASH
ndb-force-send                    TRUE
ndb_force_send                    TRUE
ndb-use-exact-count               TRUE
ndb_use_exact_count               TRUE
ndb-shm                           FALSE
ndb-optimized-node-selection      TRUE
ndb-cache-check-time              0
ndb-index-stat-enable             TRUE
ndb-index-stat-cache-entries      32
ndb-index-stat-update-freq        20
new                               FALSE
old-alter-table                   FALSE
old-passwords                     FALSE
old-style-user-limits             FALSE
pid-file                          /home/mysql/var/hostname.pid1
port                              3306
relay-log                         (No default value)
relay-log-index                   (No default value)
relay-log-info-file               relay-log.info
replicate-same-server-id          FALSE
report-host                       (No default value)
report-password                   (No default value)
report-port                       3306
report-user                       (No default value)
rpl-recovery-rank                 0
safe-user-create                  FALSE
secure-auth                       FALSE
server-id                         1
show-slave-auth-info              FALSE
skip-grant-tables                 FALSE
skip-slave-start                  FALSE
slave-load-tmpdir                 /tmp/
socket                            /tmp/mysql.sock
sporadic-binlog-dump-fail         FALSE
sql-mode                          OFF
symbolic-links                    TRUE
tc-heuristic-recover              (No default value)
temp-pool                         TRUE
timed_mutexes                     FALSE
tmpdir                            (No default value)
use-symbolic-links                TRUE
verbose                           TRUE
warnings                          1
back_log                          50
binlog_cache_size                 32768
bulk_insert_buffer_size           8388608
connect_timeout                   5
date_format                       (No default value)
datetime_format                   (No default value)
default_week_format               0
delayed_insert_limit              100
delayed_insert_timeout            300
delayed_queue_size                1000
expire_logs_days                  0
flush_time                        0
ft_max_word_len                   84
ft_min_word_len                   4
ft_query_expansion_limit          20
ft_stopword_file                  (No default value)
group_concat_max_len              1024
innodb_additional_mem_pool_size   1048576
innodb_autoextend_increment       8
innodb_buffer_pool_size           8388608
innodb_concurrency_tickets        500
innodb_file_io_threads            4
innodb_force_recovery             0
innodb_lock_wait_timeout          50
innodb_log_buffer_size            1048576
innodb_log_file_size              5242880
innodb_log_files_in_group         2
innodb_mirrored_log_groups        1
innodb_open_files                 300
innodb_sync_spin_loops            20
innodb_thread_concurrency         20
innodb_commit_concurrency         0
innodb_thread_sleep_delay         10000
interactive_timeout               28800
join_buffer_size                  131072
key_buffer_size                   8388600
key_cache_age_threshold           300
key_cache_block_size              1024
key_cache_division_limit          100
long_query_time                   10
lower_case_table_names            0
max_allowed_packet                1048576
max_binlog_cache_size             4294967295
max_binlog_size                   1073741824
max_connect_errors                10
max_connections                   100
max_delayed_threads               20
max_error_count                   64
max_heap_table_size               16777216
max_join_size                     4294967295
max_length_for_sort_data          1024
max_relay_log_size                0
max_seeks_for_key                 4294967295
max_sort_length                   1024
max_tmp_tables                    32
max_user_connections              0
max_write_lock_count              4294967295
multi_range_count                 256
myisam_block_size                 1024
myisam_data_pointer_size          6
myisam_max_sort_file_size         2147483647
myisam_repair_threads             1
myisam_sort_buffer_size           8388608
myisam_stats_method               nulls_unequal
net_buffer_length                 16384
net_read_timeout                  30
net_retry_count                   10
net_write_timeout                 60
open_files_limit                  0
optimizer_prune_level             1
optimizer_search_depth            62
preload_buffer_size               32768
query_alloc_block_size            8192
query_cache_limit                 1048576
query_cache_min_res_unit          4096
query_cache_size                  0
query_cache_type                  1
query_cache_wlock_invalidate      FALSE
query_prealloc_size               8192
range_alloc_block_size            2048
read_buffer_size                  131072
read_only                         FALSE
read_rnd_buffer_size              262144
div_precision_increment           4
record_buffer                     131072
relay_log_purge                   TRUE
relay_log_space_limit             0
slave_compressed_protocol         FALSE
slave_net_timeout                 3600
slave_transaction_retries         10
slow_launch_time                  2
sort_buffer_size                  2097144
sync-binlog                       0
sync-frm                          TRUE
sync-replication                  0
sync-replication-slave-id         0
sync-replication-timeout          10
table_open_cache                  64
table_lock_wait_timeout           50
thread_cache_size                 0
thread_concurrency                10
thread_stack                      196608
time_format                       (No default value)
tmp_table_size                    33554432
transaction_alloc_block_size      8192
transaction_prealloc_size         4096
updatable_views_with_limit        1
wait_timeout                      28800
</pre><p>
        For a <span><strong class="command">mysqld</strong></span> server that is currently
        running, you can see the current values of its system variables
        by connecting to it and issuing this statement:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES;</code></strong>
</pre><p>
        You can also see some statistical and status indicators for a
        running server by issuing this statement:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS;</code></strong>
</pre><p>
        System variable and status information also can be obtained
        using <span><strong class="command">mysqladmin</strong></span>:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqladmin variables</code></strong>
shell&gt; <strong class="userinput"><code>mysqladmin extended-status</code></strong>
</pre><p>
        For a full description of all system and status variables, see
        <a href="server-administration.html#server-system-variables" title="5.1.3. System Variables">Section 5.1.3, “System Variables”</a>, and
        <a href="server-administration.html#server-status-variables" title="5.1.6. Status Variables">Section 5.1.6, “Status Variables”</a>.
      </p><p>
        MySQL uses algorithms that are very scalable, so you can usually
        run with very little memory. However, normally you get better
        performance by giving MySQL more memory.
      </p><p>
        When tuning a MySQL server, the two most important variables to
        configure are <code class="literal">key_buffer_size</code> and
        <code class="literal">table_open_cache</code>. You should first feel
        confident that you have these set appropriately before trying to
        change any other variables.
      </p><p>
        The following examples indicate some typical variable values for
        different runtime configurations.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If you have at least 256MB of memory and many tables and
            want maximum performance with a moderate number of clients,
            you should use something like this:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=64M --table_open_cache=256 \</code></strong>
           <strong class="userinput"><code>--sort_buffer_size=4M --read_buffer_size=1M &amp;</code></strong>
</pre></li><li><p>
            If you have only 128MB of memory and only a few tables, but
            you still do a lot of sorting, you can use something like
            this:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=16M --sort_buffer_size=1M</code></strong>
</pre><p>
            If there are very many simultaneous connections, swapping
            problems may occur unless <span><strong class="command">mysqld</strong></span> has been
            configured to use very little memory for each connection.
            <span><strong class="command">mysqld</strong></span> performs better if you have enough
            memory for all connections.
          </p></li><li><p>
            With little memory and lots of connections, use something
            like this:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=512K --sort_buffer_size=100K \</code></strong>
           <strong class="userinput"><code>--read_buffer_size=100K &amp;</code></strong>
</pre><p>
            Or even this:
          </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld_safe --key_buffer_size=512K --sort_buffer_size=16K \</code></strong>
           <strong class="userinput"><code>--table_open_cache=32 --read_buffer_size=8K \</code></strong>
           <strong class="userinput"><code>--net_buffer_length=1K &amp;</code></strong>
</pre></li></ul></div><p>
        If you are performing <code class="literal">GROUP BY</code> or
        <code class="literal">ORDER BY</code> operations on tables that are much
        larger than your available memory, you should increase the value
        of <code class="literal">read_rnd_buffer_size</code> to speed up the
        reading of rows following sorting operations.
      </p><p>
        You can make use of the example option files included with your
        MySQL distribution; see
        <a href="programs.html#option-files-preconfigured" title="4.2.3.2.2. Preconfigured Option Files">Section 4.2.3.2.2, “Preconfigured Option Files”</a>.
      </p><p>
        If you specify an option on the command line for
        <span><strong class="command">mysqld</strong></span> or <span><strong class="command">mysqld_safe</strong></span>, it
        remains in effect only for that invocation of the server. To use
        the option every time the server runs, put it in an option file.
      </p><p>
        To see the effects of a parameter change, do something like
        this:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --key_buffer_size=32M --verbose --help</code></strong>
</pre><p>
        The variable values are listed near the end of the output. Make
        sure that the <code class="option">--verbose</code> and
        <code class="option">--help</code> options are last. Otherwise, the effect
        of any options listed after them on the command line are not
        reflected in the output.
      </p><p>
        For information on tuning the <code class="literal">InnoDB</code> storage
        engine, see <a href="storage-engines.html#innodb-tuning" title="13.5.11. InnoDB Performance Tuning Tips">Section 13.5.11, “<code class="literal">InnoDB</code> Performance Tuning Tips”</a>.
      </p><p class="mnmas"><b>MySQL Enterprise</b>
          For expert advice on tuning system parameters subscribe to the
          MySQL Enterprise Monitor. For more information, see
          <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="controlling-optimizer"></a>7.5.3. Controlling Query Optimizer Performance</h3></div></div></div><a class="indexterm" name="id2072608"></a><p>
        The task of the query optimizer is to find an optimal plan for
        executing an SQL query. Because the difference in performance
        between “<span class="quote">good</span>” and “<span class="quote">bad</span>” plans can be
        orders of magnitude (that is, seconds versus hours or even
        days), most query optimizers, including that of MySQL, perform a
        more or less exhaustive search for an optimal plan among all
        possible query evaluation plans. For join queries, the number of
        possible plans investigated by the MySQL optimizer grows
        exponentially with the number of tables referenced in a query.
        For small numbers of tables (typically less than 7–10)
        this is not a problem. However, when larger queries are
        submitted, the time spent in query optimization may easily
        become the major bottleneck in the server's performance.
      </p><p>
        A more flexible method for query optimization allows the user to
        control how exhaustive the optimizer is in its search for an
        optimal query evaluation plan. The general idea is that the
        fewer plans that are investigated by the optimizer, the less
        time it spends in compiling a query. On the other hand, because
        the optimizer skips some plans, it may miss finding an optimal
        plan.
      </p><p>
        The behavior of the optimizer with respect to the number of
        plans it evaluates can be controlled via two system variables:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            The <code class="literal">optimizer_prune_level</code> variable tells
            the optimizer to skip certain plans based on estimates of
            the number of rows accessed for each table. Our experience
            shows that this kind of “<span class="quote">educated guess</span>” rarely
            misses optimal plans, and may dramatically reduce query
            compilation times. That is why this option is on
            (<code class="literal">optimizer_prune_level=1</code>) by default.
            However, if you believe that the optimizer missed a better
            query plan, this option can be switched off
            (<code class="literal">optimizer_prune_level=0</code>) with the risk
            that query compilation may take much longer. Note that, even
            with the use of this heuristic, the optimizer still explores
            a roughly exponential number of plans.
          </p></li><li><p>
            The <code class="literal">optimizer_search_depth</code> variable tells
            how far into the “<span class="quote">future</span>” of each incomplete
            plan the optimizer should look to evaluate whether it should
            be expanded further. Smaller values of
            <code class="literal">optimizer_search_depth</code> may result in
            orders of magnitude smaller query compilation times. For
            example, queries with 12, 13, or more tables may easily
            require hours and even days to compile if
            <code class="literal">optimizer_search_depth</code> is close to the
            number of tables in the query. At the same time, if compiled
            with <code class="literal">optimizer_search_depth</code> equal to 3 or
            4, the optimizer may compile in less than a minute for the
            same query. If you are unsure of what a reasonable value is
            for <code class="literal">optimizer_search_depth</code>, this variable
            can be set to 0 to tell the optimizer to determine the value
            automatically.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="query-cache"></a>7.5.4. The MySQL Query Cache</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#query-cache-how">7.5.4.1. How the Query Cache Operates</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-in-select">7.5.4.2. Query Cache <code class="literal">SELECT</code> Options</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-configuration">7.5.4.3. Query Cache Configuration</a></span></dt><dt><span class="section"><a href="optimization.html#query-cache-status-and-maintenance">7.5.4.4. Query Cache Status and Maintenance</a></span></dt></dl></div><a class="indexterm" name="id2072748"></a><a class="indexterm" name="id2072757"></a><p>
        The query cache stores the text of a <code class="literal">SELECT</code>
        statement together with the corresponding result that was sent
        to the client. If an identical statement is received later, the
        server retrieves the results from the query cache rather than
        parsing and executing the statement again.
      </p><p>
        The query cache is extremely useful in an environment where you
        have tables that do not change very often and for which the
        server receives many identical queries. This is a typical
        situation for many Web servers that generate many dynamic pages
        based on database content.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          The query cache does not return stale data. When tables are
          modified, any relevant entries in the query cache are flushed.
        </p><p>
          The query cache does not work in an environment where you have
          multiple <span><strong class="command">mysqld</strong></span> servers updating the same
          <code class="literal">MyISAM</code> tables.
        </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          The query cache is not used for server-side prepared
          statements before MySQL 5.1.17. If you are using server-side
          prepared statements, consider that these statements will not
          be satisfied by the query cache. As of 5.1.17, the query cache
          is used under the conditions described in
          <a href="optimization.html#query-cache-how" title="7.5.4.1. How the Query Cache Operates">Section 7.5.4.1, “How the Query Cache Operates”</a>.
        </p></div><p>
        Some performance data for the query cache follows. These results
        were generated by running the MySQL benchmark suite on a Linux
        Alpha 2×500MHz system with 2GB RAM and a 64MB query cache.
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If all the queries you are performing are simple (such as
            selecting a row from a table with one row), but still differ
            so that the queries cannot be cached, the overhead for
            having the query cache active is 13%. This could be regarded
            as the worst case scenario. In real life, queries tend to be
            much more complicated, so the overhead normally is
            significantly lower.
          </p></li><li><p>
            Searches for a single row in a single-row table are 238%
            faster with the query cache than without it. This can be
            regarded as close to the minimum speedup to be expected for
            a query that is cached.
          </p></li></ul></div><p>
        To disable the query cache at server startup, set the
        <code class="literal">query_cache_size</code> system variable to 0. By
        disabling the query cache code, there is no noticeable overhead.
        If you build MySQL from source, query cache capabilities can be
        excluded from the server entirely by invoking
        <span><strong class="command">configure</strong></span> with the
        <code class="option">--without-query-cache</code> option.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-how"></a>7.5.4.1. How the Query Cache Operates</h4></div></div></div><p>
          This section describes how the query cache works when it is
          operational. <a href="optimization.html#query-cache-configuration" title="7.5.4.3. Query Cache Configuration">Section 7.5.4.3, “Query Cache Configuration”</a>,
          describes how to control whether it is operational.
        </p><p>
          Incoming queries are compared to those in the query cache
          before parsing, so the following two queries are regarded as
          different by the query cache:
        </p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>tbl_name</code></em>
Select * from <em class="replaceable"><code>tbl_name</code></em>
</pre><p>
          Queries must be <span class="emphasis"><em>exactly</em></span> the same (byte
          for byte) to be seen as identical. In addition, query strings
          that are identical may be treated as different for other
          reasons. Queries that use different databases, different
          protocol versions, or different default character sets are
          considered different queries and are cached separately.
        </p><p>
          The cache is not used for queries of the following types:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              Queries that are a subquery of an outer query
            </p></li><li><p>
              Queries executed within the body of a stored function,
              trigger, or event
            </p></li></ul></div><p>
          Before a query result is fetched from the query cache, MySQL
          checks that the user has <code class="literal">SELECT</code> privilege
          for all databases and tables involved. If this is not the
          case, the cached result is not used.
        </p><p>
          If a query result is returned from query cache, the server
          increments the <code class="literal">Qcache_hits</code> status variable,
          not <code class="literal">Com_select</code>. See
          <a href="optimization.html#query-cache-status-and-maintenance" title="7.5.4.4. Query Cache Status and Maintenance">Section 7.5.4.4, “Query Cache Status and Maintenance”</a>.
        </p><p>
          If a table changes, all cached queries that use the table
          become invalid and are removed from the cache. This includes
          queries that use <code class="literal">MERGE</code> tables that map to
          the changed table. A table can be changed by many types of
          statements, such as <code class="literal">INSERT</code>,
          <code class="literal">UPDATE</code>, <code class="literal">DELETE</code>,
          <code class="literal">TRUNCATE</code>, <code class="literal">ALTER TABLE</code>,
          <code class="literal">DROP TABLE</code>, or <code class="literal">DROP
          DATABASE</code>.
        </p><p>
          The query cache also works within transactions when using
          <code class="literal">InnoDB</code> tables.
        </p><p>
          In MySQL 5.1, the results of a
          <code class="literal">SELECT</code> query on a view is cached.
        </p><p>
          The query cache works for <code class="literal">SELECT SQL_CALC_FOUND_ROWS
          ...</code> queries and stores a value that is returned by a
          following <code class="literal">SELECT FOUND_ROWS()</code> query.
          <a href="functions.html#function_found-rows"><code class="literal">FOUND_ROWS()</code></a> returns the
          correct value even if the preceding query was fetched from the
          cache because the number of found rows is also stored in the
          cache. The <code class="literal">SELECT FOUND_ROWS()</code> query itself
          cannot be cached.
        </p><p>
          Before MySQL 5.1.17, prepared statements do not use the query
          cache. Beginning with 5.1.17, prepared statements use the
          query cache under certain conditions, which differ depending
          on the preparation method:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              Statements that are issued via the binary protocol using
              <a href="apis.html#mysql-stmt-prepare" title="29.2.7.20. mysql_stmt_prepare()"><code class="literal">mysql_stmt_prepare()</code></a> and
              <a href="apis.html#mysql-stmt-execute" title="29.2.7.10. mysql_stmt_execute()"><code class="literal">mysql_stmt_execute()</code></a>. See
              <a href="apis.html#c-api-prepared-statements" title="29.2.4. C API Prepared Statements">Section 29.2.4, “C API Prepared Statements”</a>.
            </p><p>
              For a prepared statement executed via the binary protocol,
              comparison with statements in the query cache is based on
              the text of the statement after expansion of
              <code class="literal">?</code> parameter markers. The statement is
              compared only with other cached statements that were
              executed via the binary protocol. That is, for query cache
              purposes, statements issued via the binary protocol are
              distinct from statements issued via the text protocol.
            </p></li><li><p>
              Statements that are issued via the text (non-binary)
              protocol using <code class="literal">PREPARE</code> and
              <code class="literal">EXECUTE</code>. See
              <a href="sql-syntax.html#sql-syntax-prepared-statements" title="12.7. SQL Syntax for Prepared Statements">Section 12.7, “SQL Syntax for Prepared Statements”</a>. These
              are denoted SQL PS statements here.
            </p><p>
              Before MySQL 5.1.21, for a prepared statement executed via
              <code class="literal">PREPARE</code> and <code class="literal">EXECUTE</code>,
              it is not cached if it contains any <code class="literal">?</code>
              parameter markers. In that case, the statement after
              parameter expansion contains references to user variables,
              which prevents caching, even for non-prepared statements.
              If the statement contains no parameter markers, the
              statement is compared with statements in the query cache
              that were executed via the text protocol (that is, it is
              compared with other SQL PS statements and non-prepared
              statements). As of MySQL 5.1.21, this limitation is lifted
              and prepared statments that contain parameter markers can
              be cached because expansion directly substitutes the user
              variable values.
            </p></li></ul></div><p>
          A query cannot be cached if it contains any of the functions
          shown in the following table:
        </p><div class="informaltable"><table border="1"><colgroup><col><col><col></colgroup><tbody><tr><td><a href="functions.html#function_benchmark"><code class="literal">BENCHMARK()</code></a></td><td><a href="functions.html#function_connection-id"><code class="literal">CONNECTION_ID()</code></a></td><td><a href="functions.html#function_convert-tz"><code class="literal">CONVERT_TZ()</code></a></td></tr><tr><td><a href="functions.html#function_curdate"><code class="literal">CURDATE()</code></a></td><td><a href="functions.html#function_current-date"><code class="literal">CURRENT_DATE()</code></a></td><td><a href="functions.html#function_current-time"><code class="literal">CURRENT_TIME()</code></a></td></tr><tr><td><a href="functions.html#function_current-timestamp"><code class="literal">CURRENT_TIMESTAMP()</code></a></td><td><a href="functions.html#function_curtime"><code class="literal">CURTIME()</code></a></td><td><a href="functions.html#function_database"><code class="literal">DATABASE()</code></a></td></tr><tr><td><a href="functions.html#function_encrypt"><code class="literal">ENCRYPT()</code></a> with one parameter</td><td><a href="functions.html#function_found-rows"><code class="literal">FOUND_ROWS()</code></a></td><td><a href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a></td></tr><tr><td><a href="functions.html#function_last-insert-id"><code class="literal">LAST_INSERT_ID()</code></a></td><td><a href="functions.html#function_load-file"><code class="literal">LOAD_FILE()</code></a></td><td><a href="functions.html#function_master-pos-wait"><code class="literal">MASTER_POS_WAIT()</code></a></td></tr><tr><td><a href="functions.html#function_now"><code class="literal">NOW()</code></a></td><td><a href="functions.html#function_rand"><code class="literal">RAND()</code></a></td><td><a href="functions.html#function_release-lock"><code class="literal">RELEASE_LOCK()</code></a></td></tr><tr><td><a href="functions.html#function_sleep"><code class="literal">SLEEP()</code></a></td><td><a href="functions.html#function_sysdate"><code class="literal">SYSDATE()</code></a></td><td><a href="functions.html#function_unix-timestamp"><code class="literal">UNIX_TIMESTAMP()</code></a> with no parameters</td></tr><tr><td><a href="functions.html#function_user"><code class="literal">USER()</code></a></td><td><a href="functions.html#function_uuid"><code class="literal">UUID()</code></a></td><td><a href="functions.html#function_uuid-short"><code class="literal">UUID_SHORT()</code></a></td></tr></tbody></table></div><p>
          A query also is not cached under these conditions:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              It refers to user-defined functions (UDFs) or stored
              functions.
            </p></li><li><p>
              It refers to user variables or local stored routine
              variables.
            </p></li><li><p>
              It refers to tables in the <code class="literal">mysql</code> or
              <code class="literal">INFORMATION_SCHEMA</code> system database.
            </p></li><li><p>
              It is of any of the following forms:
            </p><pre class="programlisting">SELECT ... IN SHARE MODE
SELECT ... FOR UPDATE
SELECT ... INTO OUTFILE ...
SELECT ... INTO DUMPFILE ...
SELECT * FROM ... WHERE autoincrement_col IS NULL
</pre><p>
              The last form is not cached because it is used as the ODBC
              workaround for obtaining the last insert ID value. See the
              MyODBC section of <a href="connectors.html" title="Chapter 30. Connectors">Chapter 30, <i>Connectors</i></a>.
            </p></li><li><p>
              It uses <code class="literal">TEMPORARY</code> tables.
            </p></li><li><p>
              It does not use any tables.
            </p></li><li><p>
              It generates warnings.
            </p></li><li><p>
              The user has a column-level privilege for any of the
              involved tables.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-in-select"></a>7.5.4.2. Query Cache <code class="literal">SELECT</code> Options</h4></div></div></div><p>
          Two query cache-related options may be specified in
          <code class="literal">SELECT</code> statements:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2073560"></a>

              <a class="indexterm" name="id2073569"></a>

              <code class="literal">SQL_CACHE</code>
            </p><p>
              The query result is cached if it is cacheable and the
              value of the <code class="literal">query_cache_type</code> system
              variable is <code class="literal">ON</code> or
              <code class="literal">DEMAND</code>.
            </p></li><li><p>
              <code class="literal">SQL_NO_CACHE</code>
            </p><p>
              The query result is not cached.
            </p></li></ul></div><p>
          Examples:
        </p><pre class="programlisting">SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-configuration"></a>7.5.4.3. Query Cache Configuration</h4></div></div></div><p>
          The <code class="literal">have_query_cache</code> server system variable
          indicates whether the query cache is available:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'have_query_cache';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre><p>
          When using a standard MySQL binary, this value is always
          <code class="literal">YES</code>, even if query caching is disabled.
        </p><p>
          Several other system variables control query cache operation.
          These can be set in an option file or on the command line when
          starting <span><strong class="command">mysqld</strong></span>. The query cache system
          variables all have names that begin with
          <code class="literal">query_cache_</code>. They are described briefly in
          <a href="server-administration.html#server-system-variables" title="5.1.3. System Variables">Section 5.1.3, “System Variables”</a>, with additional
          configuration information given here.
        </p><p>
          To set the size of the query cache, set the
          <code class="literal">query_cache_size</code> system variable. Setting
          it to 0 disables the query cache. The default size is 0, so
          the query cache is disabled by default.
        </p><p class="mnmas"><b>MySQL Enterprise</b>
            For expert advice on configuring the query cache subscribe
            to the MySQL Enterprise Monitor. For more information, see
            <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            When using the Windows Configuration Wizard to install or
            configure MySQL, the default value for
            <code class="literal">query_cache_size</code> will be configured
            automatically for you based on the different configuration
            types available. When using the Windows Configuration
            Wizard, the query cache may be enabled (i.e. set to a
            non-zero value) due to the selected configuration. The query
            cache is also controlled by the setting of the
            <code class="literal">query_cache_type</code> variable. You should
            check the values of these variables as set in your
            <code class="filename">my.ini</code> file after configuration has
            taken place.
          </p></div><p>
          When you set <code class="literal">query_cache_size</code> to a non-zero
          value, keep in mind that the query cache needs a minimum size
          of about 40KB to allocate its structures. (The exact size
          depends on system architecture.) If you set the value too
          small, you'll get a warning, as in this example:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 40000;</code></strong>
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW WARNINGS\G</code></strong>
*************************** 1. row ***************************
  Level: Warning
   Code: 1282
Message: Query cache failed to set size 39936; »
         new query cache size is 0

mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 41984;</code></strong>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'query_cache_size';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_size | 41984 |
+------------------+-------+
</pre><p>
          For the query cache to actually be able to hold any query
          results, its size must be set larger:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET GLOBAL query_cache_size = 1000000;</code></strong>
Query OK, 0 rows affected (0.04 sec)

mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'query_cache_size';</code></strong>
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| query_cache_size | 999424 | 
+------------------+--------+
1 row in set (0.00 sec)
</pre><p>
          The <code class="literal">query_cache_size</code> is aligned to the
          nearest 1024 byte block. The value reported may therefore be
          different from the value that you set.
        </p><p>
          If the query cache size is greater than 0, the
          <code class="literal">query_cache_type</code> variable influences how it
          works. This variable can be set to the following values:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              A value of <code class="literal">0</code> or <code class="literal">OFF</code>
              prevents caching or retrieval of cached results.
            </p></li><li><p>
              A value of <code class="literal">1</code> or <code class="literal">ON</code>
              allows caching except of those statements that begin with
              <code class="literal">SELECT SQL_NO_CACHE</code>.
            </p></li><li><p>
              A value of <code class="literal">2</code> or
              <code class="literal">DEMAND</code> causes caching of only those
              statements that begin with <code class="literal">SELECT
              SQL_CACHE</code>.
            </p></li></ul></div><p>
          Setting the <code class="literal">GLOBAL</code>
          <code class="literal">query_cache_type</code> value determines query
          cache behavior for all clients that connect after the change
          is made. Individual clients can control cache behavior for
          their own connection by setting the <code class="literal">SESSION</code>
          <code class="literal">query_cache_type</code> value. For example, a
          client can disable use of the query cache for its own queries
          like this:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SET SESSION query_cache_type = OFF;</code></strong>
</pre><p>
          To control the maximum size of individual query results that
          can be cached, set the <code class="literal">query_cache_limit</code>
          system variable. The default value is 1MB.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            You can set the maximum size that can be specified for the
            query cache during runtine with the <code class="literal">SET</code>
            statement by using the
            <code class="literal">--maximum-query_cache_size=<em class="replaceable"><code>32M</code></em></code>
            option on the command line or in the configuration file.
          </p></div><p>
          When a query is to be cached, its result (the data sent to the
          client) is stored in the query cache during result retrieval.
          Therefore the data usually is not handled in one big chunk.
          The query cache allocates blocks for storing this data on
          demand, so when one block is filled, a new block is allocated.
          Because memory allocation operation is costly (timewise), the
          query cache allocates blocks with a minimum size given by the
          <code class="literal">query_cache_min_res_unit</code> system variable.
          When a query is executed, the last result block is trimmed to
          the actual data size so that unused memory is freed. Depending
          on the types of queries your server executes, you might find
          it helpful to tune the value of
          <code class="literal">query_cache_min_res_unit</code>:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              The default value of
              <code class="literal">query_cache_min_res_unit</code> is 4KB. This
              should be adequate for most cases.
            </p></li><li><p>
              If you have a lot of queries with small results, the
              default block size may lead to memory fragmentation, as
              indicated by a large number of free blocks. Fragmentation
              can force the query cache to prune (delete) queries from
              the cache due to lack of memory. In this case, you should
              decrease the value of
              <code class="literal">query_cache_min_res_unit</code>. The number of
              free blocks and queries removed due to pruning are given
              by the values of the <code class="literal">Qcache_free_blocks</code>
              and <code class="literal">Qcache_lowmem_prunes</code> status
              variables.
            </p></li><li><p>
              If most of your queries have large results (check the
              <code class="literal">Qcache_total_blocks</code> and
              <code class="literal">Qcache_queries_in_cache</code> status
              variables), you can increase performance by increasing
              <code class="literal">query_cache_min_res_unit</code>. However, be
              careful to not make it too large (see the previous item).
            </p></li></ul></div><p class="mnmas"><b>MySQL Enterprise</b>
            If the query cache is under-utilized, performance will
            suffer. Advice on avoiding this problem is provided to
            subscribers to the MySQL Enterprise Monitor. For more
            information see
            <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
          </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="query-cache-status-and-maintenance"></a>7.5.4.4. Query Cache Status and Maintenance</h4></div></div></div><p>
          You can check whether the query cache is present in your MySQL
          server using the following statement:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'have_query_cache';</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre><p>
          You can defragment the query cache to better utilize its
          memory with the <code class="literal">FLUSH QUERY CACHE</code>
          statement. The statement does not remove any queries from the
          cache.
        </p><p>
          The <code class="literal">RESET QUERY CACHE</code> statement removes all
          query results from the query cache. The <code class="literal">FLUSH
          TABLES</code> statement also does this.
        </p><p>
          To monitor query cache performance, use <code class="literal">SHOW
          STATUS</code> to view the cache status variables:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'Qcache%';</code></strong>
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Qcache_free_blocks      | 36     |
| Qcache_free_memory      | 138488 |
| Qcache_hits             | 79570  |
| Qcache_inserts          | 27087  |
| Qcache_lowmem_prunes    | 3114   |
| Qcache_not_cached       | 22989  |
| Qcache_queries_in_cache | 415    |
| Qcache_total_blocks     | 912    |
+-------------------------+--------+
</pre><p>
          Descriptions of each of these variables are given in
          <a href="server-administration.html#server-status-variables" title="5.1.6. Status Variables">Section 5.1.6, “Status Variables”</a>. Some uses for them
          are described here.
        </p><p>
          The total number of <code class="literal">SELECT</code> queries is given
          by this formula:
        </p><pre class="programlisting">  Com_select
+ Qcache_hits
+ queries with errors found by parser
</pre><p>
          The <code class="literal">Com_select</code> value is given by this
          formula:
        </p><pre class="programlisting">  Qcache_inserts
+ Qcache_not_cached
+ queries with errors found during the column-privileges check
</pre><p>
          The query cache uses variable-length blocks, so
          <code class="literal">Qcache_total_blocks</code> and
          <code class="literal">Qcache_free_blocks</code> may indicate query cache
          memory fragmentation. After <code class="literal">FLUSH QUERY
          CACHE</code>, only a single free block remains.
        </p><p>
          Every cached query requires a minimum of two blocks (one for
          the query text and one or more for the query results). Also,
          every table that is used by a query requires one block.
          However, if two or more queries use the same table, only one
          table block needs to be allocated.
        </p><p>
          The information provided by the
          <code class="literal">Qcache_lowmem_prunes</code> status variable can
          help you tune the query cache size. It counts the number of
          queries that have been removed from the cache to free up
          memory for caching new queries. The query cache uses a least
          recently used (LRU) strategy to decide which queries to remove
          from the cache. Tuning information is given in
          <a href="optimization.html#query-cache-configuration" title="7.5.4.3. Query Cache Configuration">Section 7.5.4.3, “Query Cache Configuration”</a>.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="thread-information"></a>7.5.5. Examining Thread Information</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#thread-commands">7.5.5.1. Thread Command Values</a></span></dt><dt><span class="section"><a href="optimization.html#general-thread-states">7.5.5.2. General Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#delayed-insert-thread-states">7.5.5.3. Delayed-Insert Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#master-thread-states">7.5.5.4. Replication Master Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-io-thread-states">7.5.5.5. Replication Slave I/O Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-sql-thread-states">7.5.5.6. Replication Slave SQL Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#slave-connection-thread-states">7.5.5.7. Replication Slave Connection Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#mysql-cluster-thread-states">7.5.5.8. MySQL Cluster Thread States</a></span></dt><dt><span class="section"><a href="optimization.html#event-scheduler-thread-states">7.5.5.9. Event Scheduler Thread States</a></span></dt></dl></div><p>
        When you are attempting to ascertain what your MySQL server is
        doing, it can be helpful to examine the process list, which is
        the set of threads currently executing within the server.
        Process list information is available from these sources:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            The <code class="literal">SHOW [FULL] PROCESSLIST</code> statement
            (<a href="sql-syntax.html#show-processlist" title="12.5.5.28. SHOW PROCESSLIST Syntax">Section 12.5.5.28, “<code class="literal">SHOW PROCESSLIST</code> Syntax”</a>)
          </p></li><li><p>
            The <code class="literal">INFORMATION_SCHEMA</code>
            <code class="literal">PROCESSLIST</code> table
            (<a href="information-schema.html#processlist-table" title="27.22. The INFORMATION_SCHEMA PROCESSLIST Table">Section 27.22, “The <code class="literal">INFORMATION_SCHEMA PROCESSLIST</code> Table”</a>)
          </p></li><li><p>
            The <span><strong class="command">myqladmin processlist</strong></span> command
            (<a href="programs.html#mysqladmin" title="4.5.2. mysqladmin — Client for Administering a MySQL Server">Section 4.5.2, “<span><strong class="command">mysqladmin</strong></span> — Client for Administering a MySQL Server”</a>)
          </p></li></ul></div><p>
        You can always view information about your own threads. To view
        information about threads being executed for other accounts, you
        must have the <code class="literal">PROCESS</code> privilege.
      </p><p>
        Each process list entry contains several pieces of information:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">Id</code> is the connection identifier for the
            client associated with the thread.
          </p></li><li><p>
            <code class="literal">User</code> and <code class="literal">Host</code> indicate
            the account associated with the thread.
          </p></li><li><p>
            <code class="literal">db</code> is the default database for the
            thread, or <code class="literal">NULL</code> if none is selected.
          </p></li><li><p>
            <code class="literal">Command</code> and <code class="literal">State</code>
            indicate what the thread is doing.
          </p><p>
            Most states correspond to very quick operations. If a thread
            stays in a given state for many seconds, there might be a
            problem that needs to be investigated.
          </p></li><li><p>
            <code class="literal">Time</code> indicates how long the thread has
            been in its current state.
          </p></li><li><p>
            <code class="literal">Info</code> contains the text of the statement
            being executed by the thread, or <code class="literal">NULL</code> if
            it is not executing one. By default, this value contains
            only the first 100 characters of the statement. To see the
            complete statements, use <code class="literal">SHOW FULL
            PROCESSLIST</code>.
          </p></li></ul></div><p>
        The following sections list the possible
        <code class="literal">Command</code> values, and <code class="literal">State</code>
        values grouped by category. The meaning for some of these values
        is self-evident. For others, additional description is provided.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="thread-commands"></a>7.5.5.1. Thread Command Values</h4></div></div></div><a class="indexterm" name="id2074540"></a><p>
          A thread can have any of the following
          <code class="literal">Command</code> values:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2074565"></a>

              <a class="indexterm" name="id2074577"></a>

              <code class="literal">Binlog Dump</code>
            </p><p>
              This is a thread on a master server for sending binary log
              contents to a slave server.
            </p></li><li><p>
              <a class="indexterm" name="id2074606"></a>

              <a class="indexterm" name="id2074619"></a>

              <code class="literal">Change user</code>
            </p><p>
              The thread is executing a change-user operation.
            </p></li><li><p>
              <a class="indexterm" name="id2074647"></a>

              <a class="indexterm" name="id2074660"></a>

              <code class="literal">Close stmt</code>
            </p><p>
              The thread is closing a prepared statement.
            </p></li><li><p>
              <a class="indexterm" name="id2074688"></a>

              <a class="indexterm" name="id2074700"></a>

              <code class="literal">Connect</code>
            </p><p>
              A replication slave is connected to its master.
            </p></li><li><p>
              <a class="indexterm" name="id2074729"></a>

              <a class="indexterm" name="id2074741"></a>

              <code class="literal">Connect Out</code>
            </p><p>
              A replication slave is connecting to its master.
            </p></li><li><p>
              <a class="indexterm" name="id2074770"></a>

              <a class="indexterm" name="id2074782"></a>

              <code class="literal">Create DB</code>
            </p><p>
              The thread is executing a create-database operation.
            </p></li><li><p>
              <a class="indexterm" name="id2074811"></a>

              <a class="indexterm" name="id2074823"></a>

              <code class="literal">Daemon</code>
            </p><p>
              This thread is internal to the server, not a thread that
              services a client connection.
            </p></li><li><p>
              <a class="indexterm" name="id2074852"></a>

              <a class="indexterm" name="id2074865"></a>

              <code class="literal">Debug</code>
            </p><p>
              The thread is generating debugging information.
            </p></li><li><p>
              <a class="indexterm" name="id2074893"></a>

              <a class="indexterm" name="id2074906"></a>

              <code class="literal">Delayed insert</code>
            </p><p>
              The thread is a delayed-insert handler.
            </p></li><li><p>
              <a class="indexterm" name="id2074934"></a>

              <a class="indexterm" name="id2074946"></a>

              <code class="literal">Drop DB</code>
            </p><p>
              The thread is executing a drop-database operation.
            </p></li><li><p>
              <a class="indexterm" name="id2074975"></a>

              <a class="indexterm" name="id2074987"></a>

              <code class="literal">Error</code>
            </p></li><li><p>
              <a class="indexterm" name="id2075012"></a>

              <a class="indexterm" name="id2075024"></a>

              <code class="literal">Execute</code>
            </p><p>
              The thread is executing a prepared statement.
            </p></li><li><p>
              <a class="indexterm" name="id2075053"></a>

              <a class="indexterm" name="id2075065"></a>

              <code class="literal">Fetch</code>
            </p><p>
              The thread is fetching the results from executing a
              prepared statement.
            </p></li><li><p>
              <a class="indexterm" name="id2075094"></a>

              <a class="indexterm" name="id2075106"></a>

              <code class="literal">Field List</code>
            </p><p>
              The thread is retrieving information for table columns.
            </p></li><li><p>
              <a class="indexterm" name="id2075135"></a>

              <a class="indexterm" name="id2075147"></a>

              <code class="literal">Init DB</code>
            </p><p>
              The thread is selecting a default database.
            </p></li><li><p>
              <a class="indexterm" name="id2075176"></a>

              <a class="indexterm" name="id2075188"></a>

              <code class="literal">Kill</code>
            </p><p>
              The thread is killing another thread.
            </p></li><li><p>
              <a class="indexterm" name="id2075216"></a>

              <a class="indexterm" name="id2075229"></a>

              <code class="literal">Long Data</code>
            </p><p>
              The thread is retrieving long data in the result of
              executing a prepared statement.
            </p></li><li><p>
              <a class="indexterm" name="id2075258"></a>

              <a class="indexterm" name="id2075270"></a>

              <code class="literal">Ping</code>
            </p><p>
              The thread is handling a server-ping request.
            </p></li><li><p>
              <a class="indexterm" name="id2075299"></a>

              <a class="indexterm" name="id2075311"></a>

              <code class="literal">Prepare</code>
            </p><p>
              The thread is preparing a prepared statement.
            </p></li><li><p>
              <a class="indexterm" name="id2075340"></a>

              <a class="indexterm" name="id2075352"></a>

              <code class="literal">Processlist</code>
            </p><p>
              The thread is producing information about server threads.
            </p></li><li><p>
              <a class="indexterm" name="id2075381"></a>

              <a class="indexterm" name="id2075393"></a>

              <code class="literal">Query</code>
            </p><p>
              The thread is executing a statement.
            </p></li><li><p>
              <a class="indexterm" name="id2075421"></a>

              <a class="indexterm" name="id2075434"></a>

              <code class="literal">Quit</code>
            </p><p>
              The thread is terminating.
            </p></li><li><p>
              <a class="indexterm" name="id2075462"></a>

              <a class="indexterm" name="id2075474"></a>

              <code class="literal">Refresh</code>
            </p><p>
              The thread is flushing table, logs, or caches, or
              resetting status variable or replication server
              information.
            </p></li><li><p>
              <a class="indexterm" name="id2075504"></a>

              <a class="indexterm" name="id2075516"></a>

              <code class="literal">Register Slave</code>
            </p><p>
              The thread is registering a slave server.
            </p></li><li><p>
              <a class="indexterm" name="id2075544"></a>

              <a class="indexterm" name="id2075557"></a>

              <code class="literal">Reset stmt</code>
            </p><p>
              The thread is resetting a prepared statement.
            </p></li><li><p>
              <a class="indexterm" name="id2075585"></a>

              <a class="indexterm" name="id2075598"></a>

              <code class="literal">Set option</code>
            </p><p>
              The thread is setting or resetting a client
              statement-execution option.
            </p></li><li><p>
              <a class="indexterm" name="id2075627"></a>

              <a class="indexterm" name="id2075639"></a>

              <code class="literal">Shutdown</code>
            </p><p>
              The thread is shutting down the server.
            </p></li><li><p>
              <a class="indexterm" name="id2075667"></a>

              <a class="indexterm" name="id2075680"></a>

              <code class="literal">Sleep</code>
            </p><p>
              The thread is waiting for the client to send a new
              statement to it.
            </p></li><li><p>
              <a class="indexterm" name="id2075709"></a>

              <a class="indexterm" name="id2075721"></a>

              <code class="literal">Statistics</code>
            </p><p>
              The thread is producing server-status information.
            </p></li><li><p>
              <a class="indexterm" name="id2075750"></a>

              <a class="indexterm" name="id2075762"></a>

              <code class="literal">Table Dump</code>
            </p><p>
              The thread is sending table contents to a slave server.
            </p></li><li><p>
              <a class="indexterm" name="id2075790"></a>

              <a class="indexterm" name="id2075803"></a>

              <code class="literal">Time</code>
            </p><p>
              Unused.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="general-thread-states"></a>7.5.5.2. General Thread States</h4></div></div></div><a class="indexterm" name="id2075837"></a><p>
          The following list describes thread <code class="literal">State</code>
          values that are associated with general query processing and
          not more specialized activities such as replication. Many of
          these are useful only for finding bugs in the server.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2075867"></a>

              <a class="indexterm" name="id2075879"></a>

              <code class="literal">After create</code>
            </p><p>
              Occurs when the thread creates a table (including internal
              temporary tables), at the end of the function that creates
              the table. This state is used even if the table could not
              be created due to some error.
            </p></li><li><p>
              <a class="indexterm" name="id2075909"></a>

              <a class="indexterm" name="id2075922"></a>

              <code class="literal">Analyzing</code>
            </p><p>
              The thread is calculating a <code class="literal">MyISAM</code>
              table key distributions (for example, for <code class="literal">ANALYZE
              TABLE</code>).
            </p></li><li><p>
              <a class="indexterm" name="id2075963"></a>

              <a class="indexterm" name="id2075975"></a>

              <code class="literal">Checking table</code>
            </p><p>
              The thread is performing a table check operation.
            </p></li><li><p>
              <a class="indexterm" name="id2076004"></a>

              <a class="indexterm" name="id2076016"></a>

              <code class="literal">cleaning up</code>
            </p><p>
              The thread has processed one command and is preparing to
              free memory and reset certain state variables.
            </p></li><li><p>
              <a class="indexterm" name="id2076045"></a>

              <a class="indexterm" name="id2076057"></a>

              <code class="literal">closing tables</code>
            </p><p>
              Means that the thread is flushing the changed table data
              to disk and closing the used tables. This should be a fast
              operation. If not, you should verify that you do not have
              a full disk and that the disk is not in very heavy use.
            </p></li><li><p>
              <a class="indexterm" name="id2076088"></a>

              <a class="indexterm" name="id2076100"></a>

              <code class="literal">converting HEAP to MyISAM</code>
            </p><p>
              The thread is converting an internal temporary table from
              a <code class="literal">MEMORY</code> table to an on-disk
              <code class="literal">MyISAM</code> table.
            </p></li><li><p>
              <a class="indexterm" name="id2076141"></a>

              <a class="indexterm" name="id2076154"></a>

              <code class="literal">copy to tmp table</code>
            </p><p>
              The thread is processing an <code class="literal">ALTER TABLE</code>
              statement. This state occurs after the table with the new
              structure has been created but before rows are copied into
              it.
            </p></li><li><p>
              <a class="indexterm" name="id2076189"></a>

              <a class="indexterm" name="id2076202"></a>

              <code class="literal">Copying to group table</code>
            </p><p>
              If a statement has different <code class="literal">ORDER BY</code>
              and <code class="literal">GROUP BY</code> criteria, the rows are
              sorted by group and copied to a temporary table.
            </p></li><li><p>
              <a class="indexterm" name="id2076243"></a>

              <a class="indexterm" name="id2076255"></a>

              <code class="literal">Copying to tmp table</code>
            </p><p>
              The server is copying to a temporary table in memory.
            </p></li><li><p>
              <a class="indexterm" name="id2076284"></a>

              <a class="indexterm" name="id2076296"></a>

              <code class="literal">Copying to tmp table on disk</code>
            </p><p>
              The server is copying to a temporary table on disk. The
              temporary result set was larger than
              <code class="literal">tmp_table_size</code> and the thread is
              changing the temporary table from in-memory to disk-based
              format to save memory.
            </p></li><li><p>
              <a class="indexterm" name="id2076333"></a>

              <a class="indexterm" name="id2076345"></a>

              <code class="literal">Creating index</code>
            </p><p>
              The thread is processing <code class="literal">ALTER TABLE ... ENABLE
              KEYS</code> for a <code class="literal">MyISAM</code> table.
            </p></li><li><p>
              <a class="indexterm" name="id2076386"></a>

              <a class="indexterm" name="id2076398"></a>

              <code class="literal">Creating sort index</code>
            </p><p>
              The thread is processing a <code class="literal">SELECT</code> that
              is resolved using an internal temporary table.
            </p></li><li><p>
              <a class="indexterm" name="id2076433"></a>

              <a class="indexterm" name="id2076445"></a>

              <code class="literal">creating table</code>
            </p><p>
              The thread is creating a table. This includes creation of
              temporary tables.
            </p></li><li><p>
              <a class="indexterm" name="id2076474"></a>

              <a class="indexterm" name="id2076486"></a>

              <code class="literal">Creating tmp table</code>
            </p><p>
              The thread is creating a temporary table in memory or on
              disk. If the table is created in memory but later is
              converted to an on-disk table, the state during that
              operation will be <code class="literal">Copying to tmp table on
              disk</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2076522"></a>

              <a class="indexterm" name="id2076535"></a>

              <code class="literal">deleting from main table</code>
            </p><p>
              The server is executing the first part of a multiple-table
              delete. It is deleting only from the first table, and
              saving fields and offsets to be used for deleting from the
              other (reference) tables.
            </p></li><li><p>
              <a class="indexterm" name="id2076565"></a>

              <a class="indexterm" name="id2076578"></a>

              <code class="literal">deleting from reference tables</code>
            </p><p>
              The server is executing the second part of a
              multiple-table delete and deleting the matched rows from
              the other tables.
            </p></li><li><p>
              <a class="indexterm" name="id2076608"></a>

              <a class="indexterm" name="id2076620"></a>

              <code class="literal">discard_or_import_tablespace</code>
            </p><p>
              The thread is processing an <code class="literal">ALTER TABLE ...
              DISCARD TABLESPACE</code> or <code class="literal">ALTER TABLE ...
              IMPORT TABLESPACE</code> statement.
            </p></li><li><p>
              <a class="indexterm" name="id2076661"></a>

              <a class="indexterm" name="id2076673"></a>

              <code class="literal">end</code>
            </p><p>
              This occurs at the end but before the cleanup of
              <code class="literal">ALTER TABLE</code>, <code class="literal">CREATE
              VIEW</code>, <code class="literal">DELETE</code>,
              <code class="literal">INSERT</code>, <code class="literal">SELECT</code>, or
              <code class="literal">UPDATE</code> statements.
            </p></li><li><p>
              <a class="indexterm" name="id2076737"></a>

              <a class="indexterm" name="id2076749"></a>

              <code class="literal">Execution of init_command</code>
            </p><p>
              The thread is executing statements in the value of the
              <code class="literal">init_command</code> system variable.
            </p></li><li><p>
              <a class="indexterm" name="id2076784"></a>

              <a class="indexterm" name="id2076797"></a>

              <code class="literal">freeing items</code>
            </p><p>
              The thread has executed a command. This state is usually
              followed by <code class="literal">cleaning up</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2076831"></a>

              <a class="indexterm" name="id2076844"></a>

              <code class="literal">Flushing tables</code>
            </p><p>
              The thread is executing <code class="literal">FLUSH TABLES</code>
              and is waiting for all threads to close their tables.
            </p></li><li><p>
              <a class="indexterm" name="id2076878"></a>

              <a class="indexterm" name="id2076891"></a>

              <code class="literal">FULLTEXT initialization</code>
            </p><p>
              The server is preparing to perform a natural-language
              full-text search.
            </p></li><li><p>
              <a class="indexterm" name="id2076920"></a>

              <a class="indexterm" name="id2076932"></a>

              <code class="literal">init</code>
            </p><p>
              This occurs before the initialization of <code class="literal">ALTER
              TABLE</code>, <code class="literal">DELETE</code>,
              <code class="literal">INSERT</code>, <code class="literal">SELECT</code>, or
              <code class="literal">UPDATE</code> statements.
            </p></li><li><p>
              <a class="indexterm" name="id2076990"></a>

              <a class="indexterm" name="id2077003"></a>

              <code class="literal">Killed</code>
            </p><p>
              Someone has sent a <code class="literal">KILL</code> statement to
              the thread and it should abort next time it checks the
              kill flag. The flag is checked in each major loop in
              MySQL, but in some cases it might still take a short time
              for the thread to die. If the thread is locked by some
              other thread, the kill takes effect as soon as the other
              thread releases its lock.
            </p></li><li><p>
              <a class="indexterm" name="id2077040"></a>

              <a class="indexterm" name="id2077052"></a>

              <code class="literal">Locked</code>
            </p><p>
              The query is locked by another query.
            </p></li><li><p>
              <a class="indexterm" name="id2077081"></a>

              <a class="indexterm" name="id2077093"></a>

              <code class="literal">logging slow query</code>
            </p><p>
              The thread is writing a statement to the slow-query log.
            </p></li><li><p>
              <a class="indexterm" name="id2077122"></a>

              <a class="indexterm" name="id2077134"></a>

              <code class="literal">login</code>
            </p><p>
              The initial state for a connection thread until the client
              has been authenticated successfully.
            </p></li><li><p>
              <a class="indexterm" name="id2077163"></a>

              <a class="indexterm" name="id2077176"></a>

              <a class="indexterm" name="id2077188"></a>

              <a class="indexterm" name="id2077200"></a>

              <code class="literal">Opening tables</code>, <code class="literal">Opening
              table</code>
            </p><p>
              The thread is trying to open a table. This is should be
              very fast procedure, unless something prevents opening.
              For example, an <code class="literal">ALTER TABLE</code> or a
              <code class="literal">LOCK TABLE</code> statement can prevent
              opening a table until the statement is finished.
            </p></li><li><p>
              <a class="indexterm" name="id2077248"></a>

              <a class="indexterm" name="id2077261"></a>

              <code class="literal">preparing</code>
            </p><p>
              This state occurs during query optimization.
            </p></li><li><p>
              <a class="indexterm" name="id2077289"></a>

              <a class="indexterm" name="id2077302"></a>

              <code class="literal">Purging old relay logs</code>
            </p><p>
              The thread is removing unneeded relay log files.
            </p></li><li><p>
              <a class="indexterm" name="id2077330"></a>

              <a class="indexterm" name="id2077343"></a>

              <code class="literal">query end</code>
            </p><p>
              This state occurs after processing a query but before the
              <code class="literal">freeing items</code> state.
            </p></li><li><p>
              <a class="indexterm" name="id2077377"></a>

              <a class="indexterm" name="id2077390"></a>

              <code class="literal">Reading from net</code>
            </p><p>
              The server is reading a packet from the network.
            </p></li><li><p>
              <a class="indexterm" name="id2077418"></a>

              <a class="indexterm" name="id2077430"></a>

              <code class="literal">Removing duplicates</code>
            </p><p>
              The query was using <code class="literal">SELECT DISTINCT</code> in
              such a way that MySQL could not optimize away the distinct
              operation at an early stage. Because of this, MySQL
              requires an extra stage to remove all duplicated rows
              before sending the result to the client.
            </p></li><li><p>
              <a class="indexterm" name="id2077467"></a>

              <a class="indexterm" name="id2077479"></a>

              <code class="literal">removing tmp table</code>
            </p><p>
              The thread is removing an internal temporary table after
              processing a <code class="literal">SELECT</code> statement. This
              state is not used if no temporary table was created.
            </p></li><li><p>
              <a class="indexterm" name="id2077514"></a>

              <a class="indexterm" name="id2077527"></a>

              <code class="literal">rename</code>
            </p><p>
              The thread is renaming a table.
            </p></li><li><p>
              <a class="indexterm" name="id2077555"></a>

              <a class="indexterm" name="id2077568"></a>

              <code class="literal">rename result table</code>
            </p><p>
              The thread is processing an <code class="literal">ALTER TABLE</code>
              statement, has created the new table, and is renaming it
              to replace the original table.
            </p></li><li><p>
              <a class="indexterm" name="id2077603"></a>

              <a class="indexterm" name="id2077615"></a>

              <code class="literal">Reopen tables</code>
            </p><p>
              The thread got a lock for the table, but noticed after
              getting the lock that the underlying table structure
              changed. It has freed the lock, closed the table, and is
              trying to reopen it.
            </p></li><li><p>
              <a class="indexterm" name="id2077645"></a>

              <a class="indexterm" name="id2077658"></a>

              <code class="literal">Repair by sorting</code>
            </p><p>
              The repair code is using a sort to create indexes.
            </p></li><li><p>
              <a class="indexterm" name="id2077686"></a>

              <a class="indexterm" name="id2077699"></a>

              <code class="literal">Repair done</code>
            </p><p>
              The thread has completed a multi-threaded repair for a
              <code class="literal">MyISAM</code> table.
            </p></li><li><p>
              <a class="indexterm" name="id2077733"></a>

              <a class="indexterm" name="id2077746"></a>

              <code class="literal">Repair with keycache</code>
            </p><p>
              The repair code is using creating keys one by one through
              the key cache. This is much slower than <code class="literal">Repair by
              sorting</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2077781"></a>

              <a class="indexterm" name="id2077793"></a>

              <code class="literal">Rolling back</code>
            </p><p>
              The thread is rolling back a transaction.
            </p></li><li><p>
              <a class="indexterm" name="id2077821"></a>

              <a class="indexterm" name="id2077834"></a>

              <code class="literal">Saving state</code>
            </p><p>
              For <code class="literal">MyISAM</code> table operations such as
              repair or analysis, the thread is saving the new table
              state to the <code class="filename">.MYI</code> file header. State
              includes information such as number of rows, the
              <code class="literal">AUTO_INCREMENT</code> counter, and key
              distributions.
            </p></li><li><p>
              <a class="indexterm" name="id2077882"></a>

              <a class="indexterm" name="id2077894"></a>

              <code class="literal">Searching rows for update</code>
            </p><p>
              The thread is doing a first phase to find all matching
              rows before updating them. This has to be done if the
              <code class="literal">UPDATE</code> is changing the index that is
              used to find the involved rows.
            </p></li><li><p>
              <code class="literal">Sending data</code>
            </p><p>
              The thread is processing rows for a
              <code class="literal">SELECT</code> statement and also is sending
              data to the client.
            </p></li><li><p>
              <a class="indexterm" name="id2077953"></a>

              <a class="indexterm" name="id2077965"></a>

              <code class="literal">setup</code>
            </p><p>
              The thread is beginning an <code class="literal">ALTER TABLE</code>
              operation.
            </p></li><li><p>
              <a class="indexterm" name="id2078000"></a>

              <a class="indexterm" name="id2078012"></a>

              <code class="literal">Sorting for group</code>
            </p><p>
              The thread is doing a sort to satisfy a <code class="literal">GROUP
              BY</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2078046"></a>

              <a class="indexterm" name="id2078059"></a>

              <code class="literal">Sorting for order</code>
            </p><p>
              The thread is doing a sort to satisfy a <code class="literal">ORDER
              BY</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2078093"></a>

              <a class="indexterm" name="id2078106"></a>

              <code class="literal">Sorting index</code>
            </p><p>
              The thread is sorting index pages for more efficient
              access during a <code class="literal">MyISAM</code> table
              optimization operation.
            </p></li><li><p>
              <a class="indexterm" name="id2078141"></a>

              <a class="indexterm" name="id2078153"></a>

              <code class="literal">Sorting result</code>
            </p><p>
              For a <code class="literal">SELECT</code> statement, this is similar
              to <code class="literal">Creating sort index</code>, but for
              non-temporary tables.
            </p></li><li><p>
              <a class="indexterm" name="id2078194"></a>

              <a class="indexterm" name="id2078206"></a>

              <code class="literal">statistics</code>
            </p><p>
              The server is calculating statistics to develop a query
              execution plan.
            </p></li><li><p>
              <a class="indexterm" name="id2078235"></a>

              <a class="indexterm" name="id2078244"></a>

              <a class="indexterm" name="id2078256"></a>

              <a class="indexterm" name="id2078269"></a>

              <code class="literal">System lock</code>
            </p><p>
              The thread is going to request or is waiting for an
              internal or external system lock for the table. If this
              state is being caused by requests for external locks and
              you are not using multiple <span><strong class="command">mysqld</strong></span>
              servers that are accessing the same tables, you can
              disable external system locks with the
              <code class="option">--skip-external-locking</code> option. However,
              external locking is disabled by default, so it is likely
              that this option will have no effect.
            </p></li><li><p>
              <a class="indexterm" name="id2078310"></a>

              <a class="indexterm" name="id2078323"></a>

              <code class="literal">Table lock</code>
            </p><p>
              The next thread state after <code class="literal">System
              lock</code>. The thread has acquired an external lock
              and is going to request an internal table lock.
            </p></li><li><p>
              <a class="indexterm" name="id2078358"></a>

              <a class="indexterm" name="id2078370"></a>

              <code class="literal">Updating</code>
            </p><p>
              The thread is searching for rows to update and is updating
              them.
            </p></li><li><p>
              <a class="indexterm" name="id2078399"></a>

              <a class="indexterm" name="id2078412"></a>

              <code class="literal">updating main table</code>
            </p><p>
              The server is executing the first part of a multiple-table
              update. It is updating only the first table, and saving
              fields and offsets to be used for updating the other
              (reference) tables.
            </p></li><li><p>
              <a class="indexterm" name="id2078442"></a>

              <a class="indexterm" name="id2078454"></a>

              <code class="literal">updating reference tables</code>
            </p><p>
              The server is executing the second part of a
              multiple-table update and updating the matched rows from
              the other tables.
            </p></li><li><p>
              <a class="indexterm" name="id2078484"></a>

              <a class="indexterm" name="id2078496"></a>

              <code class="literal">User lock</code>
            </p><p>
              The thread is going to request or is waiting for an
              advisory lock requested with a
              <a href="functions.html#function_get-lock"><code class="literal">GET_LOCK()</code></a> call.
            </p></li><li><p>
              <a class="indexterm" name="id2078532"></a>

              <a class="indexterm" name="id2078545"></a>

              <a class="indexterm" name="id2078557"></a>

              <a class="indexterm" name="id2078569"></a>

              <code class="literal">Waiting for tables</code>, <code class="literal">Waiting
              for table</code>
            </p><p>
              The thread got a notification that the underlying
              structure for a table has changed and it needs to reopen
              the table to get the new structure. However, to reopen the
              table, it must wait until all other threads have closed
              the table in question.
            </p><p>
              This notification takes place if another thread has used
              <code class="literal">FLUSH TABLES</code> or one of the following
              statements on the table in question: <code class="literal">FLUSH TABLES
              <em class="replaceable"><code>tbl_name</code></em></code>,
              <code class="literal">ALTER TABLE</code>, <code class="literal">RENAME
              TABLE</code>, <code class="literal">REPAIR TABLE</code>,
              <code class="literal">ANALYZE TABLE</code>, or <code class="literal">OPTIMIZE
              TABLE</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2078655"></a>

              <a class="indexterm" name="id2078667"></a>

              <code class="literal">Waiting on cond</code>
            </p><p>
              A generic state in which the the thread is waiting for a
              condition to become true. No specific state information is
              available.
            </p></li><li><p>
              <a class="indexterm" name="id2078696"></a>

              <a class="indexterm" name="id2078709"></a>

              <code class="literal">Writing to net</code>
            </p><p>
              The server is writing a packet to the network.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="delayed-insert-thread-states"></a>7.5.5.3. Delayed-Insert Thread States</h4></div></div></div><a class="indexterm" name="id2078743"></a><a class="indexterm" name="id2078756"></a><p>
          These thread states are associated with processing for
          <code class="literal">DELAYED</code> inserts (see
          <a href="sql-syntax.html#insert-delayed" title="12.2.4.2. INSERT DELAYED Syntax">Section 12.2.4.2, “<code class="literal">INSERT DELAYED</code> Syntax”</a>). Some states are associated
          with connection threads that process <code class="literal">INSERT
          DELAYED</code> statements from clients. Other states are
          associated with delayed-insert handler threads that insert the
          rows. There is a delayed-insert handler thread for each table
          for which <code class="literal">INSERT DELAYED</code> statements are
          issued.
        </p><p>
          States associated with a connection thread that processes an
          <code class="literal">INSERT DELAYED</code> statement from the client:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2078814"></a>

              <a class="indexterm" name="id2078826"></a>

              <code class="literal">allocating local table</code>
            </p><p>
              The thread is preparing to feed rows to the delayed-insert
              handler thread.
            </p></li><li><p>
              <a class="indexterm" name="id2078855"></a>

              <a class="indexterm" name="id2078868"></a>

              <code class="literal">Creating delayed handler</code>
            </p><p>
              The thread is creating a handler for
              <code class="literal">DELAYED</code> inserts.
            </p></li><li><p>
              <a class="indexterm" name="id2078902"></a>

              <a class="indexterm" name="id2078915"></a>

              <code class="literal">got handler lock</code>
            </p><p>
              This occurs before the <code class="literal">allocating local
              table</code> state and after the <code class="literal">waiting for
              handler lock</code> state, when the connection thread
              gets access to the delayed-insert handler thread.
            </p></li><li><p>
              <a class="indexterm" name="id2078956"></a>

              <a class="indexterm" name="id2078968"></a>

              <code class="literal">got old table</code>
            </p><p>
              This occurs after the <code class="literal">waiting for handler
              open</code> state. The delayed-insert handler thread
              has signaled that it has ended its initialization phase,
              which includes opening the table for delayed inserts.
            </p></li><li><p>
              <a class="indexterm" name="id2079004"></a>

              <a class="indexterm" name="id2079017"></a>

              <code class="literal">storing row into queue</code>
            </p><p>
              The thread is adding a new row to the list of rows that
              the delayed-insert handler thread must insert.
            </p></li><li><p>
              <a class="indexterm" name="id2079046"></a>

              <a class="indexterm" name="id2079058"></a>

              <code class="literal">update</code>
            </p></li><li><p>
              <a class="indexterm" name="id2079083"></a>

              <a class="indexterm" name="id2079095"></a>

              <code class="literal">waiting for delay_list</code>
            </p><p>
              This occurs during the initialization phase when the
              thread is trying to find the delayed-insert handler thread
              for the table, and before attempting to gain access to the
              list of delayed-insert threads.
            </p></li><li><p>
              <a class="indexterm" name="id2079125"></a>

              <a class="indexterm" name="id2079138"></a>

              <code class="literal">waiting for handler insert</code>
            </p><p>
              An <code class="literal">INSERT DELAYED</code> handler has processed
              all pending inserts and is waiting for new ones.
            </p></li><li><p>
              <a class="indexterm" name="id2079173"></a>

              <a class="indexterm" name="id2079185"></a>

              <code class="literal">waiting for handler lock</code>
            </p><p>
              This occurs before the <code class="literal">allocating local
              table</code> state when the connection thread waits for
              access to the delayed-insert handler thread.
            </p></li><li><p>
              <a class="indexterm" name="id2079220"></a>

              <a class="indexterm" name="id2079233"></a>

              <code class="literal">waiting for handler open</code>
            </p><p>
              This occurs after the <code class="literal">Creating delayed
              handler</code> state and before the <code class="literal">got old
              table</code> state. The delayed-insert handler thread
              has just been started, and the connection thread is
              waiting for it to initialize.
            </p></li></ul></div><p>
          States associated with a delayed-insert handler thread that
          inserts the rows:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2079282"></a>

              <a class="indexterm" name="id2079295"></a>

              <code class="literal">insert</code>
            </p><p>
              The state that occurs just before inserting rows into the
              table.
            </p></li><li><p>
              <a class="indexterm" name="id2079324"></a>

              <a class="indexterm" name="id2079336"></a>

              <code class="literal">reschedule</code>
            </p><p>
              After inserting a number of rows, the delayed-insert
              thread sleeps to let other threads do work.
            </p></li><li><p>
              <a class="indexterm" name="id2079365"></a>

              <a class="indexterm" name="id2079377"></a>

              <code class="literal">upgrading lock</code>
            </p><p>
              A delayed-insert handler is trying to get a lock for the
              table to insert rows.
            </p></li><li><p>
              <a class="indexterm" name="id2079406"></a>

              <a class="indexterm" name="id2079419"></a>

              <code class="literal">Waiting for INSERT</code>
            </p><p>
              A delayed-insert handler is waiting for a connection
              thread to add rows to the queue (see <code class="literal">storing row
              into queue</code>).
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="master-thread-states"></a>7.5.5.4. Replication Master Thread States</h4></div></div></div><a class="indexterm" name="id2079460"></a><a class="indexterm" name="id2079472"></a><p>
          The following list shows the most common states you may see in
          the <code class="literal">State</code> column for the master's
          <code class="literal">Binlog Dump</code> thread. If you see no
          <code class="literal">Binlog Dump</code> threads on a master server,
          this means that replication is not running — that is,
          that no slaves are currently connected.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2079516"></a>

              <a class="indexterm" name="id2079528"></a>

              <code class="literal">Sending binlog event to slave</code>
            </p><p>
              Binary logs consist of <span class="emphasis"><em>events</em></span>, where
              an event is usually an update plus some other information.
              The thread has read an event from the binary log and is
              now sending it to the slave.
            </p></li><li><p>
              <a class="indexterm" name="id2079562"></a>

              <a class="indexterm" name="id2079574"></a>

              <code class="literal">Finished reading one binlog; switching to next
              binlog</code>
            </p><p>
              The thread has finished reading a binary log file and is
              opening the next one to send to the slave.
            </p></li><li><p>
              <a class="indexterm" name="id2079604"></a>

              <a class="indexterm" name="id2079617"></a>

              <code class="literal">Has sent all binlog to slave; waiting for binlog
              to be updated</code>
            </p><p>
              The thread has read all outstanding updates from the
              binary logs and sent them to the slave. The thread is now
              idle, waiting for new events to appear in the binary log
              resulting from new updates occurring on the master.
            </p></li><li><p>
              <a class="indexterm" name="id2079648"></a>

              <a class="indexterm" name="id2079661"></a>

              <code class="literal">Waiting to finalize termination</code>
            </p><p>
              A very brief state that occurs as the thread is stopping.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="slave-io-thread-states"></a>7.5.5.5. Replication Slave I/O Thread States</h4></div></div></div><a class="indexterm" name="id2079695"></a><a class="indexterm" name="id2079708"></a><p>
          The following list shows the most common states you see in the
          <code class="literal">State</code> column for a slave server I/O thread.
          This state also appears in the
          <code class="literal">Slave_IO_State</code> column displayed by
          <code class="literal">SHOW SLAVE STATUS</code>, so you can get a good
          view of what is happening by using that statement.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2079750"></a>

              <a class="indexterm" name="id2079763"></a>

              <code class="literal">Waiting for master update</code>
            </p><p>
              The initial state before <code class="literal">Connecting to
              master</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2079797"></a>

              <a class="indexterm" name="id2079810"></a>

              <code class="literal">Connecting to master</code>
            </p><p>
              The thread is attempting to connect to the master.
            </p></li><li><p>
              <a class="indexterm" name="id2079838"></a>

              <a class="indexterm" name="id2079851"></a>

              <code class="literal">Checking master version</code>
            </p><p>
              A state that occurs very briefly, after the connection to
              the master is established.
            </p></li><li><p>
              <a class="indexterm" name="id2079880"></a>

              <a class="indexterm" name="id2079892"></a>

              <code class="literal">Registering slave on master</code>
            </p><p>
              A state that occurs very briefly after the connection to
              the master is established.
            </p></li><li><p>
              <a class="indexterm" name="id2079921"></a>

              <a class="indexterm" name="id2079934"></a>

              <code class="literal">Requesting binlog dump</code>
            </p><p>
              A state that occurs very briefly, after the connection to
              the master is established. The thread sends to the master
              a request for the contents of its binary logs, starting
              from the requested binary log filename and position.
            </p></li><li><p>
              <a class="indexterm" name="id2079964"></a>

              <a class="indexterm" name="id2079977"></a>

              <code class="literal">Waiting to reconnect after a failed binlog dump
              request</code>
            </p><p>
              If the binary log dump request failed (due to
              disconnection), the thread goes into this state while it
              sleeps, then tries to reconnect periodically. The interval
              between retries can be specified using the <code class="literal">CHANGE
              MASTER TO</code> statement or the
              <code class="option">--master-connect-retry</code> option.
            </p></li><li><p>
              <a class="indexterm" name="id2080017"></a>

              <a class="indexterm" name="id2080030"></a>

              <code class="literal">Reconnecting after a failed binlog dump
              request</code>
            </p><p>
              The thread is trying to reconnect to the master.
            </p></li><li><p>
              <a class="indexterm" name="id2080059"></a>

              <a class="indexterm" name="id2080072"></a>

              <code class="literal">Waiting for master to send event</code>
            </p><p>
              The thread has connected to the master and is waiting for
              binary log events to arrive. This can last for a long time
              if the master is idle. If the wait lasts for
              <code class="literal">slave_net_timeout</code> seconds, a timeout
              occurs. At that point, the thread considers the connection
              to be broken and makes an attempt to reconnect.
            </p></li><li><p>
              <a class="indexterm" name="id2080109"></a>

              <a class="indexterm" name="id2080121"></a>

              <code class="literal">Queueing master event to the relay log</code>
            </p><p>
              The thread has read an event and is copying it to the
              relay log so that the SQL thread can process it.
            </p></li><li><p>
              <a class="indexterm" name="id2080151"></a>

              <a class="indexterm" name="id2080163"></a>

              <code class="literal">Waiting to reconnect after a failed master event
              read</code>
            </p><p>
              An error occurred while reading (due to disconnection).
              The thread is sleeping for the number of seconds set by
              the <code class="literal">CHANGE MASTER TO</code> statement or
              <code class="option">--master-connect-retry</code> option (default
              60) before attempting to reconnect.
            </p></li><li><p>
              <a class="indexterm" name="id2080204"></a>

              <a class="indexterm" name="id2080216"></a>

              <code class="literal">Reconnecting after a failed master event
              read</code>
            </p><p>
              The thread is trying to reconnect to the master. When
              connection is established again, the state becomes
              <code class="literal">Waiting for master to send event</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2080252"></a>

              <a class="indexterm" name="id2080265"></a>

              <code class="literal">Waiting for the slave SQL thread to free enough
              relay log space</code>
            </p><p>
              You are using a non-zero
              <code class="literal">relay_log_space_limit</code> value, and the
              relay logs have grown large enough that their combined
              size exceeds this value. The I/O thread is waiting until
              the SQL thread frees enough space by processing relay log
              contents so that it can delete some relay log files.
            </p></li><li><p>
              <a class="indexterm" name="id2080303"></a>

              <a class="indexterm" name="id2080315"></a>

              <code class="literal">Waiting for slave mutex on exit</code>
            </p><p>
              A state that occurs briefly as the thread is stopping.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="slave-sql-thread-states"></a>7.5.5.6. Replication Slave SQL Thread States</h4></div></div></div><a class="indexterm" name="id2080350"></a><a class="indexterm" name="id2080362"></a><p>
          The following list shows the most common states you may see in
          the <code class="literal">State</code> column for a slave server SQL
          thread:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2080392"></a>

              <a class="indexterm" name="id2080404"></a>

              <code class="literal">Waiting for the next event in relay log</code>
            </p><p>
              The initial state before <code class="literal">Reading event from the
              relay log</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2080439"></a>

              <a class="indexterm" name="id2080451"></a>

              <code class="literal">Reading event from the relay log</code>
            </p><p>
              The thread has read an event from the relay log so that
              the event can be processed.
            </p></li><li><p>
              <a class="indexterm" name="id2080481"></a>

              <a class="indexterm" name="id2080493"></a>

              <code class="literal">Has read all relay log; waiting for the slave I/O
              thread to update it</code>
            </p><p>
              The thread has processed all events in the relay log
              files, and is now waiting for the I/O thread to write new
              events to the relay log.
            </p></li><li><p>
              <a class="indexterm" name="id2080524"></a>

              <a class="indexterm" name="id2080536"></a>

              <code class="literal">Making temp file</code>
            </p><p>
              The thread is executing a <code class="literal">LOAD DATA
              INFILE</code> statement and is creating a temporary
              file containing the data from which the slave will read
              rows.
            </p></li><li><p>
              <a class="indexterm" name="id2080572"></a>

              <a class="indexterm" name="id2080584"></a>

              <code class="literal">Waiting for slave mutex on exit</code>
            </p><p>
              A very brief state that occurs as the thread is stopping.
            </p></li></ul></div><p>
          The <code class="literal">State</code> column for the I/O thread may
          also show the text of a statement. This indicates that the
          thread has read an event from the relay log, extracted the
          statement from it, and is executing it.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="slave-connection-thread-states"></a>7.5.5.7. Replication Slave Connection Thread States</h4></div></div></div><a class="indexterm" name="id2080630"></a><a class="indexterm" name="id2080643"></a><p>
          These thread states occur on a replication slave but are
          associated with connection threads, not with the I/O or SQL
          threads.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2080673"></a>

              <a class="indexterm" name="id2080686"></a>

              <code class="literal">Changing master</code>
            </p><p>
              The thread is processing a <code class="literal">CHANGE
              MASTER</code> statement.
            </p></li><li><p>
              <a class="indexterm" name="id2080720"></a>

              <a class="indexterm" name="id2080733"></a>

              <code class="literal">Creating table from master dump</code>
            </p><p>
              The slave is creating a table using the <code class="literal">CREATE
              TABLE</code> statement contained in the dump from the
              master. Used for <code class="literal">LOAD TABLE FROM MASTER</code>
              and <code class="literal">LOAD DATA FROM MASTER</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2080780"></a>

              <a class="indexterm" name="id2080792"></a>

              <code class="literal">Killing slave</code>
            </p><p>
              The thread is processing a <code class="literal">SLAVE STOP</code>
              statement.
            </p></li><li><p>
              <a class="indexterm" name="id2080827"></a>

              <a class="indexterm" name="id2080839"></a>

              <code class="literal">Opening master dump table</code>
            </p><p>
              This state occurs after <code class="literal">Creating table from
              master dump</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2080874"></a>

              <a class="indexterm" name="id2080887"></a>

              <code class="literal">Reading master dump table data</code>
            </p><p>
              This state occurs after <code class="literal">Opening master dump
              table</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2080921"></a>

              <a class="indexterm" name="id2080934"></a>

              <code class="literal">Rebuilding the index on master dump
              table</code>
            </p><p>
              This state occurs after <code class="literal">Reading master dump table
              data</code>.
            </p></li><li><p>
              <a class="indexterm" name="id2080969"></a>

              <a class="indexterm" name="id2080981"></a>

              <code class="literal">starting slave</code>
            </p><p>
              The thread is starting the slave threads after processing
              a successful <code class="literal">LOAD DATA FROM MASTER</code> load
              operation.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-cluster-thread-states"></a>7.5.5.8. MySQL Cluster Thread States</h4></div></div></div><a class="indexterm" name="id2081022"></a><a class="indexterm" name="id2081034"></a><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2081053"></a>

              <a class="indexterm" name="id2081066"></a>

              <code class="literal">Committing events to binlog</code>
            </p></li><li><p>
              <a class="indexterm" name="id2081091"></a>

              <a class="indexterm" name="id2081103"></a>

              <code class="literal">Opening mysql.ndb_apply_status</code>
            </p></li><li><p>
              <a class="indexterm" name="id2081128"></a>

              <a class="indexterm" name="id2081140"></a>

              <code class="literal">Processing events</code>
            </p><p>
              The thread is processing events for binary logging.
            </p></li><li><p>
              <a class="indexterm" name="id2081169"></a>

              <a class="indexterm" name="id2081181"></a>

              <code class="literal">Processing events from schema table</code>
            </p><p>
              The thread is doing the work of schema replication.
            </p></li><li><p>
              <a class="indexterm" name="id2081210"></a>

              <a class="indexterm" name="id2081223"></a>

              <code class="literal">Shutting down</code>
            </p></li><li><p>
              <a class="indexterm" name="id2081247"></a>

              <a class="indexterm" name="id2081260"></a>

              <code class="literal">Syncing ndb table schema operation and
              binlog</code>
            </p><p>
              This is used to have a correct binary log of schema
              operations for NDB.
            </p></li><li><p>
              <a class="indexterm" name="id2081289"></a>

              <a class="indexterm" name="id2081302"></a>

              <code class="literal">Waiting for event from ndbcluster</code>
            </p><p>
              The server is acting as an SQL node in a MySQL Cluster,
              and is connected to a cluster management node.
            </p></li><li><p>
              <a class="indexterm" name="id2081331"></a>

              <a class="indexterm" name="id2081344"></a>

              <code class="literal">Waiting for first event from ndbcluster</code>
            </p></li><li><p>
              <a class="indexterm" name="id2081368"></a>

              <a class="indexterm" name="id2081381"></a>

              <code class="literal">Waiting for ndbcluster binlog update to reach
              current position</code>
            </p></li><li><p>
              <a class="indexterm" name="id2081407"></a>

              <a class="indexterm" name="id2081419"></a>

              <code class="literal">Waiting for ndbcluster to start</code>
            </p></li><li><p>
              <a class="indexterm" name="id2081444"></a>

              <a class="indexterm" name="id2081457"></a>

              <code class="literal">Waiting for schema epoch</code>
            </p><p>
              The thread is waiting for a schema epoch (that is, a
              global checkpoint).
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="event-scheduler-thread-states"></a>7.5.5.9. Event Scheduler Thread States</h4></div></div></div><a class="indexterm" name="id2081492"></a><a class="indexterm" name="id2081504"></a><p>
          These states occur for the Event Scheduler thread, threads
          that are created to execute scheduled events, or threads that
          terminate the scheduler.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a class="indexterm" name="id2081528"></a>

              <a class="indexterm" name="id2081540"></a>

              <code class="literal">Clearing</code>
            </p><p>
              The scheduler thread or a thread that was executing an
              event is terminating and is about to end.
            </p></li><li><p>
              <a class="indexterm" name="id2081569"></a>

              <a class="indexterm" name="id2081582"></a>

              <code class="literal">Initialized</code>
            </p><p>
              The scheduler thread or a thread that will execute an
              event has been initialized.
            </p></li><li><p>
              <a class="indexterm" name="id2081611"></a>

              <a class="indexterm" name="id2081623"></a>

              <code class="literal">Waiting for next activation</code>
            </p><p>
              The scheduler has a non-empty event queue but the next
              activation is in the future.
            </p></li><li><p>
              <a class="indexterm" name="id2081652"></a>

              <a class="indexterm" name="id2081665"></a>

              <code class="literal">Waiting for scheduler to stop</code>
            </p><p>
              The thread issued <code class="literal">SET GLOBAL
              event_scheduler=OFF</code> and is waiting for the
              scheduler to stop.
            </p></li><li><p>
              <a class="indexterm" name="id2081700"></a>

              <a class="indexterm" name="id2081712"></a>

              <code class="literal">Waiting on empty queue</code>
            </p><p>
              The scheduler's event queue is empty and it is sleeping.
            </p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="compile-and-link-options"></a>7.5.6. How Compiling and Linking Affects the Speed of MySQL</h3></div></div></div><a class="indexterm" name="id2081748"></a><a class="indexterm" name="id2081760"></a><a class="indexterm" name="id2081773"></a><a class="indexterm" name="id2081785"></a><p>
        Most of the following tests were performed on Linux with the
        MySQL benchmarks, but they should give some indication for other
        operating systems and workloads.
      </p><p>
        You obtain the fastest executables when you link with
        <code class="option">-static</code>.
      </p><p>
        On Linux, it is best to compile the server with
        <span><strong class="command">pgcc</strong></span> and <code class="option">-O3</code>. You need about
        200MB memory to compile <code class="filename">sql_yacc.cc</code> with
        these options, because <span><strong class="command">gcc</strong></span> or
        <span><strong class="command">pgcc</strong></span> needs a great deal of memory to make all
        functions inline. You should also set <code class="literal">CXX=gcc</code>
        when configuring MySQL to avoid inclusion of the
        <code class="literal">libstdc++</code> library, which is not needed. Note
        that with some versions of <span><strong class="command">pgcc</strong></span>, the
        resulting binary runs only on true Pentium processors, even if
        you use the compiler option indicating that you want the
        resulting code to work on all x586-type processors (such as
        AMD).
      </p><p>
        By using a better compiler and compilation options, you can
        obtain a 10–30% speed increase in applications. This is
        particularly important if you compile the MySQL server yourself.
      </p><p>
        When we tested both the Cygnus CodeFusion and Fujitsu compilers,
        neither was sufficiently bug-free to allow MySQL to be compiled
        with optimizations enabled.
      </p><p>
        The standard MySQL binary distributions are compiled with
        support for all character sets. When you compile MySQL yourself,
        you should include support only for the character sets that you
        are going to use. This is controlled by the
        <code class="option">--with-charset</code> option to
        <span><strong class="command">configure</strong></span>.
      </p><p>
        Here is a list of some measurements that we have made:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If you use <span><strong class="command">pgcc</strong></span> and compile everything
            with <code class="option">-O6</code>, the <span><strong class="command">mysqld</strong></span>
            server is 1% faster than with <span><strong class="command">gcc</strong></span> 2.95.2.
          </p></li><li><p>
            If you link dynamically (without <code class="option">-static</code>),
            the result is 13% slower on Linux. Note that you still can
            use a dynamically linked MySQL library for your client
            applications. It is the server that is most critical for
            performance.
          </p></li><li><p>
            For a connection from a client to a server running on the
            same host, if you connect using TCP/IP rather than a Unix
            socket file, performance is 7.5% slower. (On Unix, if you
            connect to the hostname <code class="literal">localhost</code>, MySQL
            uses a socket file by default.)
          </p></li><li><p>
            For TCP/IP connections from a client to a server, connecting
            to a remote server on another host is 8–11% slower
            than connecting to a server on the same host, even for
            connections over 100Mb/s Ethernet.
          </p></li><li><p>
            When running our benchmark tests using secure connections
            (all data encrypted with internal SSL support) performance
            was 55% slower than with unencrypted connections.
          </p></li><li><p>
            If you compile with <code class="option">--with-debug=full</code>, most
            queries are 20% slower. Some queries may take substantially
            longer; for example, the MySQL benchmarks run 35% slower. If
            you use <code class="option">--with-debug</code> (without
            <code class="literal">=full</code>), the speed decrease is only 15%.
            For a version of <span><strong class="command">mysqld</strong></span> that has been
            compiled with <code class="option">--with-debug=full</code>, you can
            disable memory checking at runtime by starting it with the
            <code class="option">--skip-safemalloc</code> option. The execution
            speed should then be close to that obtained when configuring
            with <code class="option">--with-debug</code>.
          </p></li><li><p>
            On a Sun UltraSPARC-IIe, a server compiled with Forte 5.0 is
            4% faster than one compiled with <span><strong class="command">gcc</strong></span> 3.2.
          </p></li><li><p>
            On a Sun UltraSPARC-IIe, a server compiled with Forte 5.0 is
            4% faster in 32-bit mode than in 64-bit mode.
          </p></li><li><p>
            Compiling with <span><strong class="command">gcc</strong></span> 2.95.2 for UltraSPARC
            with the <code class="option">-mcpu=v8 -Wa,-xarch=v8plusa</code>
            options gives 4% more performance.
          </p></li><li><p>
            On Solaris 2.5.1, MIT-pthreads is 8–12% slower than
            Solaris native threads on a single processor. With greater
            loads or more CPUs, the difference should be larger.
          </p></li><li><p>
            Compiling on Linux-x86 using <span><strong class="command">gcc</strong></span> without
            frame pointers (<code class="option">-fomit-frame-pointer</code> or
            <code class="option">-fomit-frame-pointer -ffixed-ebp</code>) makes
            <span><strong class="command">mysqld</strong></span> 1–4% faster.
          </p></li></ul></div><p>
        Binary MySQL distributions for Linux that are provided by MySQL
        AB used to be compiled with <span><strong class="command">pgcc</strong></span>. We had to
        go back to regular <span><strong class="command">gcc</strong></span> due to a bug in
        <span><strong class="command">pgcc</strong></span> that would generate binaries that do not
        run on AMD. We will continue using <span><strong class="command">gcc</strong></span> until
        that bug is resolved. In the meantime, if you have a non-AMD
        machine, you can build a faster binary by compiling with
        <span><strong class="command">pgcc</strong></span>. The standard MySQL Linux binary is
        linked statically to make it faster and more portable.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="connection-threads"></a>7.5.7. How MySQL Uses Threads for Client Connections</h3></div></div></div><a class="indexterm" name="id2082146"></a><a class="indexterm" name="id2082155"></a><p>
        Connection manager threads handle client connection requests on
        the network interfaces that the server listens to. On all
        platforms, one manager thread handles TCP/IP connection
        requests. On Unix, this manager thread also handles Unix socket
        file connection requests. On Windows, a manager thread handles
        shared-memory connection requests, and another handles
        named-pipe connection requests. The server does not create
        threads to handle interfaces that it does not listen to. For
        example, a Windows server that does not have support for
        named-pipe connections enabled does not create a thread to
        handle them.
      </p><p>
        Connection manager threads associate each client connection with
        a thread dedicated to it that handles authentication and request
        processing for that connection. Manager threads create a new
        thread when necessary but try to avoid doing so by consulting
        the thread cache first to see whether it contains a thread that
        can be used for the connection. When a connection ends, its
        thread is returned to the thread cache if the cache is not full.
      </p><p>
        In this connection thread model, there are as many threads as
        there are clients currently connected, which has some drawbacks
        when server workload must scale to handle large numbers of
        connections. For example, thread creation and disposal becomes
        expensive. Also, each thread requires server and kernel
        resources, such as stack space. To accommodate a large number of
        simultaneous connections, the stack size per thread must be kept
        small, leading to a situation where it is either too small or
        the server consumes large amounts of memory. Exhaustion of other
        resources can occur as well, and scheduling overhead can become
        significant.
      </p><p>
        To control and monitor how the server manages threads that
        handle client connections, several system and status variables
        are relevant. (See <a href="server-administration.html#server-system-variables" title="5.1.3. System Variables">Section 5.1.3, “System Variables”</a>,
        and <a href="server-administration.html#server-status-variables" title="5.1.6. Status Variables">Section 5.1.6, “Status Variables”</a>.)
      </p><p>
        The thread cache has a size determined by the
        <code class="literal">thread_cache_size</code> system variable. The
        default value is 0 (no caching), which causes a thread to be set
        up for each new connection and disposed of when the connection
        terminates. Set <code class="literal">thread_cache_size</code> to
        <em class="replaceable"><code>N</code></em> to allow
        <em class="replaceable"><code>N</code></em> inactive connection threads to be
        cached. <code class="literal">thread_cache_size</code> can be set at
        server startup or changed while the server runs.
      </p><p>
        To monitor the number of threads in the cache and how many
        threads have been created because a thread could not be taken
        from the cache, monitor the <code class="literal">Threads_cached</code>
        and <code class="literal">Threads_created</code> status variables.
      </p><p>
        You can set <code class="literal">max_connections</code> at server startup
        or at runtime to control the maximum number of clients that can
        connect simultaneously.
      </p><p>
        When the thread stack is too small, this limits the complexity
        of the SQL statements which the server can handle, the recursion
        depth of stored procedures, and other memory-consuming actions.
        To set a stack size of <em class="replaceable"><code>N</code></em> bytes for
        each thread, start the server with
        <code class="option">--thread_stack=<em class="replaceable"><code>N</code></em></code>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="memory-use"></a>7.5.8. How MySQL Uses Memory</h3></div></div></div><a class="indexterm" name="id2082293"></a><p>
        The following list indicates some of the ways that the
        <span><strong class="command">mysqld</strong></span> server uses memory. Where applicable,
        the name of the system variable relevant to the memory use is
        given:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            The key buffer is shared by all threads; its size is
            determined by the <code class="literal">key_buffer_size</code>
            variable. Other buffers used by the server are allocated as
            needed. See <a href="optimization.html#server-parameters" title="7.5.2. Tuning Server Parameters">Section 7.5.2, “Tuning Server Parameters”</a>.
          </p></li><li><p>
            Each thread that is used to manage client connections uses
            some thread-specific space. The following list indicates
            these and which variables control their size:
          </p><div class="itemizedlist"><ul type="circle"><li><p>
                A stack (default 192KB, variable
                <code class="literal">thread_stack</code>)
              </p></li><li><p>
                A connection buffer (variable
                <code class="literal">net_buffer_length</code>)
              </p></li><li><p>
                A result buffer (variable
                <code class="literal">net_buffer_length</code>)
              </p></li></ul></div><p>
            The connection buffer and result buffer both begin with a
            size given by <code class="literal">net_buffer_length</code> but are
            dynamically enlarged up to
            <code class="literal">max_allowed_packet</code> bytes as needed. The
            result buffer shrinks to
            <code class="literal">net_buffer_length</code> after each SQL
            statement. While a statement is running, a copy of the
            current statement string is also allocated.
          </p></li><li><p>
            All threads share the same base memory.
          </p></li><li><p>
            When a thread is no longer needed, the memory allocated to
            it is released and returned to the system unless the thread
            goes back into the thread cache. In that case, the memory
            remains allocated.
          </p></li><li><p>
            Before MySQL 5.1.4, only compressed
            <code class="literal">MyISAM</code> tables are memory mapped. As of
            MySQL 5.1.4, the <code class="literal">myisam_use_mmap</code> system
            variable can be set to 1 to enable memory-mapping for all
            <code class="literal">MyISAM</code> tables.
          </p></li><li><p>
            Each request that performs a sequential scan of a table
            allocates a <em class="firstterm">read buffer</em> (variable
            <code class="literal">read_buffer_size</code>).
          </p></li><li><p>
            When reading rows in an arbitrary sequence (for example,
            following a sort), a <em class="firstterm">random-read
            buffer</em> (variable
            <code class="literal">read_rnd_buffer_size</code>) may be allocated in
            order to avoid disk seeks.
          </p></li><li><p>
            All joins are executed in a single pass, and most joins can
            be done without even using a temporary table. Most temporary
            tables are memory-based hash tables. Temporary tables with a
            large row length (calculated as the sum of all column
            lengths) or that contain <code class="literal">BLOB</code> columns are
            stored on disk.
          </p><p>
            If an internal heap table exceeds the size of
            <code class="literal">tmp_table_size</code>, MySQL handles this
            automatically by changing the in-memory heap table to a
            disk-based <code class="literal">MyISAM</code> table as necessary. You
            can also increase the temporary table size by setting the
            <code class="literal">tmp_table_size</code> option to
            <span><strong class="command">mysqld</strong></span>, or by setting the SQL option
            <code class="literal">SQL_BIG_TABLES</code> in the client program. See
            <a href="server-administration.html#server-session-variables" title="5.1.4. Session System Variables">Section 5.1.4, “Session System Variables”</a>.
          </p><p class="mnmas"><b>MySQL Enterprise</b>
              Subscribers to the MySQL Enterprise Monitor are alerted
              when temporary tables exceed
              <code class="literal">tmp_table_size</code>. Advisors make
              recommendations for the optimum value of
              <code class="literal">tmp_table_size</code> based on actual table
              usage. For more information about the MySQL Enterprise
              Monitor please see
              <a href="http://www.mysql.com/products/enterprise/advisors.html" target="_top">http://www.mysql.com/products/enterprise/advisors.html</a>.
            </p></li><li><p>
            Most requests that perform a sort allocate a sort buffer and
            zero to two temporary files depending on the result set
            size. See <a href="error-handling.html#temporary-files" title="B.1.4.4. Where MySQL Stores Temporary Files">Section B.1.4.4, “Where MySQL Stores Temporary Files”</a>.
          </p></li><li><p>
            Almost all parsing and calculating is done in a local memory
            store. No memory overhead is needed for small items, so the
            normal slow memory allocation and freeing is avoided. Memory
            is allocated only for unexpectedly large strings. This is
            done with <code class="literal">malloc()</code> and
            <code class="literal">free()</code>.
          </p></li><li><p>
            For each <code class="literal">MyISAM</code> table that is opened, the
            index file is opened once; the data file is opened once for
            each concurrently running thread. For each concurrent
            thread, a table structure, column structures for each
            column, and a buffer of size <code class="literal">3 ×
            <em class="replaceable"><code>N</code></em></code> are allocated (where
            <em class="replaceable"><code>N</code></em> is the maximum row length, not
            counting <code class="literal">BLOB</code> columns). A
            <code class="literal">BLOB</code> column requires five to eight bytes
            plus the length of the <code class="literal">BLOB</code> data. The
            <code class="literal">MyISAM</code> storage engine maintains one extra
            row buffer for internal use.
          </p></li><li><p>
            For each table having <code class="literal">BLOB</code> columns, a
            buffer is enlarged dynamically to read in larger
            <code class="literal">BLOB</code> values. If you scan a table, a
            buffer as large as the largest <code class="literal">BLOB</code> value
            is allocated.
          </p></li><li><p>
            Handler structures for all in-use tables are saved in a
            cache and managed as a FIFO. By default, the cache has 64
            entries. If a table has been used by two running threads at
            the same time, the cache contains two entries for the table.
            See <a href="optimization.html#table-cache" title="7.4.8. How MySQL Opens and Closes Tables">Section 7.4.8, “How MySQL Opens and Closes Tables”</a>.
          </p></li><li><p>
            A <code class="literal">FLUSH TABLES</code> statement or
            <span><strong class="command">mysqladmin flush-tables</strong></span> command closes
            all tables that are not in use at once and marks all in-use
            tables to be closed when the currently executing thread
            finishes. This effectively frees most in-use memory.
            <code class="literal">FLUSH TABLES</code> does not return until all
            tables have been closed.
          </p></li><li><p>
            The server caches information in memory as a result of
            <code class="literal">GRANT</code>, <code class="literal">CREATE USER</code>,
            <code class="literal">CREATE SERVER</code>, and <code class="literal">INSTALL
            PLUGIN</code> statements. This memory is not released by
            the corresponding <code class="literal">REVOKE</code>, <code class="literal">DROP
            USER</code>, <code class="literal">DROP SERVER</code>, and
            <code class="literal">UNINSTALL PLUGIN</code> statements, so for a
            server that executes many instances of the statements that
            cause caching, there will be an increase in memory use. This
            cached memory can be freed with <code class="literal">FLUSH
            PRIVILEGES</code>.
          </p></li></ul></div><p>
        <span><strong class="command">ps</strong></span> and other system status programs may
        report that <span><strong class="command">mysqld</strong></span> uses a lot of memory. This
        may be caused by thread stacks on different memory addresses.
        For example, the Solaris version of <span><strong class="command">ps</strong></span> counts
        the unused memory between stacks as used memory. You can verify
        this by checking available swap with <code class="literal">swap -s</code>.
        We test <span><strong class="command">mysqld</strong></span> with several memory-leakage
        detectors (both commercial and Open Source), so there should be
        no memory leaks.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="internal-temporary-tables"></a>7.5.9. How MySQL Uses Internal Temporary Tables</h3></div></div></div><a class="indexterm" name="id2082835"></a><p>
        In some cases, the server creates internal temporary tables
        while processing queries. A temporary table can be held in
        memory and processed by the <code class="literal">MEMORY</code> storage
        engine, or stored on disk and processed by the
        <code class="literal">MyISAM</code> storage engine. Temporary tables can
        be created under conditions such as these:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If there is an <code class="literal">ORDER BY</code> clause and a
            different <code class="literal">GROUP BY</code> clause, or if the
            <code class="literal">ORDER BY</code> or <code class="literal">GROUP BY</code>
            contains columns from tables other than the first table in
            the join queue, a temporary table is created.
          </p></li><li><p>
            If you use the <code class="literal">SQL_SMALL_RESULT</code> option,
            MySQL uses an in-memory temporary table.
          </p></li><li><p>
            <code class="literal">DISTINCT</code> combined with <code class="literal">ORDER
            BY</code> may require a temporary table.
          </p></li></ul></div><p>
        You can tell whether a query requires a temporary table by using
        <code class="literal">EXPLAIN</code> and checking the
        <code class="literal">Extra</code> column to see whether it says
        <code class="literal">Using temporary</code>. See
        <a href="optimization.html#using-explain" title="7.2.1. Optimizing Queries with EXPLAIN">Section 7.2.1, “Optimizing Queries with <code class="literal">EXPLAIN</code>”</a>.
      </p><p>
        Some conditions prevent the use of a <code class="literal">MEMORY</code>
        temporary table, in which case the server uses a
        <code class="literal">MyISAM</code> table instead:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Presence of a <code class="literal">TEXT</code> or
            <code class="literal">BLOB</code> column in the table
          </p></li><li><p>
            Presence of any column in a <code class="literal">GROUP BY</code> or
            <code class="literal">DISTINCT</code> clause larger than 512 bytes
          </p></li><li><p>
            Presence of any column larger than 512 bytes in the
            <code class="literal">SELECT</code> list, if <code class="literal">UNION</code>
            or <code class="literal">UNION ALL</code> is used.
          </p></li></ul></div><p>
        A temporary table that is created initially as a
        <code class="literal">MEMORY</code> table might be converted to a
        <code class="literal">MyISAM</code> table and stored on disk if it becomes
        too large. The <code class="literal">max_heap_table_size</code> system
        variable determines how large <code class="literal">MEMORY</code> tables
        are allowed to grow. It applies to all <code class="literal">MEMORY</code>
        tables, including those created with <code class="literal">CREATE
        TABLE</code>. However, for internal <code class="literal">MEMORY</code>
        tables, the actual maximum size is determined by
        <code class="literal">max_heap_table_size</code> in combination with
        <code class="literal">tmp_table_size</code>: Whichever value is smaller is
        the one that applies. If the size of an internal
        <code class="literal">MEMORY</code> table exceeds the limit, MySQL
        automatically converts it to an on-disk
        <code class="literal">MyISAM</code> table.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dns"></a>7.5.10. How MySQL Uses DNS</h3></div></div></div><a class="indexterm" name="id2083124"></a><a class="indexterm" name="id2083133"></a><p>
        When a new client connects to <span><strong class="command">mysqld</strong></span>,
        <span><strong class="command">mysqld</strong></span> spawns a new thread to handle the
        request. This thread first checks whether the hostname is in the
        hostname cache. If not, the thread attempts to resolve the
        hostname:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            If the operating system supports the thread-safe
            <code class="literal">gethostbyaddr_r()</code> and
            <code class="literal">gethostbyname_r()</code> calls, the thread uses
            them to perform hostname resolution.
          </p></li><li><p>
            If the operating system does not support the thread-safe
            calls, the thread locks a mutex and calls
            <code class="literal">gethostbyaddr()</code> and
            <code class="literal">gethostbyname()</code> instead. In this case, no
            other thread can resolve hostnames that are not in the
            hostname cache until the first thread unlocks the mutex.
          </p></li></ul></div><p>
        You can disable DNS hostname lookups by starting
        <span><strong class="command">mysqld</strong></span> with the
        <code class="option">--skip-name-resolve</code> option. However, in this
        case, you can use only IP numbers in the MySQL grant tables.
      </p><p>
        If you have a very slow DNS and many hosts, you can get more
        performance by either disabling DNS lookups with
        <code class="option">--skip-name-resolve</code> or by increasing the
        <code class="literal">HOST_CACHE_SIZE</code> define (default value: 128)
        and recompiling <span><strong class="command">mysqld</strong></span>.
      </p><p>
        You can disable the hostname cache by starting the server with
        the <code class="option">--skip-host-cache</code> option. To clear the
        hostname cache, issue a <code class="literal">FLUSH HOSTS</code> statement
        or execute the <span><strong class="command">mysqladmin flush-hosts</strong></span>
        command.
      </p><p>
        To disallow TCP/IP connections entirely, start
        <span><strong class="command">mysqld</strong></span> with the
        <code class="option">--skip-networking</code> option.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="disk-issues"></a>7.6. Disk Issues</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#symbolic-links">7.6.1. Using Symbolic Links</a></span></dt></dl></div><a class="indexterm" name="id2083281"></a><a class="indexterm" name="id2083290"></a><div class="itemizedlist"><ul type="disc"><li><p>
          Disk seeks are a huge performance bottleneck. This problem
          becomes more apparent when the amount of data starts to grow
          so large that effective caching becomes impossible. For large
          databases where you access data more or less randomly, you can
          be sure that you need at least one disk seek to read and a
          couple of disk seeks to write things. To minimize this
          problem, use disks with low seek times.
        </p></li><li><p>
          Increase the number of available disk spindles (and thereby
          reduce the seek overhead) by either symlinking files to
          different disks or striping the disks:
        </p><div class="itemizedlist"><ul type="circle"><li><p>
              Using symbolic links
            </p><p>
              This means that, for <code class="literal">MyISAM</code> tables, you
              symlink the index file and data files from their usual
              location in the data directory to another disk (that may
              also be striped). This makes both the seek and read times
              better, assuming that the disk is not used for other
              purposes as well. See <a href="optimization.html#symbolic-links" title="7.6.1. Using Symbolic Links">Section 7.6.1, “Using Symbolic Links”</a>.
            </p></li><li><p>
              <a class="indexterm" name="id2083353"></a>

              Striping
            </p><p>
              Striping means that you have many disks and put the first
              block on the first disk, the second block on the second
              disk, and the <em class="replaceable"><code>N</code></em>-th block on the
              (<code class="literal"><em class="replaceable"><code>N</code></em> MOD
              <em class="replaceable"><code>number_of_disks</code></em></code>)
              disk, and so on. This means if your normal data size is
              less than the stripe size (or perfectly aligned), you get
              much better performance. Striping is very dependent on the
              operating system and the stripe size, so benchmark your
              application with different stripe sizes. See
              <a href="optimization.html#custom-benchmarks" title="7.1.5. Using Your Own Benchmarks">Section 7.1.5, “Using Your Own Benchmarks”</a>.
            </p><p>
              The speed difference for striping is
              <span class="emphasis"><em>very</em></span> dependent on the parameters.
              Depending on how you set the striping parameters and
              number of disks, you may get differences measured in
              orders of magnitude. You have to choose to optimize for
              random or sequential access.
            </p></li></ul></div></li><li><p>
          For reliability, you may want to use RAID 0+1 (striping plus
          mirroring), but in this case, you need 2 ×
          <em class="replaceable"><code>N</code></em> drives to hold
          <em class="replaceable"><code>N</code></em> drives of data. This is probably
          the best option if you have the money for it. However, you may
          also have to invest in some volume-management software to
          handle it efficiently.
        </p></li><li><p>
          A good option is to vary the RAID level according to how
          critical a type of data is. For example, store semi-important
          data that can be regenerated on a RAID 0 disk, but store
          really important data such as host information and logs on a
          RAID 0+1 or RAID <em class="replaceable"><code>N</code></em> disk. RAID
          <em class="replaceable"><code>N</code></em> can be a problem if you have many
          writes, due to the time required to update the parity bits.
        </p></li><li><p>
          On Linux, you can get much more performance by using
          <code class="literal">hdparm</code> to configure your disk's interface.
          (Up to 100% under load is not uncommon.) The following
          <code class="literal">hdparm</code> options should be quite good for
          MySQL, and probably for many other applications:
        </p><pre class="programlisting">hdparm -m 16 -d 1
</pre><p>
          Note that performance and reliability when using this command
          depend on your hardware, so we strongly suggest that you test
          your system thoroughly after using <code class="literal">hdparm</code>.
          Please consult the <code class="literal">hdparm</code> manual page for
          more information. If <code class="literal">hdparm</code> is not used
          wisely, filesystem corruption may result, so back up
          everything before experimenting!
        </p></li><li><p>
          You can also set the parameters for the filesystem that the
          database uses:
        </p><p>
          If you do not need to know when files were last accessed
          (which is not really useful on a database server), you can
          mount your filesystems with the <code class="option">-o noatime</code>
          option. That skips updates to the last access time in inodes
          on the filesystem, which avoids some disk seeks.
        </p><p>
          On many operating systems, you can set a filesystem to be
          updated asynchronously by mounting it with the <code class="option">-o
          async</code> option. If your computer is reasonably stable,
          this should give you more performance without sacrificing too
          much reliability. (This flag is on by default on Linux.)
        </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="symbolic-links"></a>7.6.1. Using Symbolic Links</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="optimization.html#symbolic-links-to-databases">7.6.1.1. Using Symbolic Links for Databases on Unix</a></span></dt><dt><span class="section"><a href="optimization.html#symbolic-links-to-tables">7.6.1.2. Using Symbolic Links for Tables on Unix</a></span></dt><dt><span class="section"><a href="optimization.html#windows-symbolic-links">7.6.1.3. Using Symbolic Links for Databases on Windows</a></span></dt></dl></div><a class="indexterm" name="id2083527"></a><a class="indexterm" name="id2083536"></a><p>
        You can move tables and databases from the database directory to
        other locations and replace them with symbolic links to the new
        locations. You might want to do this, for example, to move a
        database to a file system with more free space or increase the
        speed of your system by spreading your tables to different disk.
      </p><p>
        The recommended way to do this is simply to symlink databases to
        a different disk. Symlink tables only as a last resort.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="symbolic-links-to-databases"></a>7.6.1.1. Using Symbolic Links for Databases on Unix</h4></div></div></div><a class="indexterm" name="id2083567"></a><p>
          On Unix, the way to symlink a database is first to create a
          directory on some disk where you have free space and then to
          create a symlink to it from the MySQL data directory.
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mkdir /dr1/databases/test</code></strong>
shell&gt; <strong class="userinput"><code>ln -s /dr1/databases/test <em class="replaceable"><code>/path/to/datadir</code></em></code></strong>
</pre><p>
          MySQL does not support linking one directory to multiple
          databases. Replacing a database directory with a symbolic link
          works as long as you do not make a symbolic link between
          databases. Suppose that you have a database
          <code class="literal">db1</code> under the MySQL data directory, and
          then make a symlink <code class="literal">db2</code> that points to
          <code class="literal">db1</code>:
        </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>/path/to/datadir</code></em></code></strong>
shell&gt; <strong class="userinput"><code>ln -s db1 db2</code></strong>
</pre><p>
          The result is that, or any table <code class="literal">tbl_a</code> in
          <code class="literal">db1</code>, there also appears to be a table
          <code class="literal">tbl_a</code> in <code class="literal">db2</code>. If one
          client updates <code class="literal">db1.tbl_a</code> and another client
          updates <code class="literal">db2.tbl_a</code>, problems are likely to
          occur.
        </p><p>
          However, if you really need to do this, it is possible by
          altering the source file
          <code class="filename">mysys/my_symlink.c</code>, in which you should
          look for the following statement:
        </p><pre class="programlisting">if (!(MyFlags &amp; MY_RESOLVE_LINK) ||
    (!lstat(filename,&amp;stat_buff) &amp;&amp; S_ISLNK(stat_buff.st_mode)))
</pre><p>
          Change the statement to this:
        </p><pre class="programlisting">if (1)
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="symbolic-links-to-tables"></a>7.6.1.2. Using Symbolic Links for Tables on Unix</h4></div></div></div><a class="indexterm" name="id2083724"></a><p>
          You should not symlink tables on systems that do not have a
          fully operational <code class="literal">realpath()</code> call. (Linux
          and Solaris support <code class="literal">realpath()</code>). You can
          check whether your system supports symbolic links by issuing a
          <code class="literal">SHOW VARIABLES LIKE 'have_symlink'</code>
          statement.
        </p><p>
          Symlinks are fully supported only for
          <code class="literal">MyISAM</code> tables. For files used by tables for
          other storage engines, you may get strange problems if you try
          to use symbolic links.
        </p><p>
          The handling of symbolic links for <code class="literal">MyISAM</code>
          tables works as follows:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              In the data directory, you always have the table format
              (<code class="filename">.frm</code>) file, the data
              (<code class="filename">.MYD</code>) file, and the index
              (<code class="filename">.MYI</code>) file. The data file and index
              file can be moved elsewhere and replaced in the data
              directory by symlinks. The format file cannot.
            </p></li><li><p>
              You can symlink the data file and the index file
              independently to different directories.
            </p></li><li><p>
              You can instruct a running MySQL server to perform the
              symlinking by using the <code class="literal">DATA DIRECTORY</code>
              and <code class="literal">INDEX DIRECTORY</code> options to
              <code class="literal">CREATE TABLE</code>. See
              <a href="sql-syntax.html#create-table" title="12.1.10. CREATE TABLE Syntax">Section 12.1.10, “<code class="literal">CREATE TABLE</code> Syntax”</a>. Alternatively, symlinking
              can be accomplished manually from the command line using
              <code class="literal">ln -s</code> if <span><strong class="command">mysqld</strong></span> is
              not running.
            </p></li><li><p>
              <span><strong class="command">myisamchk</strong></span> does not replace a symlink
              with the data file or index file. It works directly on the
              file to which the symlink points. Any temporary files are
              created in the directory where the data file or index file
              is located. The same is true for the <code class="literal">ALTER
              TABLE</code>, <code class="literal">OPTIMIZE TABLE</code>, and
              <code class="literal">REPAIR TABLE</code> statements.
            </p></li><li><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                When you drop a table that is using symlinks,
                <span class="emphasis"><em>both the symlink and the file to which the
                symlink points are dropped</em></span>. This is an
                extremely good reason why you should
                <span class="emphasis"><em>not</em></span> run <span><strong class="command">mysqld</strong></span>
                as the system <code class="literal">root</code> or allow system
                users to have write access to MySQL database
                directories.
              </p></div></li><li><p>
              If you rename a table with <code class="literal">ALTER TABLE ...
              RENAME</code> or <code class="literal">RENAME TABLE</code> and
              you do not move the table to another database, the
              symlinks in the database directory are renamed to the new
              names and the data file and index file are renamed
              accordingly.
            </p></li><li><p>
              If you use <code class="literal">ALTER TABLE ... RENAME</code> or
              <code class="literal">RENAME TABLE</code> to move a table to another
              database, the table is moved to the other database
              directory. If the table name changed, the symlinks in the
              new database directory are renamed to the new names and
              the data file and index file are renamed accordingly.
            </p></li><li><p>
              If you are not using symlinks, you should use the
              <code class="option">--skip-symbolic-links</code> option to
              <span><strong class="command">mysqld</strong></span> to ensure that no one can use
              <span><strong class="command">mysqld</strong></span> to drop or rename a file outside
              of the data directory.
            </p></li></ul></div><p>
          Table symlink operations that are not yet supported:
        </p><a class="indexterm" name="id2083996"></a><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">ALTER TABLE</code> ignores the <code class="literal">DATA
              DIRECTORY</code> and <code class="literal">INDEX DIRECTORY</code>
              table options.
            </p></li><li><p>
              <code class="literal">BACKUP TABLE</code> and <code class="literal">RESTORE
              TABLE</code> do not respect symbolic links.
            </p></li><li><p>
              The <code class="filename">.frm</code> file must
              <span class="emphasis"><em>never</em></span> be a symbolic link (as
              indicated previously, only the data and index files can be
              symbolic links). Attempting to do this (for example, to
              make synonyms) produces incorrect results. Suppose that
              you have a database <code class="literal">db1</code> under the MySQL
              data directory, a table <code class="literal">tbl1</code> in this
              database, and in the <code class="literal">db1</code> directory you
              make a symlink <code class="literal">tbl2</code> that points to
              <code class="literal">tbl1</code>:
            </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cd <em class="replaceable"><code>/path/to/datadir</code></em>/db1</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.frm tbl2.frm</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.MYD tbl2.MYD</code></strong>
shell&gt; <strong class="userinput"><code>ln -s tbl1.MYI tbl2.MYI</code></strong>
</pre><p>
              Problems result if one thread reads
              <code class="literal">db1.tbl1</code> and another thread updates
              <code class="literal">db1.tbl2</code>:
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                  The query cache is “<span class="quote">fooled</span>” (it has no
                  way of knowing that <code class="literal">tbl1</code> has not
                  been updated, so it returns outdated results).
                </p></li><li><p>
                  <code class="literal">ALTER</code> statements on
                  <code class="literal">tbl2</code> fail.
                </p></li></ul></div></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="windows-symbolic-links"></a>7.6.1.3. Using Symbolic Links for Databases on Windows</h4></div></div></div><a class="indexterm" name="id2084202"></a><a class="indexterm" name="id2084211"></a><a class="indexterm" name="id2084220"></a><p>
          Symbolic links are enabled by default for all Windows servers.
          This enables you to put a database directory on a different
          disk by setting up a symbolic link to it. This is similar to
          the way that database symbolic links work on Unix, although
          the procedure for setting up the link is different. If you do
          not need symbolic links, you can disable them using the
          <code class="option">--skip-symbolic-links</code> option.
        </p><p>
          On Windows, create a symbolic link to a MySQL database by
          creating a file in the data directory that contains the path
          to the destination directory. The file should be named
          <code class="filename"><em class="replaceable"><code>db_name</code></em>.sym</code>,
          where <em class="replaceable"><code>db_name</code></em> is the database name.
        </p><p>
          Suppose that the MySQL data directory is
          <code class="filename">C:\mysql\data</code> and you want to have
          database <code class="literal">foo</code> located at
          <code class="filename">D:\data\foo</code>. Set up a symlink using this
          procedure
        </p><div class="orderedlist"><ol type="1"><li><p>
              Make sure that the <code class="filename">D:\data\foo</code>
              directory exists by creating it if necessary. If you
              already have a database directory named
              <code class="filename">foo</code> in the data directory, you should
              move it to <code class="filename">D:\data</code>. Otherwise, the
              symbolic link will be ineffective. To avoid problems, make
              sure that the server is not running when you move the
              database directory.
            </p></li><li><p>
              Create a text file
              <code class="filename">C:\mysql\data\foo.sym</code> that contains
              the pathname <code class="literal">D:\data\foo\</code>.
            </p></li></ol></div><p>
          After this, all tables created in the database
          <code class="literal">foo</code> are created in
          <code class="filename">D:\data\foo</code>.
        </p><p>
          The following limitations apply to the use of
          <code class="filename">.sym</code> files for database symbolic linking
          on Windows:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              The symbolic link is not used if a directory with the same
              name as the database exists in the MySQL data directory.
            </p></li><li><p>
              The <code class="option">--innodb_file_per_table</code> option cannot
              be used.
            </p></li><li><p>
              If you run <span><strong class="command">mysqld</strong></span> as a service, you
              cannot use a mapped drive to a remote server as the
              destination of the symbolic link. As a workaround, you can
              use the full path
              (<code class="filename">\\servername\path\</code>).
            </p></li></ul></div></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-and-recovery.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="language-structure.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 6. Backup and Recovery </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 8. Language Structure</td></tr></table></div></body></html>
